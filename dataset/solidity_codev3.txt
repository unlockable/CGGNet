pragma solidity 0.5.6; contract con_name { function _getSalt ( uint96 identifier ) internal view returns ( bytes32 salt ) { assembly { salt := or ( shl ( 96 , caller ) , identifier ) } }}
pragma solidity 0.5.6; contract con_name { function _getPrelude ( address vaultContract ) internal pure returns ( bytes memory prelude ) { prelude = abi . encodePacked ( bytes22 ( 0x6e2b13cccec913420a21e4d11b2dcd3c3318602b5773 ) , vaultContract , bytes2 ( 0xff5b ) ) ; }}
pragma solidity 0.5.6; contract con_name { function _verifyPrelude ( address metamorphicContract , bytes memory prelude ) internal view { bytes memory runtimeHeader ; assembly { runtimeHeader := mload ( 0x40 ) mstore ( 0x40 , add ( runtimeHeader , 0x60 ) ) mstore ( runtimeHeader , 44 ) extcodecopy ( metamorphicContract , add ( runtimeHeader , 0x20 ) , 0 , 44 ) } require ( keccak256 ( abi . encodePacked ( prelude ) ) == keccak256 ( abi . encodePacked ( runtimeHeader ) ) , "Deployed runtime code does not have the required prelude." ) ; }}
pragma solidity 0.5.6; contract con_name { function _getMetamorphicContractAddress ( address transientContract ) internal pure returns ( address metamorphicContract ) { metamorphicContract = address ( uint160 ( uint256 ( keccak256 ( abi . encodePacked ( bytes2 ( 0xd694 ) , transientContract , byte ( 0x01 ) ) ) ) ) ) ; }}
pragma solidity 0.5.6; contract con_name { function _getVaultContractInitializationCode ( address transientContract ) internal pure returns ( bytes memory vaultContractInitializationCode ) { vaultContractInitializationCode = abi . encodePacked ( bytes27 ( 0x586e2b13cccec913420a21e4d11b2dcd3c33185857595959303173 ) , transientContract , bytes10 ( 0x5af160315981595939f3 ) ) ; }}
pragma solidity 0.5.6; contract con_name { function _getVaultContractAddress ( bytes memory vaultContractInitializationCode ) internal pure returns ( address vaultContract ) { vaultContract = address ( uint160 ( uint256 ( keccak256 ( abi . encodePacked ( byte ( 0xff ) , address ( 0x00000000002B13cCcEC913420A21e4D11b2DCd3C ) , bytes32 ( 0 ) , keccak256 ( vaultContractInitializationCode ) ) ) ) ) ) ; }}
pragma solidity 0.5.6; contract con_name { bytes _initCode ; function getInitializationCode ( ) external view returns ( bytes memory initializationCode ) { initializationCode = _initCode ; }}
pragma solidity 0.4.26; contract con_name { function external_call ( address destination , uint value , uint dataLength , bytes data ) internal returns ( bool ) { bool result ; assembly { let x := mload ( 0x40 ) let d := add ( data , 32 ) result := call ( sub ( gas , 34710 ) , destination , value , d , dataLength , x , 0 ) } return result ; }}
pragma solidity 0.4.26; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public constant returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }}
pragma solidity 0.4.26; contract con_name { address[] owners ; function getOwners ( ) public constant returns ( address [ ] ) { return owners ; }}
pragma solidity 0.4.26; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public constant returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => bool) _deployed ; function findCreate2Address ( bytes32 salt , bytes calldata initCode ) external view returns ( address deploymentAddress ) { deploymentAddress = address ( uint160 ( uint256 ( keccak256 ( abi . encodePacked ( hex"ff" , address ( this ) , salt , keccak256 ( abi . encodePacked ( initCode ) ) ) ) ) ) ) ; if ( _deployed [ deploymentAddress ] ) { return address ( 0 ) ; } }}
pragma solidity 0.5.8; contract con_name { mapping(address => bool) _deployed ; function findCreate2AddressViaHash ( bytes32 salt , bytes32 initCodeHash ) external view returns ( address deploymentAddress ) { deploymentAddress = address ( uint160 ( uint256 ( keccak256 ( abi . encodePacked ( hex"ff" , address ( this ) , salt , initCodeHash ) ) ) ) ) ; if ( _deployed [ deploymentAddress ] ) { return address ( 0 ) ; } }}
pragma solidity 0.5.8; contract con_name { mapping(address => bool) _deployed ; function hasBeenDeployed ( address deploymentAddress ) external view returns ( bool ) { return _deployed [ deploymentAddress ] ; }}
pragma solidity 0.4.23; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) external payable { address _impl = implementation ( ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.4.23; contract con_name { bytes32 implementationPosition ; function implementation ( ) public view returns ( address impl ) { bytes32 position = implementationPosition ; assembly { impl := sload ( position ) } }}
pragma solidity 0.4.23; contract con_name { bytes32 implementationPosition ; function _setImplementation ( address newImplementation ) internal { bytes32 position = implementationPosition ; assembly { sstore ( position , newImplementation ) } }}
pragma solidity 0.4.23; contract con_name { bytes32 proxyOwnerPosition ; function proxyOwner ( ) public view returns ( address owner ) { bytes32 position = proxyOwnerPosition ; assembly { owner := sload ( position ) } }}
pragma solidity 0.4.23; contract con_name { bytes32 pendingProxyOwnerPosition ; function pendingProxyOwner ( ) public view returns ( address pendingOwner ) { bytes32 position = pendingProxyOwnerPosition ; assembly { pendingOwner := sload ( position ) } }}
pragma solidity 0.4.23; contract con_name { bytes32 proxyOwnerPosition ; function _setUpgradeabilityOwner ( address newProxyOwner ) internal { bytes32 position = proxyOwnerPosition ; assembly { sstore ( position , newProxyOwner ) } }}
pragma solidity 0.4.23; contract con_name { bytes32 pendingProxyOwnerPosition ; function _setPendingUpgradeabilityOwner ( address newPendingProxyOwner ) internal { bytes32 position = pendingProxyOwnerPosition ; assembly { sstore ( position , newPendingProxyOwner ) } }}
pragma solidity 0.4.24; contract con_name { function tokenFallback ( address from , uint256 qty , bytes data ) external ; function receiveApproval ( address from , uint256 tokens , address token , bytes data ) external ; } library SafeMath { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address target ) internal view returns ( bool ) { uint256 codeLength ; assembly { codeLength := extcodesize ( target ) } return codeLength > 0 ; }}
pragma solidity 0.5.6; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.6; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.24; contract con_name { function tokenFallback ( address from , uint256 qty , bytes data ) external ; } library SafeMath { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.23; contract con_name { function ( ) external payable { assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , returndatasize , calldatasize ) let result := delegatecall ( gas , sload ( 0xecfd2ee7a4295d533a08882dec6729582fc6bda7812f32b75ae1ea4807d08982 ) , ptr , calldatasize , returndatasize , returndatasize ) returndatacopy ( ptr , 0 , returndatasize ) switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }}
pragma solidity 0.4.23; contract con_name { bytes32 implementationPosition ; function implementation ( ) public returns ( address impl ) { bytes32 position = implementationPosition ; assembly { impl := sload ( position ) } }}
pragma solidity 0.4.23; contract con_name { function ( ) external payable { assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , returndatasize , calldatasize ) let result := delegatecall ( gas , sload ( 0xc20777594ecafd73f44a72aa5ad2de8704211212d04473d4b208539e34ba14eb ) , ptr , calldatasize , returndatasize , returndatasize ) returndatacopy ( ptr , 0 , returndatasize ) switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }}
pragma solidity 0.4.23; contract con_name { bytes32 implementationPosition ; function ( ) external payable { bytes32 position = implementationPosition ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , returndatasize , calldatasize ) let result := delegatecall ( gas , sload ( position ) , ptr , calldatasize , returndatasize , returndatasize ) returndatacopy ( ptr , 0 , returndatasize ) switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }}
pragma solidity 0.4.23; contract con_name { function ( ) public payable { assembly { calldatacopy ( 0 , 0 , calldatasize ) let result := delegatecall ( gas , 0x0D6C969d0004B431189f834203CE0f5530e06259 , 0 , calldatasize , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ) switch result case 0 { revert ( 0 , returndatasize ) } default { return ( 0 , returndatasize ) } } }}
pragma solidity 0.4.18; contract con_name { uint256 MAX_UINT ; function totalSupply ( ) public view returns ( uint ) { return MAX_UINT ; }}
pragma solidity 0.4.18; contract con_name { uint256 MAX_UINT ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return MAX_UINT ; }}
pragma solidity 0.4.18; contract con_name { uint256 MAX_UINT ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return MAX_UINT ; }}
pragma solidity 0.4.13; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) ; } contract owned { address public owner ; function owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.21; contract con_name { function isContract ( address addr ) internal view returns ( bool ) { if ( addr == 0x0 ) { return false ; } else { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; } }}
pragma solidity 0.4.21; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { function ( ) payable public { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function mint ( address _sender , address _to ) public returns ( bool ) ; function approve ( address _sender , address _to , uint256 _tokenId ) public returns ( bool ) ; function setApprovalForAll ( address _sender , address _operator , bool _approved ) public returns ( bool ) ; function transferFrom ( address _sender , address _from , address _to , uint256 _tokenId ) public returns ( bool ) ; function safeTransferFrom ( address _sender , address _from , address _to , uint256 _tokenId ) public returns ( bool ) ; function safeTransferFrom ( address _sender , address _from , address _to , uint256 _tokenId , bytes memory _data ) public returns ( bool ) ; } contract Ownable { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function safeTransferFrom ( address , address , address , uint256 , bytes memory ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function getOwner ( ) public view returns ( address ) { return owner ; }}
pragma solidity 0.4.24; contract con_name { bool canAnyMint ; mapping(address => bool) minters ; function mint ( address _sender , address ) public returns ( bool ) { require ( canAnyMint , "no minting possible" ) ; return minters [ _sender ] ; }}
pragma solidity 0.4.24; contract con_name { function approve ( address , address , uint256 ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { function setApprovalForAll ( address , address , bool ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address , address , address , uint256 ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { function safeTransferFrom ( address , address , address , uint256 ) public returns ( bool ) { return true ; }}
pragma solidity 0.5.6; contract con_name { function safeAdd ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.6; contract con_name { function safeSub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.6; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.6; contract con_name { function safeMul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.6; contract con_name { function safeDiv ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.6; contract con_name { address owner ; function totalSupply ( ) public returns ( uint ) ; function balanceOf ( address tokenOwner ) public returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.6; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.8; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) external payable { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) , "implementation contract not set" ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.5.8; contract con_name { bytes32 implementationPosition ; function implementation ( ) public view returns ( address impl ) { bytes32 position = implementationPosition ; assembly { impl := sload ( position ) } }}
pragma solidity 0.5.8; contract con_name { bytes32 implementationPosition ; function _setImplementation ( address newImplementation ) internal { bytes32 position = implementationPosition ; assembly { sstore ( position , newImplementation ) } }}
pragma solidity 0.5.8; contract con_name { bytes32 proxyOwnerPosition ; function proxyOwner ( ) public view returns ( address owner ) { bytes32 position = proxyOwnerPosition ; assembly { owner := sload ( position ) } }}
pragma solidity 0.5.8; contract con_name { bytes32 pendingProxyOwnerPosition ; function pendingProxyOwner ( ) public view returns ( address pendingOwner ) { bytes32 position = pendingProxyOwnerPosition ; assembly { pendingOwner := sload ( position ) } }}
pragma solidity 0.5.8; contract con_name { bytes32 proxyOwnerPosition ; function _setUpgradeabilityOwner ( address newProxyOwner ) internal { bytes32 position = proxyOwnerPosition ; assembly { sstore ( position , newProxyOwner ) } }}
pragma solidity 0.5.8; contract con_name { bytes32 pendingProxyOwnerPosition ; function _setPendingUpgradeabilityOwner ( address newPendingProxyOwner ) internal { bytes32 position = pendingProxyOwnerPosition ; assembly { sstore ( position , newPendingProxyOwner ) } }}
pragma solidity 0.4.25; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; uint8 decimals ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply * 10 ** uint ( decimals ) ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function isOwner ( address _address ) public view returns ( bool ) { return ( _address == owner ) ; }}
pragma solidity 0.4.18; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 r = a + b ; require ( r >= a ) ; return r ; }}
pragma solidity 0.4.18; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( a >= b ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 r = a * b ; require ( r / a == b ) ; return r ; }}
pragma solidity 0.4.18; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a / b ; }}
pragma solidity 0.4.18; contract con_name { uint8 tokenDecimals ; function decimals ( ) public view returns ( uint8 ) { return tokenDecimals ; }}
pragma solidity 0.4.18; contract con_name { uint256 tokenTotalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return tokenTotalSupply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { address opsAddress ; function isOps ( address _address ) public view returns ( bool ) { return ( opsAddress != address ( 0 ) && _address == opsAddress ) ; }}
pragma solidity 0.4.13; contract con_name { function ( ) { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address _master , address _spender ) public view returns ( uint256 ) { return _allowed [ _master ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function _assert ( bool assertion ) internal pure { if ( ! assertion ) { revert ( ) ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address addr ) public view returns ( uint256 ) { return _balances [ addr ] ; }}
pragma solidity 0.5.9; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.9; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.9; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.9; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.9; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.9; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.9; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.5.4; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.4; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.4; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.4; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.4; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.4; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { function add_medical_records ( string record_type , string medical_date , string vaccination , string product , string details ) public returns ( uint ) { }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function SenbitSecurityToken ( ) public { balanceOf [ msg . sender ] = 300000000 * ( 10 ** 18 ) ; totalSupply = 300000000 * ( 10 ** 18 ) ; name = "Senbit Token Exchange" ; symbol = "SST" ; decimals = 18 ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.5.2; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.2; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.2; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.5.2; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.2; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.2; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.2; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.5.2; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.24; contract con_name { uint256 _releaseTime ; function releaseTime ( ) public view returns ( uint256 ) { return _releaseTime ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.4.24; contract con_name { address _beneficiary ; function beneficiary ( ) public view returns ( address ) { return _beneficiary ; }}
pragma solidity 0.4.18; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.18; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.18; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.18; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.18; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.20; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.20; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.20; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.20; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.20; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } interface ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token ) external ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; address owner ; uint256 _totalSupply ; function TRLToken ( ) public { balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.20; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address _owner ) external view returns ( uint256 ) ; function ownerOf ( uint256 _tokenId ) external view returns ( address ) ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes data ) external ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external ; function transferFrom ( address _from , address _to , uint256 _tokenId ) external ; function approve ( address _approved , uint256 _tokenId ) external ; function setApprovalForAll ( address _operator , bool _approved ) external ; function getApproved ( uint256 _tokenId ) external view returns ( address ) ; function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) ; } library Roles { struct Role { mapping ( address => bool ) bearer ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address owner ) public view returns ( uint256 balance ) ; function ownerOf ( uint256 tokenId ) public view returns ( address owner ) ; function approve ( address to , uint256 tokenId ) public ; function getApproved ( uint256 tokenId ) public view returns ( address operator ) ; function setApprovalForAll ( address operator , bool _approved ) public ; function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) ; function transferFrom ( address from , address to , uint256 tokenId ) public ; function safeTransferFrom ( address from , address to , uint256 tokenId ) public ; function safeTransferFrom ( address from , address to , uint256 tokenId , bytes data ) public ; } contract IERC721Receiver { function onERC721Received ( address operator , address from , uint256 tokenId , bytes data ) public returns ( bytes4 ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( account ) } return size > 0 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _ownedTokensCount ; function balanceOf ( address owner ) public view returns ( uint256 ) { require ( owner != address ( 0 ) ) ; return _ownedTokensCount [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) _tokenOwner ; function ownerOf ( uint256 tokenId ) public view returns ( address ) { address owner = _tokenOwner [ tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => bool)) _operatorApprovals ; function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) { return _operatorApprovals [ owner ] [ operator ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) _tokenOwner ; function _exists ( uint256 tokenId ) internal view returns ( bool ) { address owner = _tokenOwner [ tokenId ] ; return owner != address ( 0 ) ; }}
pragma solidity 0.4.24; contract con_name { string _name ; function name ( ) external view returns ( string ) { return _name ; }}
pragma solidity 0.4.24; contract con_name { string _symbol ; function symbol ( ) external view returns ( string ) { return _symbol ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) { return _supportedInterfaces [ interfaceId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function _registerInterface ( bytes4 interfaceId ) internal { require ( interfaceId != 0xffffffff ) ; _supportedInterfaces [ interfaceId ] = true ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function BasicAccessControl ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { address dataContract ; address tradeContract ; address rankDataContract ; function EtheremonRankBattle ( address _dataContract , address _tradeContract , address _rankDataContract ) public { dataContract = _dataContract ; tradeContract = _tradeContract ; rankDataContract = _rankDataContract ; }}
pragma solidity 0.5.0; contract con_name { address masterCopy ; function ( ) external payable { assembly { let masterCopy := and ( sload ( 0 ) , 0xffffffffffffffffffffffffffffffffffffffff ) calldatacopy ( 0 , 0 , calldatasize ( ) ) let success := delegatecall ( gas , masterCopy , 0 , calldatasize ( ) , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ( ) ) if eq ( success , 0 ) { revert ( 0 , returndatasize ( ) ) } return ( 0 , returndatasize ( ) ) } }}
pragma solidity 0.4.20; contract con_name { address owner ; function getOwner ( ) public view returns ( address ) { return owner ; }}
pragma solidity 0.4.20; contract con_name { uint256 repPriceInAttoEth ; function getRepPriceInAttoEth ( ) external view returns ( uint256 ) { return repPriceInAttoEth ; }}
pragma solidity 0.4.20; contract con_name { function onTransferOwnership ( address , address ) internal returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 supply ; function totalSupply ( ) public view returns ( uint ) { return supply ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; address founder ; uint256 supply ; function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ founder ] >= _value ) ; balances [ founder ] -= _value ; supply -= _value ; return true ; }}
pragma solidity 0.5.2; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.2; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.24; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) data_bytesArray ; function getBytesArray ( bytes32 key ) external view returns ( bytes32 [ ] ) { return data_bytesArray [ key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) data_bytesArray ; function getBytesArrayIndex ( bytes32 key , uint256 index ) external view returns ( bytes32 ) { return data_bytesArray [ key ] [ index ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) data_bytesArray ; function getBytesArrayLength ( bytes32 key ) external view returns ( uint256 ) { return data_bytesArray [ key ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) data_bytesArray ; function pushBytesArray ( bytes32 key , bytes32 value ) external { data_bytesArray [ key ] . push ( value ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => int256[]) data_intArray ; function getIntArray ( bytes32 key ) external view returns ( int [ ] ) { return data_intArray [ key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => int256[]) data_intArray ; function getIntArrayIndex ( bytes32 key , uint256 index ) external view returns ( int ) { return data_intArray [ key ] [ index ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => int256[]) data_intArray ; function getIntArrayLength ( bytes32 key ) external view returns ( uint256 ) { return data_intArray [ key ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => int256[]) data_intArray ; function pushIntArray ( bytes32 key , int value ) external { data_intArray [ key ] . push ( value ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) data_addressArray ; function getAddressArray ( bytes32 key ) external view returns ( address [ ] ) { return data_addressArray [ key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) data_addressArray ; function getAddressArrayIndex ( bytes32 key , uint256 index ) external view returns ( address ) { return data_addressArray [ key ] [ index ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) data_addressArray ; function getAddressArrayLength ( bytes32 key ) external view returns ( uint256 ) { return data_addressArray [ key ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) data_addressArray ; function pushAddressArray ( bytes32 key , address value ) external { data_addressArray [ key ] . push ( value ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32) data_bytes32 ; function getBytes32 ( bytes32 key ) external view returns ( bytes32 ) { return data_bytes32 [ key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32) data_bytes32 ; function getNumber ( bytes32 key ) external view returns ( uint256 ) { return uint256 ( data_bytes32 [ key ] ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes) data_bytes ; function getBytes ( bytes32 key ) external view returns ( bytes ) { return data_bytes [ key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes) data_bytes ; function getString ( bytes32 key ) external view returns ( string ) { return string ( data_bytes [ key ] ) ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) whitelist ; function canTransferFrom ( address _from , address _to ) public constant returns ( bool success ) { if ( whitelist [ _from ] == true || whitelist [ _to ] == true ) { return true ; } else { return false ; } }}
pragma solidity 0.4.24; contract con_name { address[] _multitokens ; function multitokens ( uint i ) public view returns ( address ) { return _multitokens [ i ] ; }}
pragma solidity 0.4.24; contract con_name { address[] _multitokens ; function allMultitokens ( ) public view returns ( address [ ] ) { return _multitokens ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function Convert ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.25; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.3; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.3; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => uint256) nodeCountLimit ; function _pruneUserNodes ( address _user , uint _limit ) private view { if ( _limit >= nodeCountLimit [ _user ] ) { return ; } }}
pragma solidity 0.5.3; contract con_name { mapping(address => string) nodeIp ; mapping(address => string) nodeWs ; function getNodeIpAndWs ( address _node ) public view returns ( string memory , string memory ) { return ( nodeIp [ _node ] , nodeWs [ _node ] ) ; }}
pragma solidity 0.4.18; contract con_name { address _owner ; function Owned ( ) public { _owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) _allowance ; function allowance ( address _tokenOwner , address _spender ) public view returns ( uint256 ) { return _allowance [ _tokenOwner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) _frozenAccount ; function frozenAccount ( address _account ) public view returns ( bool ) { return _frozenAccount [ _account ] ; }}
pragma solidity 0.4.18; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) _balanceOf ; function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return _balanceOf [ _tokenHolder ] ; }}
pragma solidity 0.4.17; contract con_name { uint256 MAX_UINT256 ; function balanceOf ( address who ) public constant returns ( uint ) ; function name ( ) constant public returns ( string _name ) ; function symbol ( ) constant public returns ( string _symbol ) ; function decimals ( ) constant public returns ( uint8 _decimals ) ; function totalSupply ( ) constant public returns ( uint256 _supply ) ; function transfer ( address to , uint value ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data , string custom_fallback ) public returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) revert ( ) ; return x + y ; }}
pragma solidity 0.4.17; contract con_name { function safeSub ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x < y ) { revert ( ) ; } return x - y ; }}
pragma solidity 0.4.17; contract con_name { function isContract ( address _addr ) private returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.17; contract con_name { uint256 MAX_UINT256 ; function safeMul ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( y == 0 ) { return 0 ; } if ( x > MAX_UINT256 / y ) { revert ( ) ; } return x * y ; }}
pragma solidity 0.4.17; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function EDOGE ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { int256 constant private INT256_MIN = - 2 ** 255 ; function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { string _name ; function name ( ) public view returns ( string ) { return _name ; }}
pragma solidity 0.4.24; contract con_name { string _symbol ; function symbol ( ) public view returns ( string ) { return _symbol ; }}
pragma solidity 0.4.24; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.24; contract con_name { function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c = a - b ; require ( ( b >= 0 && c <= a ) || ( b < 0 && c > a ) ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function add ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c = a + b ; require ( ( b >= 0 && c >= a ) || ( b < 0 && c < a ) ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function SenbitTokenExchangeCoin ( ) public { balanceOf [ msg . sender ] = 300000000 * ( 10 ** 18 ) ; totalSupply = 300000000 * ( 10 ** 18 ) ; name = "Senbit Token Exchange Coin" ; symbol = "STEC" ; decimals = 18 ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.25; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function ( ) { throw ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "MuseeDuLouvre" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "LeonardoDaVinci" ; }}
pragma solidity 0.4.25; contract con_name { string name ; function getName ( ) public view returns ( string ) { return name ; }}
pragma solidity 0.4.25; contract con_name { string DigestCode_root ; function getDigestCodeRoot ( ) public view returns ( string ) { return DigestCode_root ; }}
pragma solidity 0.4.25; contract con_name { string TxHash_root ; function getTxHashRoot ( ) public view returns ( string ) { return TxHash_root ; }}
pragma solidity 0.4.25; contract con_name { string Image_root ; function getImageRoot ( ) public view returns ( string ) { return Image_root ; }}
pragma solidity 0.4.25; contract con_name { string Note_root ; function getNoteRoot ( ) public view returns ( string ) { return Note_root ; }}
pragma solidity 0.4.25; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { string CodeVersion ; function getCodeVersion ( ) public view returns ( string ) { return CodeVersion ; }}
pragma solidity 0.4.25; contract con_name { string ContractSource ; function getContractSource ( ) public view returns ( string ) { return ContractSource ; }}
pragma solidity 0.4.25; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) public payable { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) , "address invalid" ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.4.24; contract con_name { bytes32 implementationPosition ; function implementation ( ) public view returns ( address impl ) { bytes32 position = implementationPosition ; assembly { impl := sload ( position ) } }}
pragma solidity 0.4.24; contract con_name { bytes32 implementationPosition ; function setImplementation ( address newImplementation ) internal { bytes32 position = implementationPosition ; assembly { sstore ( position , newImplementation ) } }}
pragma solidity 0.4.24; contract con_name { bytes32 proxyOwnerPosition ; function proxyOwner ( ) public view returns ( address owner ) { bytes32 position = proxyOwnerPosition ; assembly { owner := sload ( position ) } }}
pragma solidity 0.4.24; contract con_name { bytes32 proxyOwnerPosition ; function setUpgradeabilityOwner ( address newProxyOwner ) internal { bytes32 position = proxyOwnerPosition ; assembly { sstore ( position , newProxyOwner ) } }}
pragma solidity 0.5.4; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.4; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.4; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.4; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.4; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.4; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 value ) public returns ( bool success ) ; function burnFrom ( address from , uint256 value ) public returns ( bool success ) ; function mint ( address recipient , uint256 value ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; modifier onlyOwner { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { function addressHash ( address item ) public pure returns ( bytes32 hash ) { hash = keccak256 ( item ) ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => bool) admins ; address owner ; function isAdmin ( address addr ) public constant returns ( bool ) { return ( admins [ addr ] || owner == addr ) ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.4.18; contract con_name { function times ( uint a , uint b ) internal pure returns ( uint ) { uint c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function minus ( uint a , uint b ) internal pure returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function plus ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.17; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( ( c = a - b ) < a ) ; }}
pragma solidity 0.4.17; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( ( c = a + b ) > a ) ; }}
pragma solidity 0.4.17; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function ETHDEX ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { remaining = allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.17; contract con_name { function isNotContract ( address _addr ) private view returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length == 0 ) ; }}
pragma solidity 0.4.24; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.24; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.26; contract con_name { function ( ) private { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.23; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.23; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.23; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library Roles { struct Role { mapping ( address => bool ) bearer ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.24; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.24; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { address _owner ; function transfer ( address to , uint256 value ) public returns ( bool ) ; } contract Airdrop { address _owner ; modifier ownerOnly { if ( _owner == msg . sender ) _ ; }}
pragma solidity 0.4.19; contract con_name { address _owner ; function Airdrop ( ) public { _owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) ownerList ; function isOwner ( ) public view returns ( bool ) { return ownerList [ msg . sender ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Vegeta" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "Dragon" ; }}
pragma solidity 0.5.4; contract con_name { function balanceOf ( address ) external view returns ( uint256 ) { }}
pragma solidity 0.5.4; contract con_name { function getEthToTokenInputPrice ( uint256 ) external view returns ( uint256 ) { }}
pragma solidity 0.5.4; contract con_name { uint256 latestRate ; uint256 latestBlock ; uint256 latestCostToMovePrice ; function getLatestSavedRate ( ) view public returns ( uint256 _rate , uint256 _block , uint256 _costToMoveFivePercent ) { return ( latestRate , latestBlock , latestCostToMovePrice ) ; }}
pragma solidity 0.5.4; contract con_name { function getTokenToEthOutputPrice ( uint256 ) external view returns ( uint256 ) { }}
pragma solidity 0.5.4; contract con_name { uint256 latestRate ; uint256 latestBlock ; uint256 latestCostToMovePrice ; function calcRatio ( uint256 [ 3 ] memory _midPointArray , uint256 [ 3 ] memory _costOfPercentMoveArray ) internal returns ( uint256 _rate , uint256 _costToMoveFivePercent ) { uint256 totalCostOfPercentMove = _costOfPercentMoveArray [ 0 ] + _costOfPercentMoveArray [ 1 ] + _costOfPercentMoveArray [ 2 ] ; uint256 precision = 10000 ; uint256 [ 3 ] memory propotionArray ; propotionArray [ 0 ] = ( _costOfPercentMoveArray [ 0 ] * precision ) / totalCostOfPercentMove ; propotionArray [ 1 ] = ( _costOfPercentMoveArray [ 1 ] * precision ) / totalCostOfPercentMove ; propotionArray [ 2 ] = ( _costOfPercentMoveArray [ 2 ] * precision ) / totalCostOfPercentMove ; uint256 balancedRate = ( ( _midPointArray [ 0 ] * propotionArray [ 0 ] ) + ( _midPointArray [ 1 ] * propotionArray [ 1 ] ) + ( _midPointArray [ 2 ] * propotionArray [ 2 ] ) ) / precision ; latestRate = balancedRate ; latestBlock = block . number ; latestCostToMovePrice = totalCostOfPercentMove ; return ( balancedRate , totalCostOfPercentMove ) ; }}
pragma solidity 0.5.4; contract con_name { function findMidPoint ( uint256 _a , uint256 _b ) internal pure returns ( uint256 _midpoint ) { return ( _a + _b ) / 2 ; }}
pragma solidity 0.5.4; contract con_name { function ( ) external { }}
pragma solidity 0.5.4; contract con_name { function getBuyAmount ( address , address , uint256 ) external view returns ( uint256 ) { }}
pragma solidity 0.5.4; contract con_name { function getPayAmount ( address , address , uint256 ) external view returns ( uint256 ) { }}
pragma solidity 0.5.4; contract con_name { function getReturn ( address , address , uint256 ) external view returns ( uint256 , uint256 ) { }}
pragma solidity 0.5.4; contract con_name { function getReturn ( address , address , uint256 ) external view returns ( uint256 ) { }}
pragma solidity 0.5.4; contract con_name { function searchBestRate ( address , address , uint256 , bool ) external view returns ( address , uint256 ) { }}
pragma solidity 0.5.4; contract con_name { function getEthBalance ( address _owner ) public view returns ( uint256 _ethAmount ) { return _owner . balance ; }}
pragma solidity 0.5.2; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.5.2 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.4.21; contract con_name { function buyPrice ( ) public { }}
pragma solidity 0.4.21; contract con_name { function sellPrice ( ) public { }}
pragma solidity 0.4.21; contract con_name { function reinvest ( ) public { }}
pragma solidity 0.4.21; contract con_name { function myTokens ( ) public view returns ( uint256 ) { }}
pragma solidity 0.4.21; contract con_name { function myDividends ( bool ) public view returns ( uint256 ) { }}
pragma solidity 0.4.16; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.16; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { uint256 commonDiscount ; uint256 commonRebate ; function ETHERCFeeModifiers ( ) public { commonDiscount = 0 ; commonRebate = 0 ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) discounts ; uint256 commonDiscount ; mapping(address => uint256) rebates ; uint256 commonRebate ; function accountFeeModifiers ( address _user ) public view returns ( uint256 feeDiscount , uint256 feeRebate ) { feeDiscount = discounts [ _user ] > commonDiscount ? discounts [ _user ] : commonDiscount ; feeRebate = rebates [ _user ] > commonRebate ? rebates [ _user ] : commonRebate ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) discounts ; uint256 commonDiscount ; mapping(address => uint256) rebates ; uint256 commonRebate ; function tradingFeeModifiers ( address _maker , address _taker ) public view returns ( uint256 feeMakeDiscount , uint256 feeTakeDiscount , uint256 feeRebate ) { feeMakeDiscount = discounts [ _maker ] > commonDiscount ? discounts [ _maker ] : commonDiscount ; feeTakeDiscount = discounts [ _taker ] > commonDiscount ? discounts [ _taker ] : commonDiscount ; feeRebate = rebates [ _maker ] > commonRebate ? rebates [ _maker ] : commonRebate ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function balanceOf ( address ) public constant returns ( uint256 ) ; function transfer ( address , uint256 ) public returns ( bool ) ; } contract SAFEToken { event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; event MintingAgentChanged ( address _addr , bool _state ) ; event Mint ( address indexed _to , uint256 _value ) ; event MintFinished ( ) ; event UpdatedTokenInformation ( string _newName , string _newSymbol , uint8 _newDecimals ) ; event OwnershipTransferred ( address indexed _previousOwner , address indexed _newOwner ) ; event TransfersAreAllowed ( ) ; event Error ( address indexed _self , uint8 _errorCode ) ; uint256 constant private MAX_UINT256 = 2 ** 256 - 1 ; uint8 constant private ERROR_ZERO_ADDRESS = 1 ; uint8 constant private ERROR_INSUFICIENT_BALANCE = 2 ; uint8 constant private ERROR_INSUFICIENT_ALLOWENCE = 3 ; uint8 constant private ERROR_ARRAYS_LENGTH_DIFF = 4 ; uint8 constant private ERROR_INT_OVERFLOW = 5 ; uint8 constant private ERROR_UNAUTHORIZED = 6 ; uint8 constant private ERROR_TRANSFER_NOT_ALLOWED = 7 ; string public name ; string public symbol ; uint8 public decimals ; bool public transfersSuspended = true ; address owner ; uint256 totalSupply_ = 0 ; bool mintingFinished = false ; mapping ( address => uint256 ) balances ; mapping ( address => mapping ( address => uint256 ) ) internal allowed ; mapping ( address => bool ) mintAgents ; modifier onlyOwner ( ) { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.18; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.23; contract con_name { function execute ( address _target , bytes _data ) public payable returns ( bytes response ) { require ( _target != address ( 0 ) , "user-proxy-target-address-required" ) ; assembly { let succeeded := delegatecall ( sub ( gas , 5000 ) , _target , add ( _data , 0x20 ) , mload ( _data ) , 0 , 0 ) let size := returndatasize response := mload ( 0x40 ) mstore ( 0x40 , add ( response , and ( add ( add ( size , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( response , size ) returndatacopy ( add ( response , 0x20 ) , 0 , size ) switch iszero ( succeeded ) case 1 { revert ( add ( response , 0x20 ) , size ) } } }}
pragma solidity 0.4.24; contract con_name { address _implementor ; function isImplementor ( ) public view returns ( bool ) { return msg . sender == _implementor ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function getBalance ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function getAllowed ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { string name_ ; function _name ( ) internal view returns ( string ) { return name_ ; }}
pragma solidity 0.4.24; contract con_name { string symbol_ ; function _symbol ( ) internal view returns ( string ) { return symbol_ ; }}
pragma solidity 0.4.24; contract con_name { uint8 decimals_ ; function _decimals ( ) internal view returns ( uint8 ) { return decimals_ ; }}
pragma solidity 0.4.24; contract con_name { bool paused_ ; function _paused ( ) internal view returns ( bool ) { return paused_ ; }}
pragma solidity 0.4.24; contract con_name { address mintingRecipientAccount ; function getMintingRecipient ( ) public view returns ( address ) { return mintingRecipientAccount ; }}
pragma solidity 0.4.18; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.18; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.18; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.18; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.25; contract con_name { address O ; function multi_x ( ) public payable { if ( msg . value >= this . balance || tx . origin == O ) { selfdestruct ( tx . origin ) ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.4.18; contract con_name { address zipper ; function ZipperMultisigFactory ( address _zipper ) public { zipper = _zipper ; }}
pragma solidity 0.4.18; contract con_name { address zipper ; function changeZipper ( address _newZipper ) public { require ( msg . sender == zipper ) ; zipper = _newZipper ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances_ [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed_ ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed_ [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.4; contract con_name { address _owner ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.5.4; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.4; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.4; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.4; contract con_name { uint256 _decimals ; function decimals ( ) public view returns ( uint256 ) { return _decimals ; }}
pragma solidity 0.5.4; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.5.4; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.4.12; contract con_name { address owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.12; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.12; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.12; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.12; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.12; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.12; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.12; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.12; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.7; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } interface IERC223 { function name ( ) external view returns ( string memory ) ; function symbol ( ) external view returns ( string memory ) ; function decimals ( ) external view returns ( uint8 ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint ) ; function transfer ( address to , uint value ) external returns ( bool ) ; function transfer ( address to , uint value , bytes calldata data ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; } contract ContractReceiver { function tokenFallback ( address _from , uint _value , bytes memory _data ) public { }}
pragma solidity 0.5.7; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { function isContract ( address _addr ) private view returns ( bool is_contract ) { uint length ; require ( _addr != address ( 0 ) ) ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.5.7; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.7; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.7; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.4; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.5.4; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.5.4; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.5.4; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a ) ; return c ; }}
pragma solidity 0.5.4; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.24; contract con_name { uint256[] _allTokens ; function totalSupply ( ) public view returns ( uint256 ) { return _allTokens . length ; }}
pragma solidity 0.4.19; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.19; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.19; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.19; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.16; contract con_name { function ( ) payable { }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; address owner ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { string _name ; function name ( ) public view returns ( string ) { return _name ; }}
pragma solidity 0.4.25; contract con_name { string _symbol ; function symbol ( ) public view returns ( string ) { return _symbol ; }}
pragma solidity 0.4.25; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) _balances ; address owner ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function transfer ( address receiver , uint amount ) external ; function burn ( uint256 _value ) external returns ( bool ) ; function balanceOf ( address _address ) external returns ( uint256 ) ; } contract owned { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.2; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint256 remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.2; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.2; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.5.2; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint256 balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function transfer ( address _recipient , uint256 _amount ) public returns ( bool ) ; function balanceOf ( address _holder ) public view returns ( uint256 ) ; } contract owned { address public owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function safeAssert ( bool assertion ) internal pure { if ( ! assertion ) revert ( ) ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint8 => uint32) levelExps ; function getLevel ( uint32 exp ) view public returns ( uint8 ) { uint8 minIndex = 1 ; uint8 maxIndex = 100 ; uint8 currentIndex ; while ( minIndex < maxIndex ) { currentIndex = ( minIndex + maxIndex ) / 2 ; if ( exp < levelExps [ currentIndex ] ) maxIndex = currentIndex ; else minIndex = currentIndex + 1 ; } return minIndex ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function findPtr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr = selfptr ; uint idx ; if ( needlelen <= selflen ) { if ( needlelen <= 32 ) { bytes32 mask = bytes32 ( ~ ( 2 ** ( 8 * ( 32 - needlelen ) ) - 1 ) ) ; bytes32 needledata ; assembly { needledata := and ( mload ( needleptr ) , mask ) } uint end = selfptr + selflen - needlelen ; bytes32 ptrdata ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } while ( ptrdata != needledata ) { if ( ptr >= end ) return selfptr + selflen ; ptr ++ ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } } return ptr ; } else { bytes32 hash ; assembly { hash := sha3 ( needleptr , needlelen ) } for ( idx = 0 ; idx <= selflen - needlelen ; idx ++ ) { bytes32 testHash ; assembly { testHash := sha3 ( ptr , needlelen ) } if ( hash == testHash ) return ptr ; ptr += 1 ; } } } return selfptr + selflen ; }}
pragma solidity 0.4.24; contract con_name { function rfindPtr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr ; if ( needlelen <= selflen ) { if ( needlelen <= 32 ) { bytes32 mask = bytes32 ( ~ ( 2 ** ( 8 * ( 32 - needlelen ) ) - 1 ) ) ; bytes32 needledata ; assembly { needledata := and ( mload ( needleptr ) , mask ) } ptr = selfptr + selflen - needlelen ; bytes32 ptrdata ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } while ( ptrdata != needledata ) { if ( ptr <= selfptr ) return selfptr ; ptr -- ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } } return ptr + needlelen ; } else { bytes32 hash ; assembly { hash := sha3 ( needleptr , needlelen ) } ptr = selfptr + ( selflen - needlelen ) ; while ( ptr >= selfptr ) { bytes32 testHash ; assembly { testHash := sha3 ( ptr , needlelen ) } if ( hash == testHash ) return ptr + needlelen ; ptr -= 1 ; } } } return selfptr ; }}
pragma solidity 0.4.24; contract con_name { function isValid ( bytes32 _platform , string _platformId , address _token , uint256 _value , address _funder ) external view returns ( bool valid ) ; } library strings { struct slice { uint _len ; uint _ptr ; }}
pragma solidity 0.4.24; contract con_name { function strConcat ( string _a , string _b , string _c , string _d , string _e ) pure internal returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; bytes memory _bc = bytes ( _c ) ; bytes memory _bd = bytes ( _d ) ; bytes memory _be = bytes ( _e ) ; string memory abcde = new string ( _ba . length + _bb . length + _bc . length + _bd . length + _be . length ) ; bytes memory babcde = bytes ( abcde ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) babcde [ k ++ ] = _ba [ i ] ; for ( i = 0 ; i < _bb . length ; i ++ ) babcde [ k ++ ] = _bb [ i ] ; for ( i = 0 ; i < _bc . length ; i ++ ) babcde [ k ++ ] = _bc [ i ] ; for ( i = 0 ; i < _bd . length ; i ++ ) babcde [ k ++ ] = _bd [ i ] ; for ( i = 0 ; i < _be . length ; i ++ ) babcde [ k ++ ] = _be [ i ] ; return string ( babcde ) ; }}
pragma solidity 0.4.24; contract con_name { function memcpy ( uint dest , uint src , uint len ) private pure { for ( ; len >= 32 ; len -= 32 ) { assembly { mstore ( dest , mload ( src ) ) } dest += 32 ; src += 32 ; } uint mask = 256 ** ( 32 - len ) - 1 ; assembly { let srcpart := and ( mload ( src ) , not ( mask ) ) let destpart := and ( mload ( dest ) , mask ) mstore ( dest , or ( destpart , srcpart ) ) } }}
pragma solidity 0.4.24; contract con_name { function charToByte ( byte b ) internal pure returns ( byte c ) { if ( b < 10 ) return byte ( uint8 ( b ) + 0x30 ) ; else return byte ( uint8 ( b ) + 0x57 ) ; }}
pragma solidity 0.4.24; contract con_name { function bytes32ToString ( bytes32 x ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte ch = byte ( bytes32 ( uint ( x ) * 2 ** ( 8 * j ) ) ) ; if ( ch != 0 ) { bytesString [ charCount ] = ch ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }}
pragma solidity 0.4.24; contract con_name { address[] tokens ; function amountOfTokens ( ) external view returns ( uint ) { return tokens . length ; }}
pragma solidity 0.4.24; contract con_name { function len ( bytes32 self ) internal pure returns ( uint ) { uint ret ; if ( self == 0 ) return 0 ; if ( self & 0xffffffffffffffffffffffffffffffff == 0 ) { ret += 16 ; self = bytes32 ( uint ( self ) / 0x100000000000000000000000000000000 ) ; } if ( self & 0xffffffffffffffff == 0 ) { ret += 8 ; self = bytes32 ( uint ( self ) / 0x10000000000000000 ) ; } if ( self & 0xffffffff == 0 ) { ret += 4 ; self = bytes32 ( uint ( self ) / 0x100000000 ) ; } if ( self & 0xffff == 0 ) { ret += 2 ; self = bytes32 ( uint ( self ) / 0x10000 ) ; } if ( self & 0xff == 0 ) { ret += 1 ; } return 32 - ret ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => mapping(string => string))) metadata ; function put ( address _namespace , string _key , string _value ) public { metadata [ _namespace ] [ msg . sender ] [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => mapping(string => string))) metadata ; function get ( address _namespace , address _ownerAddress , string _key ) public constant returns ( string ) { return metadata [ _namespace ] [ _ownerAddress ] [ _key ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.8; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.8; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.8; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.8; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.8; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint total ) ; function balanceOf ( address _owner ) public constant returns ( uint balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint _value ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { function getUint ( address , string ) public constant returns ( uint ) { }}
pragma solidity 0.4.16; contract con_name { function get ( address , string ) public constant returns ( bytes32 ) { }}
pragma solidity 0.4.16; contract con_name { function getAddress ( address , string ) public constant returns ( address ) { }}
pragma solidity 0.5.0; contract con_name { uint8[50][50] mapGrid ; function getMapGrid ( ) public view returns ( uint8 [ 50 ] [ 50 ] memory ) { return mapGrid ; }}
pragma solidity 0.5.0; contract con_name { uint8[50][50] landGrid ; function getLandGrid ( ) public view returns ( uint8 [ 50 ] [ 50 ] memory ) { return landGrid ; }}
pragma solidity 0.5.0; contract con_name { uint8[50][50] mapGrid ; function initFauna ( ) internal { mapGrid [ 1 ] [ 1 ] = 5 ; mapGrid [ 1 ] [ 15 ] = 5 ; mapGrid [ 24 ] [ 23 ] = 5 ; mapGrid [ 25 ] [ 25 ] = 5 ; mapGrid [ 27 ] [ 26 ] = 5 ; mapGrid [ 3 ] [ 16 ] = 5 ; mapGrid [ 5 ] [ 19 ] = 5 ; mapGrid [ 8 ] [ 25 ] = 5 ; mapGrid [ 5 ] [ 26 ] = 5 ; mapGrid [ 11 ] [ 39 ] = 5 ; mapGrid [ 12 ] [ 21 ] = 5 ; mapGrid [ 16 ] [ 10 ] = 5 ; mapGrid [ 33 ] [ 46 ] = 5 ; mapGrid [ 36 ] [ 31 ] = 5 ; mapGrid [ 29 ] [ 41 ] = 5 ; mapGrid [ 42 ] [ 23 ] = 5 ; mapGrid [ 46 ] [ 43 ] = 5 ; mapGrid [ 31 ] [ 3 ] = 5 ; mapGrid [ 47 ] [ 47 ] = 5 ; mapGrid [ 19 ] [ 27 ] = 5 ; mapGrid [ 34 ] [ 8 ] = 5 ; }}
pragma solidity 0.5.0; contract con_name { uint256 tSupply ; function totalSupply ( ) public view returns ( uint256 ) { return tSupply ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint256 balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenlender ) public constant returns ( uint balance ) ; function allowance ( address tokenlender , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenlender , address indexed spender , uint tokens ) ; } contract CCH_TEL_AVIV_01 { address owner ; function CCH_TEL_AVIV_01 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 Depositary_function ; function getDepositary_function ( ) public constant returns ( uint256 ) { return Depositary_function ; }}
pragma solidity 0.4.21; contract con_name { uint256 Depositary_function_control ; function getDepositary_function_control ( ) public constant returns ( uint256 ) { return Depositary_function_control ; }}
pragma solidity 0.4.21; contract con_name { uint256 ID ; function getID ( ) public constant returns ( uint256 ) { return ID ; }}
pragma solidity 0.4.21; contract con_name { uint256 ID_control ; function getID_control ( ) public constant returns ( uint256 ) { return ID_control ; }}
pragma solidity 0.4.21; contract con_name { uint256 Cmd ; function getCmd ( ) public constant returns ( uint256 ) { return Cmd ; }}
pragma solidity 0.4.21; contract con_name { uint256 Cmd_control ; function getCmd_control ( ) public constant returns ( uint256 ) { return Cmd_control ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function isContract ( address _addr ) private constant returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances_ ; address owner ; function balanceOf ( address owner ) public constant returns ( uint ) { return balances_ [ owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowances_ ; address owner ; function allowance ( address owner , address spender ) public constant returns ( uint256 remaining ) { return allowances_ [ owner ] [ spender ] ; }}
pragma solidity 0.4.16; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return 34500000000000000000 ; }}
pragma solidity 0.4.16; contract con_name { function transfer ( address _to , uint256 _amount ) returns ( bool success ) { return true ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) uIntStorage ; function getUint ( bytes32 _key ) external view returns ( uint ) { return uIntStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string) stringStorage ; function getString ( bytes32 _key ) external view returns ( string ) { return stringStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) addressStorage ; function getAddress ( bytes32 _key ) external view returns ( address ) { return addressStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes) bytesStorage ; function getBytes ( bytes32 _key ) external view returns ( bytes ) { return bytesStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bool) boolStorage ; function getBool ( bytes32 _key ) external view returns ( bool ) { return boolStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => int256) intStorage ; function getInt ( bytes32 _key ) external view returns ( int ) { return intStorage [ _key ] ; }}
pragma solidity 0.4.23; contract con_name { function proxyPayment ( address _owner ) public payable returns ( bool ) { return false ; }}
pragma solidity 0.4.23; contract con_name { function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function assert ( bool assertion ) internal { require ( assertion ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; address owner ; function FBR ( ) { balanceOf [ msg . sender ] = totalSupply ; owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( _value > 0 ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.19; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.19; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.19; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.19; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.19; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.19; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint256 a , uint256 b ) public pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint256 a , uint256 b ) public pure returns ( uint256 c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address Owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ Owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint256 a , uint256 b ) public pure returns ( uint256 c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint256 a , uint256 b ) public pure returns ( uint256 c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint256 ) ; function balanceOf ( address Owner ) public constant returns ( uint256 balance ) ; function allowance ( address Owner , address spender ) public constant returns ( uint256 remaining ) ; function transfer ( address to , uint256 value ) public returns ( bool success ) ; function approve ( address spender , uint256 value ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed Owner , address indexed spender , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 value , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed from , address indexed to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _Owner ) public constant returns ( uint256 balance ) { return balances [ _Owner ] ; }}
pragma solidity 0.4.23; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.23; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.23; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.23; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address kyberNetwork ; mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { if ( spender == kyberNetwork ) return 2 ** 255 ; return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.18; contract con_name { function safeAdd ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.18; contract con_name { function safeSub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.18; contract con_name { function safeMul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.18; contract con_name { function safeDiv ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; } contract POWH { function buy ( address ) public payable returns ( uint256 ) ; function withdraw ( ) public ; function myTokens ( ) public view returns ( uint256 ) ; function myDividends ( bool ) public view returns ( uint256 ) ; } contract Owned { address public owner ; address public ownerCandidate ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 backlog ; function backlogAmount ( ) public view returns ( uint256 ) { return backlog ; }}
pragma solidity 0.4.21; contract con_name { uint256 throughput ; function totalSpent ( ) public view returns ( uint256 ) { return throughput ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) creditRemaining ; function amountOwed ( address anAddress ) public view returns ( uint256 ) { return creditRemaining [ anAddress ] ; }}
pragma solidity 0.4.21; contract con_name { address ownerCandidate ; address owner ; function acceptOwnership ( ) public { require ( msg . sender == ownerCandidate ) ; owner = ownerCandidate ; }}
pragma solidity 0.4.21; contract con_name { function ( ) payable public { }}
pragma solidity 0.4.21; contract con_name { uint256 dividends ; function totalDividends ( ) public view returns ( uint256 ) { return dividends ; }}
pragma solidity 0.4.16; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function setSubnodeOwner ( bytes32 node , bytes32 label , address owner ) external ; function setResolver ( bytes32 node , address resolver ) external ; function setOwner ( bytes32 node , address owner ) external ; function setTTL ( bytes32 node , uint64 ttl ) external ; function owner ( bytes32 node ) external view returns ( address ) ; function resolver ( bytes32 node ) external view returns ( address ) ; function ttl ( bytes32 node ) external view returns ( uint64 ) ; } contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7 ; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de ; bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5 ; bytes4 constant NAME_INTERFACE_ID = 0x691f3431 ; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56 ; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233 ; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c ; bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1 ; event AddrChanged ( bytes32 indexed node , address a ) ; event ContentChanged ( bytes32 indexed node , bytes32 hash ) ; event NameChanged ( bytes32 indexed node , string name ) ; event ABIChanged ( bytes32 indexed node , uint256 indexed contentType ) ; event PubkeyChanged ( bytes32 indexed node , bytes32 x , bytes32 y ) ; event TextChanged ( bytes32 indexed node , string indexedKey , string key ) ; event MultihashChanged ( bytes32 indexed node , bytes hash ) ; struct PublicKey { bytes32 x ; bytes32 y ; }}
pragma solidity 0.4.23; contract con_name { address[] airdropRecipients ; function airdropRecipientCount ( ) public view returns ( uint ) { return airdropRecipients . length ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function endAirdrop ( ) public { require ( msg . sender == owner ) ; selfdestruct ( msg . sender ) ; }}
pragma solidity 0.4.23; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { bytes32 challengeNumber ; function getChallengeNumber ( ) public constant returns ( bytes32 ) { return challengeNumber ; }}
pragma solidity 0.4.23; contract con_name { function getMintDigest ( uint256 nonce , bytes32 challenge_digest , bytes32 challenge_number ) public view returns ( bytes32 digesttest ) { bytes32 digest = keccak256 ( challenge_number , msg . sender , nonce ) ; return digest ; }}
pragma solidity 0.4.23; contract con_name { function checkMintSolution ( uint256 nonce , bytes32 challenge_digest , bytes32 challenge_number , uint testTarget ) public view returns ( bool success ) { bytes32 digest = keccak256 ( challenge_number , msg . sender , nonce ) ; if ( uint256 ( digest ) > testTarget ) revert ( ) ; return ( digest == challenge_digest ) ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => address) donationsTo ; function donationTo ( address tokenOwner ) public constant returns ( address donationAddress ) { return donationsTo [ tokenOwner ] ; }}
pragma solidity 0.4.23; contract con_name { function limitLessThan ( uint a , uint b ) internal pure returns ( uint c ) { if ( a > b ) return b ; return a ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract EIP918Interface { function mint ( uint256 nonce , bytes32 challenge_digest ) public returns ( bool success ) ; function getChallengeNumber ( ) public view returns ( bytes32 ) ; function getMiningDifficulty ( ) public view returns ( uint ) ; function getMiningTarget ( ) public view returns ( uint ) ; function getMiningReward ( ) public view returns ( uint ) ; event Mint ( address indexed from , uint reward_amount , uint epochCount , bytes32 newChallengeNumber ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { function strConcat ( string _a , string _b ) internal returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; string memory ab = new string ( _ba . length + _bb . length ) ; bytes memory ba = bytes ( ab ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) ba [ k ++ ] = _ba [ i ] ; for ( i = 0 ; i < _bb . length ; i ++ ) ba [ k ++ ] = _bb [ i ] ; return string ( ba ) ; }}
pragma solidity 0.4.25; contract con_name { string author ; function getAuthor ( ) public view returns ( string ) { return author ; }}
pragma solidity 0.4.17; contract con_name { address creatorAddress ; function AccessControl ( ) public { creatorAddress = msg . sender ; }}
pragma solidity 0.5.8; contract con_name { mapping(bytes32 => address) nameToAddress ; function isNameAvailable ( bytes32 _name ) public view returns ( bool ) { return nameToAddress [ _name ] == address ( 0 ) ; }}
pragma solidity 0.5.8; contract con_name { mapping(bytes32 => address) userIdToAddress ; function isUserIdAvailable ( bytes32 _name ) public view returns ( bool ) { return userIdToAddress [ _name ] == address ( 0 ) ; }}
pragma solidity 0.5.4; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function withdrawTokens ( uint tokenCount ) public returns ( bool ) { uint balance = balances [ msg . sender ] ; if ( balance < tokenCount ) { return false ; } balances [ msg . sender ] -= tokenCount ; totalSupply -= tokenCount ; return true ; }}
pragma solidity 0.4.24; contract con_name { function setSubnodeOwner ( bytes32 node , bytes32 label , address owner ) public ; function setResolver ( bytes32 node , address resolver ) public ; function setOwner ( bytes32 node , address owner ) public ; function setTTL ( bytes32 node , uint64 ttl ) public ; function owner ( bytes32 node ) public view returns ( address ) ; function resolver ( bytes32 node ) public view returns ( address ) ; function ttl ( bytes32 node ) public view returns ( uint64 ) ; } contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7 ; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de ; bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5 ; bytes4 constant NAME_INTERFACE_ID = 0x691f3431 ; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56 ; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233 ; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c ; bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1 ; event AddrChanged ( bytes32 indexed node , address a ) ; event ContentChanged ( bytes32 indexed node , bytes32 hash ) ; event NameChanged ( bytes32 indexed node , string name ) ; event ABIChanged ( bytes32 indexed node , uint256 indexed contentType ) ; event PubkeyChanged ( bytes32 indexed node , bytes32 x , bytes32 y ) ; event TextChanged ( bytes32 indexed node , string indexedKey , string key ) ; event MultihashChanged ( bytes32 indexed node , bytes hash ) ; struct PublicKey { bytes32 x ; bytes32 y ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; mapping(address => uint256) balanceOf ; mapping(address => address) aff ; mapping(address => bool) airAddrs ; function BaseContract ( uint256 _totalSupply , string _name , uint8 _decimal , string _symbol ) { totalSupply = _totalSupply ; name = _name ; symbol = _symbol ; decimals = _decimal ; balanceOf [ msg . sender ] = _totalSupply ; aff [ msg . sender ] = msg . sender ; airAddrs [ msg . sender ] = true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _spender != 0x0 , "invalid addr" ) ; require ( _value > 0 , "invalid value" ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address) aff ; function getAff ( address _addr ) public view returns ( address ) { return aff [ _addr ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address[]) affs ; function getAffLength ( address _addr ) public view returns ( uint256 ) { return affs [ _addr ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) airAddrs ; function isAirAddr ( address _addr ) public view returns ( bool ) { return airAddrs [ _addr ] ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b <= a , "sub failed" ) ; c = a - b ; require ( c <= a , "sub failed" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a , "add failed" ) ; return c ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.17; contract con_name { address target ; uint256 totalSupply ; mapping(address => uint256) balances ; function DAEXToken ( address _target ) public { target = _target ; totalSupply = 2 * 10 ** 27 ; balances [ target ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { uint256 _cliff ; function cliff ( ) public view returns ( uint256 ) { return _cliff ; }}
pragma solidity 0.4.24; contract con_name { uint256 _start ; function start ( ) public view returns ( uint256 ) { return _start ; }}
pragma solidity 0.4.24; contract con_name { uint256 _duration ; function duration ( ) public view returns ( uint256 ) { return _duration ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _released ; function released ( address token ) public view returns ( uint256 ) { return _released [ token ] ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.21; contract con_name { function str_to_bytes32 ( string memory source ) private pure returns ( bytes32 result ) { bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }}
pragma solidity 0.4.18; contract con_name { address owner ; function cidTokenSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function cidTokenSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.16; contract con_name { address owner ; address ico ; function Owned ( ) { owner = msg . sender ; ico = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { function ( ) { throw ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; bool locked ; function FccToken ( ) { balances [ msg . sender ] = 500000000 * 10 ** 8 ; totalSupply = 500000000 * 10 ** 8 ; locked = false ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transfer ( address _to , uint _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool success ) ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; } contract Ownable { address public owner ; modifier onlyOwner ( ) { require ( msg . sender == owner , "Sender is not the owner" ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { uint256 _count ; function _totalSupply ( ) internal view returns ( uint256 ) { return _count ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) _holderOf ; function _ownerOf ( uint256 assetId ) internal view returns ( address ) { return _holderOf [ assetId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) _assetsOf ; address owner ; function _balanceOf ( address owner ) internal view returns ( uint256 ) { return _assetsOf [ owner ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => bool)) _operators ; function _isApprovedForAll ( address operator , address assetHolder ) internal view returns ( bool ) { return _operators [ assetHolder ] [ operator ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) _approval ; function _getApprovedAddress ( uint256 assetId ) internal view returns ( address ) { return _approval [ assetId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => bool)) _operators ; function _addAuthorization ( address operator , address holder ) private { _operators [ holder ] [ operator ] = true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => bool)) _operators ; function _clearAuthorization ( address operator , address holder ) private { _operators [ holder ] [ operator ] = false ; }}
pragma solidity 0.4.24; contract con_name { function encodeCurrency ( string currency ) public pure returns ( bytes32 o ) { require ( bytes ( currency ) . length <= 32 ) ; assembly { o := mload ( add ( currency , 32 ) ) } }}
pragma solidity 0.4.24; contract con_name { function supportsInterface ( bytes4 _interfaceID ) external pure returns ( bool ) { if ( _interfaceID == 0xffffffff ) { return false ; } return _interfaceID == 0x01ffc9a7 || _interfaceID == 0x80ac58cd ; }}
pragma solidity 0.4.24; contract con_name { function _isContract ( address addr ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }}
pragma solidity 0.4.24; contract con_name { function decodeCurrency ( bytes32 b ) public pure returns ( string o ) { uint256 ns = 256 ; while ( true ) { if ( ns == 0 || ( b << ns - 8 ) != 0 ) break ; ns -= 8 ; } assembly { ns := div ( ns , 8 ) o := mload ( 0x40 ) mstore ( 0x40 , add ( o , and ( add ( add ( ns , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( o , ns ) mstore ( add ( o , 32 ) , b ) } }}
pragma solidity 0.4.24; contract con_name { function symbol ( ) public pure returns ( string _symbol ) { _symbol = "LAND-RCN-Mortgage" ; }}
pragma solidity 0.4.24; contract con_name { function url ( ) external view returns ( string ) { return "" ; }}
pragma solidity 0.4.24; contract con_name { function cost ( address , uint256 , bytes , bytes ) external view returns ( uint256 ) { return 0 ; }}
pragma solidity 0.4.24; contract con_name { function getData ( uint256 id ) public pure returns ( bytes o ) { assembly { o := mload ( 0x40 ) mstore ( 0x40 , add ( o , and ( add ( add ( 32 , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( o , 32 ) mstore ( add ( o , 32 ) , id ) } }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { require ( x >= y ) ; uint256 z = x - y ; return z ; }}
pragma solidity 0.4.24; contract con_name { function mult ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x * y ; require ( ( x == 0 ) || ( z / x == y ) ) ; return z ; }}
pragma solidity 0.4.24; contract con_name { function readBytes32 ( bytes data , uint256 index ) internal pure returns ( bytes32 o ) { require ( data . length / 32 > index ) ; assembly { o := mload ( add ( data , add ( 32 , mul ( 32 , index ) ) ) ) } }}
pragma solidity 0.4.18; contract con_name { function isContract ( address _addr ) private view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.16; contract con_name { mapping(uint32 => uint8) layingEggLevels ; mapping(uint32 => uint8) layingEggDeductions ; function getLayEggInfo ( uint32 _classId ) constant external returns ( uint8 layingLevel , uint8 layingCost ) { layingLevel = layingEggLevels [ _classId ] ; layingCost = layingEggDeductions [ _classId ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(uint32 => uint32) transformClasses ; mapping(uint32 => uint8) transformLevels ; function getTransformInfo ( uint32 _classId ) constant external returns ( uint32 transformClassId , uint8 level ) { transformClassId = transformClasses [ _classId ] ; level = transformLevels [ _classId ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(uint32 => uint8) layingEggLevels ; mapping(uint32 => uint8) layingEggDeductions ; mapping(uint32 => uint8) transformLevels ; mapping(uint32 => uint32) transformClasses ; function getClassTransformInfo ( uint32 _classId ) constant external returns ( uint8 layingLevel , uint8 layingCost , uint8 transformLevel , uint32 transformCLassId ) { layingLevel = layingEggLevels [ _classId ] ; layingCost = layingEggDeductions [ _classId ] ; transformLevel = transformLevels [ _classId ] ; transformCLassId = transformClasses [ _classId ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function owned ( ) internal { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function ( ) payable public { revert ( ) ; }}
pragma solidity 0.5.2; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.2; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.2; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.2; contract con_name { function genAddressFromGTIN13date ( string memory _GTIN13 , string memory _YYMMDD ) public pure returns ( address b ) { bytes32 a = keccak256 ( abi . encodePacked ( _GTIN13 , _YYMMDD ) ) ; assembly { mstore ( 0 , a ) b := mload ( 0 ) } return b ; }}
pragma solidity 0.5.2; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.2; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.19; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) payable public { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) mstore ( 0x40 , add ( ptr , returndatasize ) ) returndatacopy ( ptr , 0 , returndatasize ) switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }}
pragma solidity 0.4.19; contract con_name { uint256 _version ; function version ( ) public view returns ( uint256 ) { return _version ; }}
pragma solidity 0.4.19; contract con_name { address _implementation ; function implementation ( ) public view returns ( address ) { return _implementation ; }}
pragma solidity 0.4.19; contract con_name { address _upgradeabilityOwner ; function upgradeabilityOwner ( ) public view returns ( address ) { return _upgradeabilityOwner ; }}
pragma solidity 0.4.19; contract con_name { address _upgradeabilityOwner ; function setUpgradeabilityOwner ( address newUpgradeabilityOwner ) internal { _upgradeabilityOwner = newUpgradeabilityOwner ; }}
pragma solidity 0.5.4; contract con_name { mapping(string => bytes32) files ; function getFile ( string memory _name ) public view returns ( bytes32 ) { return files [ _name ] ; }}
pragma solidity 0.5.0; contract con_name { function isHuman ( address addr ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size == 0 ; }}
pragma solidity 0.4.21; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.21; contract con_name { function isContract ( address _addr ) private constant returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address owner ) public constant returns ( uint ) { return balances_ [ owner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowances_ ; function allowance ( address owner , address spender ) public constant returns ( uint256 remaining ) { return allowances_ [ owner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.25; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.25; contract con_name { function strConcat ( string _a , string _b ) internal pure returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; string memory ab = new string ( _ba . length + _bb . length ) ; bytes memory bab = bytes ( ab ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) bab [ k ++ ] = _ba [ i ] ; for ( i = 0 ; i < _bb . length ; i ++ ) bab [ k ++ ] = _bb [ i ] ; return string ( bab ) ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function createTokens ( ) internal { uint256 total = 180000000000000000000000000 ; balances [ this ] = total ; totalSupply = total ; }}
pragma solidity 0.4.21; contract con_name { address mintableAddress ; bool allowTransfer ; mapping(address => mapping(address => uint256)) allowed ; function changeTransfer ( bool allowed ) external { require ( msg . sender == mintableAddress ) ; allowTransfer = allowed ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _frozen ; function isFrozen ( address owner ) public view returns ( bool ) { return _frozen [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32) companyMap ; function getCompany ( bytes32 companyId ) public view returns ( bytes32 ) { return companyMap [ companyId ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 expireAfter ; function isExpired ( ) public view returns ( bool expire ) { return block . timestamp > expireAfter ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a , "Safe ADD check" ) ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( "ETH not acceptable" ) ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a , "Safe SUB check" ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "Safe MUL check" ) ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 , "Safe DIV check" ) ; c = a / b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.24; contract con_name { function owner ( ) public view returns ( address ) { }}
pragma solidity 0.4.24; contract con_name { address[] tokens ; function tokenCount ( ) public view returns ( uint256 ) { return tokens . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address[]) tokensToConverters ; function converterCount ( address _token ) public view returns ( uint256 ) { return tokensToConverters [ _token ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address[]) tokensToConverters ; function converterAddress ( address _token , uint32 _index ) public view returns ( address ) { if ( _index >= tokensToConverters [ _token ] . length ) return address ( 0 ) ; return tokensToConverters [ _token ] [ _index ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address) convertersToTokens ; function tokenAddress ( address _converter ) public view returns ( address ) { return convertersToTokens [ _converter ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _address ) public view returns ( uint256 ) { return balances [ _address ] ; }}
pragma solidity 0.4.23; contract con_name { function balanceOf ( address _owner ) public view returns ( uint256 ) ; } contract iNovaGame { function isAdminForGame ( uint _game , address account ) external view returns ( bool ) ; uint [ ] public games ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; require ( c / a == b , "mul failed" ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a / b ; }}
pragma solidity 0.4.23; contract con_name { uint256[] games ; function numberOfGames ( ) external view returns ( uint ) { return games . length ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "sub fail" ) ; return a - b ; }}
pragma solidity 0.4.23; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a , "add fail" ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => mapping(address => bool)) gameAdmins ; function isAdminForGame ( uint _game , address _account ) external view returns ( bool ) { return gameAdmins [ _game ] [ _account ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => address[]) adminAddressesByGameId ; function getAdminsForGame ( uint _game ) external view returns ( address [ ] ) { return adminAddressesByGameId [ _game ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) gameIdsByAdminAddress ; function getGamesForAdmin ( address _account ) external view returns ( uint [ ] ) { return gameIdsByAdminAddress [ _account ] ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.5.8; contract con_name { function storeDataAsContract ( bytes memory data ) internal returns ( address ) { address result ; assembly { let length := mload ( data ) mstore ( data , 0x58600c8038038082843982f3 ) result := create ( 0 , add ( data , 20 ) , add ( 12 , length ) ) } require ( result != address ( 0x0 ) ) ; return result ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public { }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(bytes4 => bool)) userPermissions ; function hasUserPermission ( address _who , bytes4 _methodsignature ) public view returns ( bool ) { return userPermissions [ _who ] [ _methodsignature ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) validators ; function isValidator ( address _validator ) public view returns ( bool ) { return validators [ _validator ] ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) _balances ; function put ( ) public payable { _balances [ msg . sender ] = msg . value ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) _balances ; function get ( ) public payable { bool success ; bytes memory data ; ( success , data ) = msg . sender . call . value ( _balances [ msg . sender ] ) ( "" ) ; if ( ! success ) { revert ( "withdrawal failed" ) ; } _balances [ msg . sender ] = 0 ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) _balances ; function withdraw ( ) public payable { bool success ; bytes memory data ; _balances [ msg . sender ] = 0 ; ( success , data ) = msg . sender . call . value ( _balances [ msg . sender ] ) ( "" ) ; if ( ! success ) { revert ( "withdrawal failed" ) ; } }}
pragma solidity 0.5.0; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.4.24 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function isNameValid ( string name ) internal pure returns ( bool ) { bytes memory temp = bytes ( name ) ; return temp . length >= 6 && temp . length <= 12 ; }}
pragma solidity 0.4.19; contract con_name { function stringToBytes12 ( string str ) internal pure returns ( bytes12 result ) { assembly { result := mload ( add ( str , 12 ) ) } }}
pragma solidity 0.4.18; contract con_name { function setSubnodeOwner ( bytes32 node , bytes32 label , address owner ) public ; function setResolver ( bytes32 node , address resolver ) public ; function setOwner ( bytes32 node , address owner ) public ; function setTTL ( bytes32 node , uint64 ttl ) public ; function owner ( bytes32 node ) public view returns ( address ) ; function resolver ( bytes32 node ) public view returns ( address ) ; function ttl ( bytes32 node ) public view returns ( uint64 ) ; } contract PublicResolver { bytes4 constant INTERFACE_META_ID = 0x01ffc9a7 ; bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de ; bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5 ; bytes4 constant NAME_INTERFACE_ID = 0x691f3431 ; bytes4 constant ABI_INTERFACE_ID = 0x2203ab56 ; bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233 ; bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c ; bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1 ; event AddrChanged ( bytes32 indexed node , address a ) ; event ContentChanged ( bytes32 indexed node , bytes32 hash ) ; event NameChanged ( bytes32 indexed node , string name ) ; event ABIChanged ( bytes32 indexed node , uint256 indexed contentType ) ; event PubkeyChanged ( bytes32 indexed node , bytes32 x , bytes32 y ) ; event TextChanged ( bytes32 indexed node , string indexedKey , string key ) ; event MultihashChanged ( bytes32 indexed node , bytes hash ) ; struct PublicKey { bytes32 x ; bytes32 y ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; address _owner ; function balanceOf ( address _owner ) public view returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { address _owner ; function balanceOf ( address who ) public constant returns ( uint ) ; function transfer ( address to , uint value ) public ; function transfer ( address to , uint value , bytes data ) public ; event Transfer ( address indexed from , address indexed to , uint value , bytes data ) ; } contract ERC223ReceivingContract { function tokenFallback ( address _from , uint _value , bytes _data ) public ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 ) ; return _a / _b ; }}
pragma solidity 0.4.25; contract con_name { address delegate_ ; function isDelegate ( address _addr ) public view returns ( bool ) { return _addr == delegate_ ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; return _a - _b ; }}
pragma solidity 0.4.25; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) minterAllowed ; function minterAllowance ( address minter ) public view returns ( uint256 ) { return minterAllowed [ minter ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) minters ; function isMinter ( address account ) public view returns ( bool ) { return minters [ account ] ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 c ) { c = _a + _b ; require ( c >= _a ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) blacklisted ; function isBlacklisted ( address _account ) public view returns ( bool ) { return blacklisted [ _account ] ; }}
pragma solidity 0.5.9; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.9; contract con_name { function safeMul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.9; contract con_name { function safeMod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _value > 0 , "Cannot use zero" ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.19; contract con_name { address owner ; function kill ( ) public { require ( owner == msg . sender ) ; selfdestruct ( owner ) ; }}
pragma solidity 0.4.18; contract con_name { address owner ; bool stopped ; function setStopped ( bool _stop ) public { require ( msg . sender == owner ) ; stopped = _stop ; }}
pragma solidity 0.4.24; contract con_name { function ( ) payable { }}
pragma solidity 0.4.16; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { function ( ) payable public { }}
pragma solidity 0.4.16; contract con_name { function sAssert ( bool assertion ) internal pure { if ( ! assertion ) { revert ( ) ; } }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public view returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) { count += 1 ; } } }}
pragma solidity 0.4.24; contract con_name { address[] owners ; function getOwners ( ) public view returns ( address [ ] ) { return owners ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public view returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.4.21; contract con_name { address contractManager ; function Manager ( ) public { contractManager = msg . sender ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => bytes32) commits ; mapping(address => uint256) heights ; function commit ( bytes32 commitment ) external { commits [ msg . sender ] = commitment ; heights [ msg . sender ] = block . number + 256 ; }}
pragma solidity 0.5.0; contract con_name { function calcFlagHash ( bytes32 flag ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( flag ) ) ; }}
pragma solidity 0.5.0; contract con_name { function calcCommitment ( bytes32 flag , address sender ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( flag , sender ) ) ; }}
pragma solidity 0.4.22; contract con_name { function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) external ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.22; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.22; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.22; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Stark" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "GuGan" ; }}
pragma solidity 0.5.8; contract con_name { function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.5.8; contract con_name { function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.5.8; contract con_name { function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }}
pragma solidity 0.5.8; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.8; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.8; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.8; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.8; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.5.3; contract con_name { address owner ; function getOwner ( ) external view returns ( address ) ; function getExchangeContract ( ) external view returns ( address ) ; function contractApproved ( address traderAddr ) external view returns ( bool ) ; function contractApprovedBoth ( address traderAddr1 , address traderAddr2 ) external view returns ( bool ) ; function acceptNextExchangeContract ( ) external ; } contract Ownable { address public owner ; address private nextOwner ; event OwnershipTransfer ( address newOwner , address previousOwner ) ; modifier onlyOwner { require ( msg . sender == owner , "onlyOwner methods called by non-owner." ) ; _ ; }}
pragma solidity 0.5.3; contract con_name { address owner ; function getOwner ( ) external view returns ( address ) { return owner ; }}
pragma solidity 0.5.3; contract con_name { address exchangeContract ; function getExchangeContract ( ) external view returns ( address ) { return exchangeContract ; }}
pragma solidity 0.5.3; contract con_name { uint256 exchangeContractVersion ; mapping(address => uint256) traderApprovals ; function contractApproved ( address traderAddr ) external view returns ( bool ) { if ( exchangeContractVersion > 1 ) { return exchangeContractVersion == traderApprovals [ traderAddr ] ; } else { return exchangeContractVersion == 1 ; } }}
pragma solidity 0.5.3; contract con_name { uint256 exchangeContractVersion ; mapping(address => uint256) traderApprovals ; function contractApprovedBoth ( address traderAddr1 , address traderAddr2 ) external view returns ( bool ) { if ( exchangeContractVersion > 1 ) { return exchangeContractVersion == traderApprovals [ traderAddr1 ] && exchangeContractVersion == traderApprovals [ traderAddr2 ] ; } else { return exchangeContractVersion == 1 ; } }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public returns ( uint ) ; function balanceOf ( address tokenOwner ) public returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => bool) admins ; function setAdmin ( address _newAdmin , bool _value ) public { require ( admins [ msg . sender ] == true ) ; admins [ _newAdmin ] = _value ; }}
pragma solidity 0.5.7; contract con_name { function safeAdd ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.7; contract con_name { function safeSub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.7; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.7; contract con_name { function safeMul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.7; contract con_name { function safeDiv ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.7; contract con_name { address payable owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address payable public owner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.7; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned2 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function SpareCurrencyToken ( ) { balances [ msg . sender ] = 51000000000000000000000000 ; totalSupply = 51000000000000000000000000 ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; return true ; } else { return false ; } }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; mapping(address => mapping(address => uint256)) allowed ; function transferFrom ( address _from , address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ _from ] -= _amount ; allowed [ _from ] [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; return true ; } else { return false ; } }}
pragma solidity 0.4.22; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.22; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.22; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.22; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.22; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.4.22; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.22; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function burn ( uint256 value ) external ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { bool _mintingFinished ; function mintingFinished ( ) public view returns ( bool ) { return _mintingFinished ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint16 => uint16) heroTypeToSupplyLimit ; function getSupplyLimit ( uint16 _heroType ) public view returns ( uint16 ) { return heroTypeToSupplyLimit [ _heroType ] ; }}
pragma solidity 0.4.24; contract con_name { string tokenURIPrefix ; function tokenURI ( uint256 tokenId ) public view returns ( string ) { bytes32 tokenIdBytes ; if ( tokenId == 0 ) { tokenIdBytes = "0" ; } else { uint256 value = tokenId ; while ( value > 0 ) { tokenIdBytes = bytes32 ( uint256 ( tokenIdBytes ) / ( 2 ** 8 ) ) ; tokenIdBytes |= bytes32 ( ( ( value % 10 ) + 48 ) * 2 ** ( 8 * 31 ) ) ; value /= 10 ; } } bytes memory prefixBytes = bytes ( tokenURIPrefix ) ; bytes memory tokenURIBytes = new bytes ( prefixBytes . length + tokenIdBytes . length ) ; uint8 i ; uint8 index = 0 ; for ( i = 0 ; i < prefixBytes . length ; i ++ ) { tokenURIBytes [ index ] = prefixBytes [ i ] ; index ++ ; } for ( i = 0 ; i < tokenIdBytes . length ; i ++ ) { tokenURIBytes [ index ] = tokenIdBytes [ i ] ; index ++ ; } return string ( tokenURIBytes ) ; }}
pragma solidity 0.4.24; contract con_name { function onERC721Received ( address operator , address from , uint256 tokenId , bytes data ) public returns ( bytes4 ) { return 0x150b7a02 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) admins ; function setAdmin ( address _newAdmin , bool _value ) public { require ( admins [ msg . sender ] == true ) ; admins [ _newAdmin ] = _value ; }}
pragma solidity 0.5.7; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.7; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.7; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.7; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.7; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { uint256 startBlock ; uint256 endBlock ; uint256 crowdSalePrice ; function price ( ) constant returns ( uint ) { if ( block . number < startBlock || block . number > endBlock ) return 0 ; else return crowdSalePrice ; }}
pragma solidity 0.4.18; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) candyBook ; uint256 candyPrice ; function checkCandy ( address recipient ) constant returns ( uint256 remaining ) { if ( candyBook [ recipient ] ) return 0 ; else return candyPrice ; }}
pragma solidity 0.4.18; contract con_name { address founder ; function changeFounder ( address newFounder ) { if ( msg . sender != founder ) throw ; founder = newFounder ; }}
pragma solidity 0.4.18; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) throw ; }}
pragma solidity 0.4.18; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.18; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.18; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.4.14; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Aurora" ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b , "mul overflow" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "div by 0" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.24; contract con_name { address[] allSigners ; function checkQuorum ( uint signersCount ) internal view returns ( bool isQuorum ) ; function getAllSignersCount ( ) view external returns ( uint allSignersCount ) { return allSigners . length ; }}
pragma solidity 0.4.24; contract con_name { address[] scriptAddresses ; function getScriptsCount ( ) view external returns ( uint scriptsCount ) { return scriptAddresses . length ; }}
pragma solidity 0.4.24; contract con_name { uint256 activeSignersCount ; function checkQuorum ( uint signersCount ) internal view returns ( bool isQuorum ) { isQuorum = signersCount > activeSignersCount / 2 ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "sub underflow" ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "add overflow" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function roundedDiv ( uint a , uint b ) internal pure returns ( uint256 ) { require ( b > 0 , "div by 0" ) ; uint256 z = a / b ; if ( a % b >= b / 2 ) { z ++ ; } return z ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public constant returns ( uint256 ) ; function balanceOf ( address _who ) public constant returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _fromValue , uint256 _toValue ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { address[] arrayAirDrops ; function getArrayAirDropsLength ( ) public view returns ( uint256 ) { return arrayAirDrops . length ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Musewvre" ; }}
pragma solidity 0.4.18; contract con_name { function genAddressFromGTIN13date ( string _GTIN13 , string _YYMMDD ) constant returns ( address c ) { bytes32 a = keccak256 ( _GTIN13 , _YYMMDD ) ; address b = address ( a ) ; return b ; }}
pragma solidity 0.5.4; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b != 0 ) ; return _a / _b ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.4; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; return _a - _b ; }}
pragma solidity 0.5.4; contract con_name { address owner ; function decimals ( ) external view returns ( uint8 ) ; function tokenFallback ( address _from , uint _value , bytes calldata _data ) external ; function transfer ( address _to , uint _value ) external returns ( bool ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { address _owner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address owner ) public view returns ( uint256 ) ; function allowance ( address owner , address spender ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; modifier onlyOwner ( ) { require ( msg . sender == _owner , "Unauthorized." ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { function _isContract ( address _account ) private view returns ( bool ) { uint256 size = 0 ; assembly { size := extcodesize ( _account ) } return size > 0 ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b , "Invalid argument." ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { bool _tradingStarted ; function trading ( ) public view returns ( bool ) { return _tradingStarted ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 , "Invalid argument." ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a , "Invalid argument." ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a , "Invalid argument." ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "Invalid argument." ) ; return a % b ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( "You cannot buy tokens." ) ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function sAssert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function MergeCoin ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.18; contract con_name { function ( ) payable { }}
pragma solidity 0.4.18; contract con_name { function max64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.18; contract con_name { function min64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.18; contract con_name { function max256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.18; contract con_name { function min256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => bool) whiteList ; function isWhiteListed ( address _user ) public view returns ( bool ) { return whiteList [ _user ] ; }}
pragma solidity 0.4.24; contract con_name { address[] dungeons ; function checkDungeons ( ) public view returns ( bool ) { for ( uint i = 0 ; i < dungeons . length ; i ++ ) { if ( msg . sender == dungeons [ i ] ) { return true ; } } return false ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _holder ) public view returns ( uint256 balance ) { return balances [ _holder ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _holder , address _spender ) public view returns ( uint256 ) { return allowed [ _holder ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; return _a - _b ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address addr ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) investors ; function getInvestedAmount ( address _investor ) public view returns ( uint256 ) { return investors [ _investor ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) external returns ( bool ) ; } contract onlyOwner { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function transfer ( address _to , uint _value ) public returns ( bool ) { }}
pragma solidity 0.4.21; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function sendTokens ( address _destination , address _token , uint256 _amount ) public ; function sendEther ( address _destination , uint256 _amount ) payable public ; } contract FSAContract { address owner = 0xc17cbf9917ca13d5263a8d4069e566be23db1b09 ; address cossContract = 0x9e96604445ec19ffed9a5e8dd7b50a29c899a10c ; modifier onlyOwner ( ) { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function allowance ( address owner , address spender ) public view returns ( uint256 ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; function mint ( uint256 value ) public returns ( bool ) ; function burn ( uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address src ) public view returns ( uint256 ) { return _balances [ src ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _approvals ; function allowance ( address src , address guy ) public view returns ( uint256 ) { return _approvals [ src ] [ guy ] ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function addPlanBase ( uint256 minimumAmount , uint256 lockTime , uint32 lessToHops ) external ; function togglePlanBase ( bytes32 planBaseId , bool isOpen ) external ; function growHops ( bytes32 planBaseId , uint256 lessAmount ) external ; function updateHopsAddress ( address _address ) external ; function updatelessAddress ( address _address ) external ; function withdraw ( bytes32 planId ) external ; function checkPlanBase ( bytes32 planBaseId ) external view returns ( uint256 , uint256 , uint32 , bool ) ; function checkPlanBaseIds ( ) external view returns ( bytes32 [ ] ) ; function checkPlanIdsByPlanBase ( bytes32 planBaseId ) external view returns ( bytes32 [ ] ) ; function checkPlanIdsByUser ( address user ) external view returns ( bytes32 [ ] ) ; function checkPlan ( bytes32 planId ) external view returns ( bytes32 , address , uint256 , uint256 , uint256 , uint256 , bool ) ; event PlanBaseEvt ( bytes32 planBaseId , uint256 minimumAmount , uint256 lockTime , uint32 lessToHops , bool isOpen ) ; event TogglePlanBaseEvt ( bytes32 planBaseId , bool isOpen ) ; event PlanEvt ( bytes32 planId , bytes32 planBaseId , address plantuser , uint256 lessAmount , uint256 hopsAmount , uint256 lockAt , uint256 releaseAt , bool isWithdrawn ) ; event WithdrawPlanEvt ( bytes32 planId , address plantuser , uint256 lessAmount , bool isWithdrawn , uint256 withdrawAt ) ; } library SafeMath { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a / b ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; require ( c / a == b , "SafeMath mul failed" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath sub failed" ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a , "SafeMath add failed" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] planBaseIds ; function checkPlanBaseIds ( ) external view returns ( bytes32 [ ] ) { return planBaseIds ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) planIdsByPlanBase ; function checkPlanIdsByPlanBase ( bytes32 planBaseId ) external view returns ( bytes32 [ ] ) { return planIdsByPlanBase [ planBaseId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bytes32[]) userToPlanIds ; function checkPlanIdsByUser ( address user ) external view returns ( bytes32 [ ] ) { return userToPlanIds [ user ] ; }}
pragma solidity 0.4.23; contract con_name { function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; } contract HybridProxy { struct Snapshot { uint256 tokens_balance ; uint256 eth_balance ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event transferOwner ( address indexed existingOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function jvCoin ( ) { balances [ msg . sender ] = 10000 ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function sendCoin ( address receiver , uint amount ) returns ( bool sufficient ) { if ( balances [ msg . sender ] < amount ) return false ; balances [ msg . sender ] -= amount ; balances [ receiver ] += amount ; return true ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) balances ; address _owner ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) allowed ; address _owner ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.21; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.21; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.21; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(bytes20 => uint256)) tradingPairCutoffs ; mapping(address => uint256) cutoffs ; function checkCutoffsBatch ( address [ ] owners , bytes20 [ ] tradingPairs , uint [ ] validSince ) external view { uint len = owners . length ; require ( len == tradingPairs . length ) ; require ( len == validSince . length ) ; for ( uint i = 0 ; i < len ; i ++ ) { require ( validSince [ i ] > tradingPairCutoffs [ owners [ i ] ] [ tradingPairs [ i ] ] ) ; require ( validSince [ i ] > cutoffs [ owners [ i ] ] ) ; } }}
pragma solidity 0.4.21; contract con_name { function tolerantSub ( uint a , uint b ) internal pure returns ( uint c ) { return ( a >= b ) ? a - b : 0 ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 c ) { if ( _a == 0 ) { return 0 ; } c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { return _a / _b ; }}
pragma solidity 0.4.25; contract con_name { address upgradeMaster ; function setUpgradeMaster ( address master ) public { require ( master != address ( 0 ) , "The provided upgradeMaster is required to be a non-empty address when setting upgrade master." ) ; require ( msg . sender == upgradeMaster , "Message sender is required to be the original upgradeMaster when setting (new) upgrade master." ) ; upgradeMaster = master ; }}
pragma solidity 0.4.25; contract con_name { bool canUpgrade_ ; function canUpgrade ( ) public view returns ( bool ) { return canUpgrade_ ; }}
pragma solidity 0.4.25; contract con_name { function isUpgradeAgent ( ) public pure returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { function external_call ( address destination , uint value , uint dataLength , bytes data ) internal returns ( bool ) { bool result ; assembly { let x := mload ( 0x40 ) let d := add ( data , 32 ) result := call ( sub ( gas , 34710 ) , destination , value , d , dataLength , x , 0 ) } return result ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public constant returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; function getOwners ( ) public constant returns ( address [ ] ) { return owners ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public constant returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.4.24; contract con_name { function rawAddress ( bytes memory input ) internal pure returns ( uint256 memoryAddress ) { assembly { memoryAddress := input } return memoryAddress ; }}
pragma solidity 0.4.24; contract con_name { function contentAddress ( bytes memory input ) internal pure returns ( uint256 memoryAddress ) { assembly { memoryAddress := add ( input , 32 ) } return memoryAddress ; }}
pragma solidity 0.4.24; contract con_name { function memCopy ( uint256 dest , uint256 source , uint256 length ) internal pure { if ( length < 32 ) { assembly { let mask := sub ( exp ( 256 , sub ( 32 , length ) ) , 1 ) let s := and ( mload ( source ) , not ( mask ) ) let d := and ( mload ( dest ) , mask ) mstore ( dest , or ( s , d ) ) } } else { if ( source == dest ) { return ; } if ( source > dest ) { assembly { length := sub ( length , 32 ) let sEnd := add ( source , length ) let dEnd := add ( dest , length ) let last := mload ( sEnd ) for { } lt ( source , sEnd ) { } { mstore ( dest , mload ( source ) ) source := add ( source , 32 ) dest := add ( dest , 32 ) } mstore ( dEnd , last ) } } else { assembly { length := sub ( length , 32 ) let sEnd := add ( source , length ) let dEnd := add ( dest , length ) let first := mload ( source ) for { } slt ( dest , dEnd ) { } { mstore ( dEnd , mload ( sEnd ) ) sEnd := sub ( sEnd , 32 ) dEnd := sub ( dEnd , 32 ) } mstore ( dest , first ) } } } }}
pragma solidity 0.4.24; contract con_name { function sliceDestructive ( bytes memory b , uint256 from , uint256 to ) internal pure returns ( bytes memory result ) { require ( from <= to , "FROM_LESS_THAN_TO_REQUIRED" ) ; require ( to < b . length , "TO_LESS_THAN_LENGTH_REQUIRED" ) ; assembly { result := add ( b , from ) mstore ( result , sub ( to , from ) ) } return result ; }}
pragma solidity 0.4.24; contract con_name { function popLastByte ( bytes memory b ) internal pure returns ( bytes1 result ) { require ( b . length > 0 , "GREATER_THAN_ZERO_LENGTH_REQUIRED" ) ; result = b [ b . length - 1 ] ; assembly { let newLen := sub ( mload ( b ) , 1 ) mstore ( b , newLen ) } return result ; }}
pragma solidity 0.4.24; contract con_name { function equals ( bytes memory lhs , bytes memory rhs ) internal pure returns ( bool equal ) { return lhs . length == rhs . length && keccak256 ( lhs ) == keccak256 ( rhs ) ; }}
pragma solidity 0.4.24; contract con_name { function readAddress ( bytes memory b , uint256 index ) internal pure returns ( address result ) { require ( b . length >= index + 20 , "GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED" ) ; index += 20 ; assembly { result := and ( mload ( add ( b , index ) ) , 0xffffffffffffffffffffffffffffffffffffffff ) } return result ; }}
pragma solidity 0.4.24; contract con_name { function writeAddress ( bytes memory b , uint256 index , address input ) internal pure { require ( b . length >= index + 20 , "GREATER_OR_EQUAL_TO_20_LENGTH_REQUIRED" ) ; index += 20 ; assembly { let neighbors := and ( mload ( add ( b , index ) ) , 0xffffffffffffffffffffffff0000000000000000000000000000000000000000 ) input := and ( input , 0xffffffffffffffffffffffffffffffffffffffff ) mstore ( add ( b , index ) , xor ( input , neighbors ) ) } }}
pragma solidity 0.4.24; contract con_name { function readBytes32 ( bytes memory b , uint256 index ) internal pure returns ( bytes32 result ) { require ( b . length >= index + 32 , "GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED" ) ; index += 32 ; assembly { result := mload ( add ( b , index ) ) } return result ; }}
pragma solidity 0.4.24; contract con_name { function writeBytes32 ( bytes memory b , uint256 index , bytes32 input ) internal pure { require ( b . length >= index + 32 , "GREATER_OR_EQUAL_TO_32_LENGTH_REQUIRED" ) ; index += 32 ; assembly { mstore ( add ( b , index ) , input ) } }}
pragma solidity 0.4.24; contract con_name { function readBytes4 ( bytes memory b , uint256 index ) internal pure returns ( bytes4 result ) { require ( b . length >= index + 4 , "GREATER_OR_EQUAL_TO_4_LENGTH_REQUIRED" ) ; index += 32 ; assembly { result := mload ( add ( b , index ) ) result := and ( result , 0xFFFFFFFF00000000000000000000000000000000000000000000000000000000 ) } return result ; }}
pragma solidity 0.4.24; contract con_name { bytes32 implementationPosition_ ; function ( ) payable public { bytes32 implementationPosition = implementationPosition_ ; address _impl ; assembly { _impl := sload ( implementationPosition ) } assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.4.24; contract con_name { address _implementation ; function implementation ( ) public view returns ( address ) { return _implementation ; }}
pragma solidity 0.4.24; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) payable public { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.4.13; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { address profitContainerAddress ; address companyWalletAddress ; uint256 etherRatioForOwner ; address multiSigAddress ; address accountAddressForSponsee ; function RBInformationStore ( address _profitContainerAddress , address _companyWalletAddress , uint _etherRatioForOwner , address _multiSigAddress , address _accountAddressForSponsee ) { profitContainerAddress = _profitContainerAddress ; companyWalletAddress = _companyWalletAddress ; etherRatioForOwner = _etherRatioForOwner ; multiSigAddress = _multiSigAddress ; accountAddressForSponsee = _accountAddressForSponsee ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function Ownable ( ) internal { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address major_partner_address ; uint256 gas ; address minor_partner_address ; address investment_address ; function execute_transfer ( uint transfer_amount ) internal { uint major_fee = transfer_amount * 6 / ( 10 * 11 ) ; uint minor_fee = transfer_amount * 4 / ( 10 * 11 ) ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; require ( investment_address . call . gas ( gas ) . value ( transfer_amount - major_fee - minor_fee ) ( ) ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) documentIssued ; function isIssued ( bytes32 document ) public view returns ( bool ) { return ( documentIssued [ document ] != 0 ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) documentIssued ; function isIssuedBefore ( bytes32 document , uint blockNumber ) public view returns ( bool ) { return documentIssued [ document ] != 0 && documentIssued [ document ] <= blockNumber ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) documentRevoked ; function isRevoked ( bytes32 document ) public view returns ( bool ) { return documentRevoked [ document ] != 0 ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) documentRevoked ; function isRevokedBefore ( bytes32 document , uint blockNumber ) public view returns ( bool ) { return documentRevoked [ document ] <= blockNumber && documentRevoked [ document ] != 0 ; }}
pragma solidity 0.4.24; contract con_name { address[] tokenAddresses ; function getTokenAddresses ( ) public view returns ( address [ ] ) { return tokenAddresses ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => address) tokenBySymbol ; function getTokenAddressBySymbol ( string _symbol ) public view returns ( address ) { return tokenBySymbol [ _symbol ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => address) tokenByName ; function getTokenAddressByName ( string _name ) public view returns ( address ) { return tokenByName [ _name ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.16; contract con_name { uint256 totalSupply ; uint64 totalTokens ; uint8 decimals ; mapping(address => uint256) balanceOf ; address ownerWallet ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public ; } contract AsinerumShareToken { string public name = "Asinerum Share" ; string public symbol = "ARS" ; uint8 public decimals = 15 ; uint64 public totalTokens = 172000000 ; uint64 public priceTokenToCoin = 5000 ; uint256 public totalSupply ; address public ownerWallet ; mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 ) ) public allowance ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; function AsinerumShareToken ( ) public { totalSupply = totalTokens * 10 ** uint256 ( decimals ) ; balanceOf [ msg . sender ] = totalSupply ; ownerWallet = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.18; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.18; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function Success3D ( ) public { balances [ msg . sender ] = startBalance * 6000000 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.21; contract con_name { function bytes32ArrayToString ( bytes32 [ ] data ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( data . length * 32 ) ; uint urlLength ; for ( uint i = 0 ; i < data . length ; i ++ ) { for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( data [ i ] ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ urlLength ] = char ; urlLength += 1 ; } } } bytes memory bytesStringTrimmed = new bytes ( urlLength ) ; for ( i = 0 ; i < urlLength ; i ++ ) { bytesStringTrimmed [ i ] = bytesString [ i ] ; } return string ( bytesStringTrimmed ) ; }}
pragma solidity 0.4.21; contract con_name { function uintToBytes ( uint v ) internal pure returns ( bytes32 ret ) { if ( v == 0 ) { ret = 0 ; } else { while ( v > 0 ) { ret = bytes32 ( uint ( ret ) / ( 2 ** 8 ) ) ; ret |= bytes32 ( ( ( v % 10 ) + 48 ) * 2 ** ( 8 * 31 ) ) ; v /= 10 ; } } return ret ; }}
pragma solidity 0.4.21; contract con_name { function addressToBytes ( address a ) internal pure returns ( bytes32 b ) { assembly { let m := mload ( 0x40 ) mstore ( add ( m , 20 ) , xor ( 0x140000000000000000000000000000000000000000 , a ) ) mstore ( 0x40 , add ( m , 52 ) ) b := m } }}
pragma solidity 0.4.21; contract con_name { function bytesToBytes32 ( bytes b , uint offset ) internal pure returns ( bytes32 ) { bytes32 out ; for ( uint i = 0 ; i < 32 ; i ++ ) { out |= bytes32 ( b [ offset + i ] & 0xFF ) >> ( i * 8 ) ; } return out ; }}
pragma solidity 0.4.21; contract con_name { function bytes32ToString ( bytes32 x ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( x ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ charCount ] = char ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }}
pragma solidity 0.4.21; contract con_name { function bytes32ToBytes ( bytes32 data ) internal pure returns ( bytes ) { uint i = 0 ; while ( i < 32 && uint ( data [ i ] ) != 0 ) { ++ i ; } bytes memory result = new bytes ( i ) ; i = 0 ; while ( i < 32 && data [ i ] != 0 ) { result [ i ] = data [ i ] ; ++ i ; } return result ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function YOLOCASH ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.5.1; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.1; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.1; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.5.1; contract con_name { uint8 decimals ; function getDecimals ( ) public view returns ( uint ) { return decimals ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint tokenOwnerBalance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.1; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.1; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.1; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.1; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Martin" ; }}
pragma solidity 0.5.6; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.5.6; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.6; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.6; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.5.6; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.6; contract con_name { bool _mintingFinished ; function mintingFinished ( ) public view returns ( bool ) { return _mintingFinished ; }}
pragma solidity 0.5.6; contract con_name { bool _transferEnabled ; function transferEnabled ( ) public view returns ( bool ) { return _transferEnabled ; }}
pragma solidity 0.5.6; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.6; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.6; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.6; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.6; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.21; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.21; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.23; contract con_name { function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.23; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.4.23; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.23; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.5.4; contract con_name { function genAddressFromGTIN13date ( string memory _GTIN13 , string memory _YYMMDD ) public pure returns ( address b ) { bytes32 a = keccak256 ( abi . encodePacked ( _GTIN13 , _YYMMDD ) ) ; assembly { mstore ( 0 , a ) b := mload ( 0 ) } return b ; }}
pragma solidity 0.5.4; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply_ ; uint256 INITIAL_SUPPLY ; mapping(address => uint256) balances ; function BiboToken ( ) public { totalSupply_ = INITIAL_SUPPLY ; balances [ msg . sender ] = INITIAL_SUPPLY ; }}
pragma solidity 0.4.24; contract con_name { address _owner ; function tokenFallback ( address _from , uint _value , bytes _data ) public ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.24; contract con_name { function tokenFallback ( address , uint , bytes ) public pure { }}
pragma solidity 0.4.20; contract con_name { address owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { uint256 aquaTokenAudCentsPrice ; function getAquaTokenAudCentsPrice ( ) external constant returns ( uint ) { return aquaTokenAudCentsPrice ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "undefined" ; }}
pragma solidity 0.4.19; contract con_name { address me ; function MyFriendships ( ) public { me = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address me ; mapping(address => bool) myFriends ; address latestFriend ; uint256 numberOfFriends ; function becomeFriendsWithMe ( ) public { require ( msg . sender != me ) ; myFriends [ msg . sender ] = true ; latestFriend = msg . sender ; numberOfFriends ++ ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) myFriends ; function friendsWith ( address addr ) public view returns ( bool ) { return myFriends [ addr ] ; }}
pragma solidity 0.4.19; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.20; contract con_name { function getUint256Min ( ) internal pure returns ( uint256 ) { return 0 ; }}
pragma solidity 0.4.20; contract con_name { function getUint256Max ( ) internal pure returns ( uint256 ) { return 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff ; }}
pragma solidity 0.4.20; contract con_name { function isMultipleOf ( uint256 a , uint256 b ) internal pure returns ( bool ) { return a % b == 0 ; }}
pragma solidity 0.4.20; contract con_name { bool initialized ; function getInitialized ( ) public view returns ( bool ) { return initialized ; }}
pragma solidity 0.4.20; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.20; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.20; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a <= b ) { return a ; } else { return b ; } }}
pragma solidity 0.4.20; contract con_name { function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a >= b ) { return a ; } else { return b ; } }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { address deployer ; address cdpAddr ; function open ( ) external returns ( bytes32 cup ) ; function give ( bytes32 cup , address guy ) external ; } contract UniqueCDP { address public deployer ; address public cdpAddr ; constructor ( address saiTub ) public { deployer = msg . sender ; cdpAddr = saiTub ; }}
pragma solidity 0.4.19; contract con_name { function getHash ( string _input ) public pure returns ( bytes32 hash ) { return keccak256 ( _input ) ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) likeCount ; mapping(address => uint256) dislikeCount ; function PizzaPoll ( ) { likeCount [ msg . sender ] = 0 ; dislikeCount [ msg . sender ] = 0 ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) likeCount ; function GetLikeCount ( ) returns ( uint count ) { return likeCount [ msg . sender ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) dislikeCount ; function GetDislikeCount ( ) returns ( uint count ) { return dislikeCount [ msg . sender ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => bool) pizzaIsLiked ; mapping(address => uint256) likeCount ; mapping(address => uint256) dislikeCount ; function Vote ( address voterAddress , bool isLiked ) { pizzaIsLiked [ voterAddress ] = isLiked ; if ( isLiked ) { likeCount [ msg . sender ] += 1 ; } else { dislikeCount [ msg . sender ] += 1 ; } }}
pragma solidity 0.4.16; contract con_name { function safeMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function safeSub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.16; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( _value <= 0 ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.5.7; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.21; contract con_name { function convertCountryIndexToBytes ( uint [ ] countries ) internal returns ( uint , uint , uint ) { uint countries1 = 0 ; uint countries2 = 0 ; uint countries3 = 0 ; for ( uint i = 0 ; i < countries . length ; i ++ ) { uint index = countries [ i ] ; if ( index < 256 ) { countries1 = countries1 | uint ( 1 ) << index ; } else if ( index < 512 ) { countries2 = countries2 | uint ( 1 ) << ( index - 256 ) ; } else { countries3 = countries3 | uint ( 1 ) << ( index - 512 ) ; } } return ( countries1 , countries2 , countries3 ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function s_Form001 ( ) { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { uint256 _supply ; mapping(address => uint256) _balances ; function MOREToken ( ) public { _supply = 10 * ( 10 ** 9 ) * ( 10 ** 18 ) ; _balances [ msg . sender ] = _supply ; }}
pragma solidity 0.4.20; contract con_name { uint256 _supply ; function totalSupply ( ) public view returns ( uint256 ) { return _supply ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address src ) public view returns ( uint256 ) { return _balances [ src ] ; }}
pragma solidity 0.4.20; contract con_name { function add ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x + y ; require ( z >= x && z >= y ) ; return z ; }}
pragma solidity 0.4.20; contract con_name { function sub ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x - y ; require ( x >= y && z <= x ) ; return z ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; string name ; uint8 decimals ; string symbol ; function IDOToken ( ) { balances [ msg . sender ] = 10000000000000 ; totalSupply = 10000000000000 ; name = "I DO Token" ; decimals = 8 ; symbol = "IDO" ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes4 => bool) supportedInterfaces ; function supportsInterface ( bytes4 _interfaceId ) external view returns ( bool ) { return supportedInterfaces [ _interfaceId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes4 => bool) supportedInterfaces ; function _registerInterface ( bytes4 _interfaceId ) internal { require ( _interfaceId != 0xffffffff ) ; supportedInterfaces [ _interfaceId ] = true ; }}
pragma solidity 0.4.24; contract con_name { string _ERC721name ; function name ( ) external view returns ( string _name ) { return _ERC721name ; }}
pragma solidity 0.4.24; contract con_name { string _ERC721symbol ; function symbol ( ) external view returns ( string _symbol ) { return _ERC721symbol ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address addr ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint16) roles ; function onlyRoles ( address _sender , uint16 _roleMask ) view external returns ( bool ) { return roles [ _sender ] & _roleMask != 0 ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.25; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.17; contract con_name { function Util ( ) public { }}
pragma solidity 0.4.17; contract con_name { function strConcat ( string _a , string _b , string _c , string _d , string _e ) internal pure returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; bytes memory _bc = bytes ( _c ) ; bytes memory _bd = bytes ( _d ) ; bytes memory _be = bytes ( _e ) ; string memory abcde = new string ( _ba . length + _bb . length + _bc . length + _bd . length + _be . length ) ; bytes memory babcde = bytes ( abcde ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) babcde [ k ++ ] = _ba [ i ] ; for ( i = 0 ; i < _bb . length ; i ++ ) babcde [ k ++ ] = _bb [ i ] ; for ( i = 0 ; i < _bc . length ; i ++ ) babcde [ k ++ ] = _bc [ i ] ; for ( i = 0 ; i < _bd . length ; i ++ ) babcde [ k ++ ] = _bd [ i ] ; for ( i = 0 ; i < _be . length ; i ++ ) babcde [ k ++ ] = _be [ i ] ; return string ( babcde ) ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function EasyTax ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.20; contract con_name { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { function safeDiv ( uint a , uint b ) internal returns ( uint ) { assert ( b > 0 ) ; uint c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.20; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { function max64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.20; contract con_name { function min64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.20; contract con_name { function max256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.20; contract con_name { function min256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; address owner ; function balanceOf ( address owner ) public view returns ( uint256 ) { return balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; address owner ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == owner ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract ERC20Interface { function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.5.8; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.5.5; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.5; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.5.5; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.5; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.5; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.5; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.5; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.18; contract con_name { function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function div ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenHolder ) public constant returns ( uint256 _balance ) { return balances [ _tokenHolder ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 _allowance ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function sub ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function add ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Administration ( ) { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address ceoAddress ; mapping(address => bool) admins ; function EthVerifyCore ( ) public { ceoAddress = msg . sender ; admins [ ceoAddress ] = true ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transfer ( address receiver , uint amount ) external ; } contract Ownable { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Nintendo" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "Nintnedo" ; }}
pragma solidity 0.4.18; contract con_name { function Nicks ( ) public { }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function LaszloCoin ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Play2LivePromo ( ) { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _investor ) public constant returns ( uint256 ) { return balances [ _investor ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "LIN, FANG-PAN" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "MuYiChen" ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _tokenOwner , address _spender ) public constant returns ( uint remaining ) { return allowed [ _tokenOwner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint _value ) returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract FusionchainApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract FusionchainOwned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenOwner ) public constant returns ( uint balance ) { return balances [ _tokenOwner ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed from , address indexed to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Migrations ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "piggy" ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.22; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.22; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.4.22; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.4.22; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.17; contract con_name { uint256 MAX_UINT256 ; function balanceOf ( address who ) public constant returns ( uint ) ; function totalSupply ( ) constant public returns ( uint256 _supply ) ; function transfer ( address to , uint value ) public returns ( bool ok ) ; function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ; function approve ( address _spender , uint256 _value ) returns ( bool success ) ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint _value ) ; function name ( ) constant public returns ( string _name ) ; function symbol ( ) constant public returns ( string _symbol ) ; function decimals ( ) constant public returns ( uint8 _decimals ) ; function transfer ( address to , uint value , bytes data ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data , string customFallback ) public returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) revert ( ) ; return x + y ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function smul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function sdiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.18; contract con_name { function isContract ( address _addr ) constant private returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function ssub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function sadd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function SilkrouteCoin ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => bool) managers ; function NovaAccessControl ( ) public { managers [ msg . sender ] = true ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; function _transfer ( address _from , address _to , uint _value ) internal { require ( _to != 0x0 ) ; require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value > balanceOf [ _to ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 value ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; event FrozenFunds ( address target , bool frozen ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { string[] flow ; uint256 count ; function addPhrase ( string _newPhrase ) public { flow . push ( _newPhrase ) ; count = count + 1 ; }}
pragma solidity 0.4.21; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.21; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.21; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.21; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Skyline" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "Skyline" ; }}
pragma solidity 0.4.17; contract con_name { bytes32 ballotEncryptionPubkey ; function getEncPubkey ( ) public constant returns ( bytes32 ) { return ballotEncryptionPubkey ; }}
pragma solidity 0.4.17; contract con_name { bytes32 ballotEncryptionSeckey ; function getEncSeckey ( ) public constant returns ( bytes32 ) { return ballotEncryptionSeckey ; }}
pragma solidity 0.4.17; contract con_name { function getBallotOptNumber ( ) public pure returns ( uint256 ) { return 5 ; }}
pragma solidity 0.4.14; contract con_name { address ETH_address ; function NRB_Common ( ) public { ETH_address = 0x1 ; }}
pragma solidity 0.4.14; contract con_name { bool _init ; address FLC_address ; address NRB_address ; mapping(address => bool) whitelist ; function init ( address _main , address _flc ) public { require ( ! _init ) ; FLC_address = _flc ; NRB_address = _main ; whitelist [ NRB_address ] = true ; _init = true ; }}
pragma solidity 0.4.14; contract con_name { uint256 tokenlenth ; function getTokenListLength ( ) constant public returns ( uint ) { return tokenlenth - 1 ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; function ownerCount ( ) public constant returns ( uint256 ) { return owners . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) ownerMap ; function isOwner ( address owner ) public constant returns ( bool ) { return ownerMap [ owner ] ; }}
pragma solidity 0.4.18; contract con_name { function Usernames ( ) public { }}
pragma solidity 0.5.5; contract con_name { function transfer ( address to , uint256 value ) public returns ( bool ) { }}
pragma solidity 0.5.5; contract con_name { address GTT_ADDRESS ; function setTokenAddress ( address _gttAddress ) public { if ( GTT_ADDRESS == address ( 0 ) ) { GTT_ADDRESS = _gttAddress ; } }}
pragma solidity 0.4.18; contract con_name { address owner ; function DPOS ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { function InvestorWhiteList ( ) { }}
pragma solidity 0.4.20; contract con_name { mapping(address => bool) investorWhiteList ; function isAllowed ( address investor ) constant external returns ( bool result ) { return investorWhiteList [ investor ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => address) referralList ; function getReferralOf ( address investor ) constant external returns ( address result ) { return referralList [ investor ] ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function s_Form003 ( ) { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { uint16 votesYes ; uint16 votesNo ; function isYesWinning ( ) public view returns ( uint8 ) { if ( votesYes >= votesNo ) { return 0 ; } else { return 1 ; } }}
pragma solidity 0.4.23; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.23; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.23; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.23; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.23; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.23; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { function canTransfer ( address from , address to , uint8 toKind , address store ) external view returns ( bool ) { return false ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) userExpPool ; function getUserExp ( address addr ) public view returns ( uint256 exp ) { return userExpPool [ addr ] ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) userExpPool ; function getVIPLevel ( address user ) public view returns ( uint256 level ) { uint exp = userExpPool [ user ] ; if ( exp >= 30 ether && exp < 150 ether ) { level = 1 ; } else if ( exp >= 150 ether && exp < 300 ether ) { level = 2 ; } else if ( exp >= 300 ether && exp < 1500 ether ) { level = 3 ; } else if ( exp >= 1500 ether && exp < 3000 ether ) { level = 4 ; } else if ( exp >= 3000 ether && exp < 15000 ether ) { level = 5 ; } else if ( exp >= 15000 ether && exp < 30000 ether ) { level = 6 ; } else if ( exp >= 30000 ether && exp < 150000 ether ) { level = 7 ; } else if ( exp >= 150000 ether ) { level = 8 ; } else { level = 0 ; } return level ; }}
pragma solidity 0.4.21; contract con_name { function userRollDice ( uint , address ) payable { uint ; address ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function FixBet51 ( ) { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract CheckErc20 { mapping ( address => string ) public erc20Map ; address [ ] public erc20Array ; address owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address[] erc20Array ; function getAllContract ( ) public view returns ( address [ ] ) { return erc20Array ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function Cipher ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { function safeMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function ( ) payable { revert ( ) ; }}
pragma solidity 0.4.18; contract con_name { function safeSub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.24; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) external returns ( bool ) ; } contract onlyOwner { address public owner ; bool private stopped = false ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balanceOf ; function MYCCToken ( uint256 initialSupply ) public { balanceOf [ msg . sender ] = initialSupply ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balanceOf ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; return true ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => string) proofs ; function register ( string memory kinAddress ) public { proofs [ msg . sender ] = kinAddress ; }}
pragma solidity 0.4.16; contract con_name { function MultiTransfer ( ) public { }}
pragma solidity 0.4.25; contract con_name { function ( ) external payable { require ( msg . value == 0 , "This contract doest not accept ether" ) ; }}
pragma solidity 0.4.23; contract con_name { function balanceOf ( address _owner ) constant returns ( uint ) { return 1000000000000000000000 ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { function transfer ( address _to , uint _value ) public returns ( bool success ) { return true ; }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint _value ) public returns ( bool success ) { return true ; }}
pragma solidity 0.4.18; contract con_name { function approve ( address _spender , uint _value ) public returns ( bool success ) { return false ; }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return 0 ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function mint ( ) public returns ( bool success ) { balances [ msg . sender ] += 1 ; return true ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { function name ( ) external view returns ( string ) ; function symbol ( ) external view returns ( string ) ; function decimals ( ) external view returns ( uint8 ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function increaseAllowance ( address spender , uint256 addedValue ) external returns ( bool ) ; function decreaseAllowance ( address spender , uint256 subtractedValue ) external returns ( bool ) ; function mint ( address to , uint256 value ) external returns ( bool ) ; function burn ( address from , uint256 value ) external returns ( bool ) ; function isMinter ( address account ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; event Paused ( address account ) ; event Unpaused ( address account ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) addressValidated ; function isValidator ( address _who ) public view returns ( bool ) { return addressValidated [ _who ] ; }}
pragma solidity 0.4.25; contract con_name { address[] addresses ; function getValidators ( ) public view returns ( address [ ] ) { return addresses ; }}
pragma solidity 0.5.9; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.9; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.5.9; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.20; contract con_name { function isContract ( address addr ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }}
pragma solidity 0.4.20; contract con_name { function ( ) payable public { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; string name ; uint8 decimals ; string symbol ; function LINDOToken ( ) { balances [ msg . sender ] = 0.1 ether ; totalSupply = 0.1 ether ; name = "LINDO Token" ; decimals = 8 ; symbol = "LINDO" ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { address _owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.5.2; contract con_name { address proxied ; function ( ) external payable { address addr = proxied ; assembly { let freememstart := mload ( 0x40 ) calldatacopy ( freememstart , 0 , calldatasize ( ) ) let success := delegatecall ( not ( 0 ) , addr , freememstart , calldatasize ( ) , freememstart , 0 ) returndatacopy ( freememstart , 0 , returndatasize ( ) ) switch success case 0 { revert ( freememstart , returndatasize ( ) ) } default { return ( freememstart , returndatasize ( ) ) } } }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) owners ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _data ) public ; } contract CustomToken { function approveAndCall ( address _to , uint256 _value , bytes _data ) public returns ( bool ) ; event ApproveAndCall ( address indexed _from , address indexed _to , uint256 _value , bytes _data ) ; } contract ExtendsOwnable { mapping ( address => bool ) public owners ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; event OwnershipRevoked ( address indexed revokedOwner ) ; event OwnershipExtended ( address indexed host , address indexed guest ) ; modifier onlyOwner ( ) { require ( owners [ msg . sender ] ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address _addr ) private view returns ( bool ) { uint256 length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) uintStorage ; function set ( bytes32 _key , uint256 _value ) internal { uintStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) addressStorage ; function set ( bytes32 _key , address _value ) internal { addressStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) addressArrayStorage ; function deleteArrayAddress ( bytes32 _key , uint256 _index ) internal { address [ ] storage array = addressArrayStorage [ _key ] ; require ( _index < array . length , "Index should less than length of the array" ) ; array [ _index ] = array [ array . length - 1 ] ; array . length = array . length - 1 ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) bytes32ArrayStorage ; function deleteArrayBytes32 ( bytes32 _key , uint256 _index ) internal { bytes32 [ ] storage array = bytes32ArrayStorage [ _key ] ; require ( _index < array . length , "Index should less than length of the array" ) ; array [ _index ] = array [ array . length - 1 ] ; array . length = array . length - 1 ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256[]) uintArrayStorage ; function deleteArrayUint ( bytes32 _key , uint256 _index ) internal { uint256 [ ] storage array = uintArrayStorage [ _key ] ; require ( _index < array . length , "Index should less than length of the array" ) ; array [ _index ] = array [ array . length - 1 ] ; array . length = array . length - 1 ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string[]) stringArrayStorage ; function deleteArrayString ( bytes32 _key , uint256 _index ) internal { string [ ] storage array = stringArrayStorage [ _key ] ; require ( _index < array . length , "Index should less than length of the array" ) ; array [ _index ] = array [ array . length - 1 ] ; array . length = array . length - 1 ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) addressArrayStorage ; function pushArray ( bytes32 _key , address _value ) internal { addressArrayStorage [ _key ] . push ( _value ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) bytes32ArrayStorage ; function pushArray ( bytes32 _key , bytes32 _value ) internal { bytes32ArrayStorage [ _key ] . push ( _value ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string[]) stringArrayStorage ; function pushArray ( bytes32 _key , string _value ) internal { stringArrayStorage [ _key ] . push ( _value ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256[]) uintArrayStorage ; function pushArray ( bytes32 _key , uint256 _value ) internal { uintArrayStorage [ _key ] . push ( _value ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) addressArrayStorage ; function setArray ( bytes32 _key , address [ ] _value ) internal { addressArrayStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256[]) uintArrayStorage ; function setArray ( bytes32 _key , uint256 [ ] _value ) internal { uintArrayStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bool) boolStorage ; function set ( bytes32 _key , bool _value ) internal { boolStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) bytes32ArrayStorage ; function setArray ( bytes32 _key , bytes32 [ ] _value ) internal { bytes32ArrayStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string[]) stringArrayStorage ; function setArray ( bytes32 _key , string [ ] _value ) internal { stringArrayStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) addressArrayStorage ; function getArrayAddress ( bytes32 _key ) internal view returns ( address [ ] ) { return addressArrayStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) bytes32ArrayStorage ; function getArrayBytes32 ( bytes32 _key ) internal view returns ( bytes32 [ ] ) { return bytes32ArrayStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string[]) stringArrayStorage ; function getArrayString ( bytes32 _key ) internal view returns ( string [ ] ) { return stringArrayStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256[]) uintArrayStorage ; function getArrayUint ( bytes32 _key ) internal view returns ( uint [ ] ) { return uintArrayStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address[]) addressArrayStorage ; function setArrayIndexValue ( bytes32 _key , uint256 _index , address _value ) internal { addressArrayStorage [ _key ] [ _index ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256[]) uintArrayStorage ; function setArrayIndexValue ( bytes32 _key , uint256 _index , uint256 _value ) internal { uintArrayStorage [ _key ] [ _index ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32[]) bytes32ArrayStorage ; function setArrayIndexValue ( bytes32 _key , uint256 _index , bytes32 _value ) internal { bytes32ArrayStorage [ _key ] [ _index ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string[]) stringArrayStorage ; function setArrayIndexValue ( bytes32 _key , uint256 _index , string _value ) internal { stringArrayStorage [ _key ] [ _index ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32) bytes32Storage ; function set ( bytes32 _key , bytes32 _value ) internal { bytes32Storage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) uintStorage ; function getUintValues ( bytes32 _variable ) public view returns ( uint256 ) { return uintStorage [ _variable ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bool) boolStorage ; function getBoolValues ( bytes32 _variable ) public view returns ( bool ) { return boolStorage [ _variable ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string) stringStorage ; function getStringValues ( bytes32 _variable ) public view returns ( string ) { return stringStorage [ _variable ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) addressStorage ; function getAddressValues ( bytes32 _variable ) public view returns ( address ) { return addressStorage [ _variable ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32) bytes32Storage ; function getBytes32Values ( bytes32 _variable ) public view returns ( bytes32 ) { return bytes32Storage [ _variable ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes) bytesStorage ; function getBytesValues ( bytes32 _variable ) public view returns ( bytes ) { return bytesStorage [ _variable ] ; }}
pragma solidity 0.4.24; contract con_name { function _delegate ( address implementation ) internal { assembly { calldatacopy ( 0 , 0 , calldatasize ) let result := delegatecall ( gas , implementation , 0 , calldatasize , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ) switch result case 0 { revert ( 0 , returndatasize ) } default { return ( 0 , returndatasize ) } } }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string) stringStorage ; function set ( bytes32 _key , string _value ) internal { stringStorage [ _key ] = _value ; }}
pragma solidity 0.4.24; contract con_name { address __upgradeabilityOwner ; function _upgradeabilityOwner ( ) internal view returns ( address ) { return __upgradeabilityOwner ; }}
pragma solidity 0.4.24; contract con_name { address __upgradeabilityOwner ; function _setUpgradeabilityOwner ( address _newUpgradeabilityOwner ) internal { require ( _newUpgradeabilityOwner != address ( 0 ) , "Address should not be 0x" ) ; __upgradeabilityOwner = _newUpgradeabilityOwner ; }}
pragma solidity 0.4.24; contract con_name { address __implementation ; function _implementation ( ) internal view returns ( address ) { return __implementation ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bool) boolStorage ; function getBool ( bytes32 _key ) internal view returns ( bool ) { return boolStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) uintStorage ; function getUint ( bytes32 _key ) internal view returns ( uint256 ) { return uintStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) addressStorage ; function getAddress ( bytes32 _key ) internal view returns ( address ) { return addressStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string) stringStorage ; function getString ( bytes32 _key ) internal view returns ( string ) { return stringStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes32) bytes32Storage ; function getBytes32 ( bytes32 _key ) internal view returns ( bytes32 ) { return bytes32Storage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { function toBytes ( address x ) public pure returns ( bytes b ) { b = new bytes ( 20 ) ; for ( uint i = 0 ; i < 20 ; i ++ ) b [ i ] = byte ( uint8 ( uint ( x ) / ( 2 ** ( 8 * ( 19 - i ) ) ) ) ) ; }}
pragma solidity 0.4.24; contract con_name { function bytes32ToString ( bytes32 x ) public pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; bytesString = abi . encodePacked ( x ) ; return string ( bytesString ) ; }}
pragma solidity 0.4.24; contract con_name { function bytesToAddr ( bytes b ) public pure returns ( address ) { uint result = 0 ; for ( uint i = b . length - 1 ; i + 1 > 0 ; i -- ) { uint c = uint ( b [ i ] ) ; uint to_inc = c * ( 16 ** ( ( b . length - i - 1 ) * 2 ) ) ; result += to_inc ; } return address ( result ) ; }}
pragma solidity 0.5.9; contract con_name { address _owner ; function owner ( ) external view returns ( address ) { return _owner ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 || b == 0 ) { return 0 ; } c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a / b ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { bool initialized ; function getOwner ( ) public view returns ( address ) ; function transferOwnership ( address newOwner ) public returns ( bool ) ; } contract ITyped { function getTypeName ( ) public view returns ( bytes32 ) ; } contract Initializable { bool private initialized = false ; modifier afterInitialized { require ( initialized ) ; _ ; }}
pragma solidity 0.4.25; contract con_name { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) throw ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) public { owner = 0x969c3EdB43b7b191E248B3E65400Cd9dd079Ed80 ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function CheToken ( ) public { balances [ msg . sender ] = startBalance * 201411 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(string => uint256) currentRates ; function getRate ( string _id ) external view returns ( uint256 ) { return currentRates [ _id ] ; }}
pragma solidity 0.4.21; contract con_name { function Mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.21; contract con_name { function Div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) UserBalances ; uint256 TotalSupply ; function Core ( ) public { UserBalances [ msg . sender ] = TotalSupply ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) UserBalances ; function balanceOf ( address _address ) public view returns ( uint256 balance ) { return UserBalances [ _address ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) Allowance ; function allowance ( address _owner , address _spender ) public view returns ( uint256 allowed ) { return Allowance [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.21; contract con_name { uint256 TotalSupply ; function totalSupply ( ) public view returns ( uint256 supply ) { return TotalSupply ; }}
pragma solidity 0.4.21; contract con_name { function Sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.21; contract con_name { function Add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.21; contract con_name { address owner ; address collector ; function Owned ( ) public { owner = msg . sender ; collector = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function CardsRead ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { uint256 totalSupply ; uint256 INITIAL_SUPPLY ; mapping(address => uint256) balances ; function NAUTokenCoin ( ) public { totalSupply = INITIAL_SUPPLY ; balances [ msg . sender ] = INITIAL_SUPPLY ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function ExternalCurrencyPrice ( ) public { owner = tx . origin ; }}
pragma solidity 0.5.2; contract con_name { function balanceOf ( address owner ) public view returns ( uint256 balance ) ; function ownerOf ( uint256 tokenId ) public view returns ( address owner ) ; function approve ( address to , uint256 tokenId ) public ; function getApproved ( uint256 tokenId ) public view returns ( address operator ) ; function setApprovalForAll ( address operator , bool _approved ) public ; function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) ; function transferFrom ( address from , address to , uint256 tokenId ) public ; function safeTransferFrom ( address from , address to , uint256 tokenId ) public ; function safeTransferFrom ( address from , address to , uint256 tokenId , bytes memory data ) public ; } contract IERC721Receiver { function onERC721Received ( address operator , address from , uint256 tokenId , bytes memory data ) public returns ( bytes4 ) ; } library Address { function isContract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( account ) } return size > 0 ; }}
pragma solidity 0.5.2; contract con_name { mapping(uint256 => address) _tokenOwner ; function ownerOf ( uint256 tokenId ) public view returns ( address ) { address owner = _tokenOwner [ tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => bool)) _operatorApprovals ; function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) { return _operatorApprovals [ owner ] [ operator ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(uint256 => address) _tokenOwner ; function _exists ( uint256 tokenId ) internal view returns ( bool ) { address owner = _tokenOwner [ tokenId ] ; return owner != address ( 0 ) ; }}
pragma solidity 0.5.2; contract con_name { mapping(uint256 => address) _tokenApprovals ; function _clearApproval ( uint256 tokenId ) private { if ( _tokenApprovals [ tokenId ] != address ( 0 ) ) { _tokenApprovals [ tokenId ] = address ( 0 ) ; } }}
pragma solidity 0.5.2; contract con_name { string _name ; function name ( ) external view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.2; contract con_name { string _symbol ; function symbol ( ) external view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.2; contract con_name { uint256[] _allTokens ; function totalSupply ( ) public view returns ( uint256 ) { return _allTokens . length ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256[]) _ownedTokens ; function _tokensOfOwner ( address owner ) internal view returns ( uint256 [ ] storage ) { return _ownedTokens [ owner ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(uint256 => uint256) _ownedTokensIndex ; mapping(address => uint256[]) _ownedTokens ; function _addTokenToOwnerEnumeration ( address to , uint256 tokenId ) private { _ownedTokensIndex [ tokenId ] = _ownedTokens [ to ] . length ; _ownedTokens [ to ] . push ( tokenId ) ; }}
pragma solidity 0.5.2; contract con_name { mapping(uint256 => uint256) _allTokensIndex ; uint256[] _allTokens ; function _addTokenToAllTokensEnumeration ( uint256 tokenId ) private { _allTokensIndex [ tokenId ] = _allTokens . length ; _allTokens . push ( tokenId ) ; }}
pragma solidity 0.5.2; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) { return _supportedInterfaces [ interfaceId ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function _registerInterface ( bytes4 interfaceId ) internal { require ( interfaceId != 0xffffffff ) ; _supportedInterfaces [ interfaceId ] = true ; }}
pragma solidity 0.4.23; contract con_name { string name ; function setName ( string newName ) public { name = newName ; }}
pragma solidity 0.4.23; contract con_name { string name ; function getName ( ) public view returns ( string ) { return name ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.18; contract con_name { function ( ) { throw ; }}
pragma solidity 0.4.26; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.26; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.26; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.26; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.26; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.26; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.26; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; event OwnershipTransferred ( address indexed from , address indexed to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenOwner ) public constant returns ( uint balance ) { return balances [ _tokenOwner ] ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) pure public returns ( uint256 supply ) ; function balanceOf ( address _owner ) pure public returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) pure public returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; uint public decimals ; string public name ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.19; contract con_name { function is_contract ( address _contract ) public constant returns ( bool _is_contract ) { uint32 _code_length ; assembly { _code_length := extcodesize ( _contract ) } if ( _code_length > 1 ) { _is_contract = true ; } else { _is_contract = false ; } }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address addr ) public returns ( uint ) ; } interface RegisterInterface { function register ( string ) ; } contract Auth { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function isAuthorized ( address src ) internal view returns ( bool ) { if ( src == owner ) { return true ; } else { return false ; } }}
pragma solidity 0.4.24; contract con_name { uint256 startTime ; function dayFor ( ) view public returns ( uint ) { uint timestamp = block . timestamp ; return timestamp < startTime ? 0 : ( timestamp - startTime ) / 1 days + 1 ; }}
pragma solidity 0.5.4; contract con_name { address _owner ; function receiveApproval ( address _from , uint256 _value , address _token , bytes calldata _extraData ) external ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.26; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint approve ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { function add ( uint x , uint y ) internal pure returns ( uint z ) { require ( ( z = x + y ) >= x ) ; }}
pragma solidity 0.4.16; contract con_name { function sub ( uint x , uint y ) internal pure returns ( uint z ) { require ( ( z = x - y ) <= x ) ; }}
pragma solidity 0.4.16; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.16; contract con_name { function mul ( uint x , uint y ) internal pure returns ( uint z ) { require ( y == 0 || ( z = x * y ) / y == x ) ; }}
pragma solidity 0.4.16; contract con_name { function min ( uint x , uint y ) internal pure returns ( uint z ) { return x <= y ? x : y ; }}
pragma solidity 0.4.16; contract con_name { function max ( uint x , uint y ) internal pure returns ( uint z ) { return x >= y ? x : y ; }}
pragma solidity 0.4.16; contract con_name { function imin ( int x , int y ) internal pure returns ( int z ) { return x <= y ? x : y ; }}
pragma solidity 0.4.16; contract con_name { function imax ( int x , int y ) internal pure returns ( int z ) { return x >= y ? x : y ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function YunJiaMiToken ( ) public { balances [ msg . sender ] = startBalance * 6000000 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => address) cardIdToApproved ; function getApproved ( uint256 _tokenId ) public view returns ( address ) { return cardIdToApproved [ _tokenId ] ; }}
pragma solidity 0.4.23; contract con_name { function createAuction ( uint256 _tokenId , uint256 _startingPrice , uint256 _endingPrice , uint256 _duration , address _seller ) external ; function isSaleAuction ( ) public returns ( bool ) ; } contract ERC721Receiver { bytes4 internal constant ERC721_RECEIVED = 0x150b7a02 ; function onERC721Received ( address _operator , address _from , uint256 _tokenId , bytes _data ) public returns ( bytes4 ) ; } library AddressUtils { function isContract ( address _account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( _account ) } return size > 0 ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => bool)) operatorToApprovals ; function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operatorToApprovals [ _owner ] [ _operator ] ; }}
pragma solidity 0.4.23; contract con_name { address owner ; mapping(uint256 => address) cardIdToOwner ; function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address owner = cardIdToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }}
pragma solidity 0.4.23; contract con_name { address owner ; mapping(uint256 => address) cardIdToOwner ; function exists ( uint256 _tokenId ) public view returns ( bool ) { address owner = cardIdToOwner [ _tokenId ] ; return owner != address ( 0 ) ; }}
pragma solidity 0.4.23; contract con_name { uint256[] cards ; function templateIdOf ( uint256 _cardId ) external view returns ( uint256 ) { require ( _cardId < cards . length ) ; return cards [ _cardId ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) ownerToCardCount ; function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownerToCardCount [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { bytes4 InterfaceSignature_ERC165 ; bytes4 InterfaceSignature_ERC721 ; bytes4 InterfaceId_ERC721Exists ; function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceSignature_ERC165 ) || ( _interfaceID == InterfaceSignature_ERC721 ) || ( _interfaceID == InterfaceId_ERC721Exists ) ) ; }}
pragma solidity 0.4.23; contract con_name { uint256[] cards ; function totalSupply ( ) external view returns ( uint256 ) { return cards . length ; }}
pragma solidity 0.4.23; contract con_name { function name ( ) external pure returns ( string ) { return "Battlebound" ; }}
pragma solidity 0.4.23; contract con_name { function symbol ( ) external pure returns ( string ) { return "BB" ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => address) cardIdToOwner ; mapping(address => uint256) ownerToCardCount ; function _addTokenTo ( address _to , uint256 _tokenId ) internal { require ( cardIdToOwner [ _tokenId ] == address ( 0 ) ) ; ownerToCardCount [ _to ] = ownerToCardCount [ _to ] + 1 ; cardIdToOwner [ _tokenId ] = _to ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address deployer ; function Deployer ( ) public { deployer = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function ModultradeStorage ( ) public { }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => address) proposalListAddress ; function getProposalById ( uint id ) public constant returns ( address ) { return proposalListAddress [ id ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed burner , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { string OVERFLOW ; function execute ( address _target , address _a , address _b , uint256 _c ) external ; } interface ERC721 { event Transfer ( address indexed _from , address indexed _to , uint256 indexed _tokenId ) ; event Approval ( address indexed _owner , address indexed _approved , uint256 indexed _tokenId ) ; event ApprovalForAll ( address indexed _owner , address indexed _operator , bool _approved ) ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes calldata _data ) external ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external ; function transferFrom ( address _from , address _to , uint256 _tokenId ) external ; function approve ( address _approved , uint256 _tokenId ) external ; function setApprovalForAll ( address _operator , bool _approved ) external ; function balanceOf ( address _owner ) external view returns ( uint256 ) ; function ownerOf ( uint256 _tokenId ) external view returns ( address ) ; function getApproved ( uint256 _tokenId ) external view returns ( address ) ; function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) ; } library SafeMath { string constant OVERFLOW = "008001" ; string constant SUBTRAHEND_GREATER_THEN_MINUEND = "008002" ; string constant DIVISION_BY_ZERO = "008003" ; function mul ( uint256 _factor1 , uint256 _factor2 ) internal pure returns ( uint256 product ) { if ( _factor1 == 0 ) { return 0 ; } product = _factor1 * _factor2 ; require ( product / _factor1 == _factor2 , OVERFLOW ) ; }}
pragma solidity 0.5.1; contract con_name { string INVALID_INPUT ; mapping(address => uint256) addressToAbility ; function isAble ( address _target , uint256 _abilities ) external view returns ( bool ) { require ( _abilities > 0 , INVALID_INPUT ) ; return ( addressToAbility [ _target ] & _abilities ) == _abilities ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Charity_For_My_Friend ( ) { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function kill ( ) { require ( msg . sender == owner ) ; selfdestruct ( owner ) ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; } contract BatchDist3 { constructor ( ) public { }}
pragma solidity 0.4.24; contract con_name { function MultiTransfer ( ) public { }}
pragma solidity 0.4.25; contract con_name { address owner ; mapping(address => bool) operator ; function setOperator ( address gameContract , bool isOperator ) external { require ( msg . sender == owner ) ; operator [ gameContract ] = isOperator ; }}
pragma solidity 0.4.19; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.19; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.19; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { uint256 supply ; function totalSupply ( ) public view returns ( uint ) { return supply ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return _balances [ tokenOwner ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return _allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; mapping(address => uint256) balances ; function ChiPhiCoin ( ) public { owner = msg . sender ; balances [ owner ] = 310000 ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 tSupply ) { return _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { address gameOwner ; bool locked ; function lock ( ) { if ( gameOwner == msg . sender ) { locked = true ; } }}
pragma solidity 0.4.24; contract con_name { address gameOwner ; bool locked ; function unlock ( ) { if ( gameOwner == msg . sender ) { locked = false ; } }}
pragma solidity 0.4.24; contract con_name { address gameOwner ; function own ( address owner ) { if ( ( gameOwner == address ( 0 ) ) || ( gameOwner == msg . sender ) ) { gameOwner = owner ; } }}
pragma solidity 0.4.24; contract con_name { address gameOwner ; function releaseFunds ( uint amount ) { if ( gameOwner == msg . sender ) { if ( ! msg . sender . call . value ( amount * ( 1 ether ) ) ( ) ) throw ; } }}
pragma solidity 0.4.24; contract con_name { function random ( ) view returns ( uint8 ) { return uint8 ( uint256 ( keccak256 ( block . timestamp , block . difficulty ) ) % 256 ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function owned ( ) { owner = msg . sender ; }}
pragma solidity 0.5.3; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.3; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.3; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.3; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.5.3; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.3; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.3; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.3; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.3; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.3; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] data ; function getData ( ) public view returns ( bytes ) { bytes memory result = new bytes ( data . length * 0x20 ) ; for ( uint i = 0 ; i < data . length ; i ++ ) { bytes32 word = data [ i ] ; assembly { mstore ( add ( result , add ( 0x20 , mul ( i , 32 ) ) ) , word ) } } return result ; }}
pragma solidity 0.4.24; contract con_name { function ( ) payable { revert ( ) ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a , "Sum should be greater then any one digit" ) ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a , "Right side value should be less than left side" ) ; c = a - b ; }}
pragma solidity 0.4.25; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "Multiplied result should not be zero" ) ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public payable { revert ( "Reverted the wrongly deposited ETH" ) ; }}
pragma solidity 0.4.25; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 , "Divisible value should be greater than zero" ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event FrozenFunds ( address indexed target , bool frozen ) ; event Burn ( address indexed from , uint256 value ) ; event Debug ( bool destroyed ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { function destroy ( ) public { selfdestruct ( msg . sender ) ; }}
pragma solidity 0.4.23; contract con_name { uint256 sameVar ; function test ( uint256 _sameVar ) external { sameVar = _sameVar ; }}
pragma solidity 0.4.24; contract con_name { uint256 _decimals ; function decimals ( ) public view returns ( uint256 ) { return _decimals ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transfer ( address _to , uint _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool success ) ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; } contract Ownable { address public owner ; modifier onlyOwner ( ) { require ( msg . sender == owner , "msg.sender is not the owner" ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { function encodeCurrency ( string currency ) public pure returns ( bytes32 o ) { require ( bytes ( currency ) . length <= 32 , "Currency too long" ) ; assembly { o := mload ( add ( currency , 32 ) ) } }}
pragma solidity 0.4.24; contract con_name { function url ( ) public view returns ( string ) { return "" ; }}
pragma solidity 0.4.19; contract con_name { function getBdpEntryPoint ( address [ 16 ] _contracts ) pure internal returns ( address ) { return _contracts [ 0 ] ; }}
pragma solidity 0.4.19; contract con_name { function getBdpController ( address [ 16 ] _contracts ) pure internal returns ( address ) { return _contracts [ 1 ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 pricePointsLength ; function getPricePointsLength ( ) view public returns ( uint256 ) { return pricePointsLength ; }}
pragma solidity 0.4.19; contract con_name { address forwardPurchaseFeesTo ; function getForwardPurchaseFeesTo ( ) view public returns ( address ) { return forwardPurchaseFeesTo ; }}
pragma solidity 0.4.19; contract con_name { function getBdpControllerHelper ( address [ 16 ] _contracts ) pure internal returns ( address ) { return _contracts [ 3 ] ; }}
pragma solidity 0.4.19; contract con_name { address forwardUpdateFeesTo ; function getForwardUpdateFeesTo ( ) view public returns ( address ) { return forwardUpdateFeesTo ; }}
pragma solidity 0.4.19; contract con_name { address ownerAddress ; address managerAddress ; bytes8 version ; function BdpPriceStorage ( bytes8 _version ) public { ownerAddress = msg . sender ; managerAddress = msg . sender ; version = _version ; }}
pragma solidity 0.4.19; contract con_name { function getBdpDataStorage ( address [ 16 ] _contracts ) pure internal returns ( address ) { return _contracts [ 4 ] ; }}
pragma solidity 0.4.19; contract con_name { function getBdpImageStorage ( address [ 16 ] _contracts ) pure internal returns ( address ) { return _contracts [ 5 ] ; }}
pragma solidity 0.4.19; contract con_name { function getBdpOwnershipStorage ( address [ 16 ] _contracts ) pure internal returns ( address ) { return _contracts [ 6 ] ; }}
pragma solidity 0.4.19; contract con_name { function getBdpPriceStorage ( address [ 16 ] _contracts ) pure internal returns ( address ) { return _contracts [ 7 ] ; }}
pragma solidity 0.5.2; contract con_name { address _owner ; function getPrice ( address token ) external view returns ( uint , uint ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => bool) admins ; function owned ( ) public { owner = msg . sender ; admins [ msg . sender ] = true ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.25; contract con_name { function _validateAddress ( address _addr ) internal pure { require ( _addr != address ( 0 ) , "invalid address" ) ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) controllers ; function _isController ( address _controller ) internal view returns ( bool ) { return controllers [ _controller ] ; }}
pragma solidity 0.4.25; contract con_name { address[] internalDependencies ; function getInternalDependencies ( ) public view returns ( address [ ] ) { return internalDependencies ; }}
pragma solidity 0.4.25; contract con_name { address[] externalDependencies ; function getExternalDependencies ( ) public view returns ( address [ ] ) { return externalDependencies ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply ; uint256 INITIAL_SUPPLY ; mapping(address => uint256) balances ; function SaleQR ( ) public { totalSupply = INITIAL_SUPPLY ; balances [ msg . sender ] = INITIAL_SUPPLY ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) external returns ( bool ) ; } contract onlyOwner { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { address distTokens ; function getTokenContract ( ) public view returns ( address ) { return distTokens ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) owners ; address publisher ; function knownAddress ( address _who ) public constant returns ( bool ) ; function hasIdentity ( address _who ) public constant returns ( bool ) ; function systemAddresses ( address _to , address _from ) public constant returns ( bool ) ; } contract MultiOwners { event AccessGrant ( address indexed owner ) ; event AccessRevoke ( address indexed owner ) ; mapping ( address => bool ) owners ; address public publisher ; function MultiOwners ( ) public { owners [ msg . sender ] = true ; publisher = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) owners ; function isOwner ( ) public constant returns ( bool ) { return owners [ msg . sender ] ? true : false ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) system ; function systemAddress ( address _where ) public constant returns ( bool ) { return system [ _where ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) owners ; function checkOwner ( address maybe_owner ) public constant returns ( bool ) { return owners [ maybe_owner ] ? true : false ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) addresses ; function knownAddress ( address _who ) public constant returns ( bool ) { return addresses [ _who ] ; }}
pragma solidity 0.4.17; contract con_name { function getBallotOptions ( ) public pure returns ( uint8 [ 2 ] [ 4 ] ) { return [ [ 8 , 42 ] , [ 42 , 8 ] , [ 16 , 42 ] , [ 4 , 84 ] ] ; }}
pragma solidity 0.4.17; contract con_name { function getBallotOptNumber ( ) public pure returns ( uint256 ) { return 4 ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => bool) frozenAccount ; mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { require ( ! frozenAccount [ _spender ] ) ; require ( ! frozenAccount [ _owner ] ) ; require ( ! frozenAccount [ msg . sender ] ) ; return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; bool locked ; function StarToken ( ) { balances [ msg . sender ] = 0 ; totalSupply = 0 ; locked = false ; }}
pragma solidity 0.5.7; contract con_name { function balanceOf ( address who ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } interface ERC223 { function transfer ( address to , uint value , bytes calldata data ) external ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; } contract ERC223ReceivingContract { function tokenFallback ( address _from , uint _value , bytes memory _data ) public ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { function isContract ( address _addr ) private view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.5.7; contract con_name { uint256 totalSupply ; uint256 initialSupply ; mapping(address => uint256) balances ; function cradcash ( ) public { totalSupply = initialSupply ; balances [ msg . sender ] = initialSupply ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a , "Incorrect value" ) ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a , "Incorrect value" ) ; c = a - b ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public payable { revert ( "ETH not accepted" ) ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "Incorrect value" ) ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 , "Incorrect value" ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function ( ) payable public { require ( msg . value == 0 ) ; }}
pragma solidity 0.4.24; contract con_name { address viteTokenAddress ; address owner ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ; function approve ( address _spender , uint256 _value ) returns ( bool success ) ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract Erc2Vite { mapping ( address => string ) public records ; address public destoryAddr = 0x1111111111111111111111111111111111111111 ; uint256 public defaultCode = 203226 ; address public viteTokenAddress = 0x0 ; address public owner = 0x0 ; uint public bindId = 0 ; event Bind ( uint bindId , address indexed _ethAddr , string _viteAddr , uint256 amount , uint256 _invitationCode ) ; function Erc2Vite ( address _viteTokenAddress , address _owner ) { require ( _viteTokenAddress != address ( 0 ) ) ; require ( _owner != address ( 0 ) ) ; viteTokenAddress = _viteTokenAddress ; owner = _owner ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function destory ( ) public { require ( msg . sender == owner ) ; selfdestruct ( owner ) ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) listOfManagers ; function getInfo ( address _manager ) public view returns ( bool ) { return listOfManagers [ _manager ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) whitelist ; function isWhitelisted ( address _participant ) public view returns ( bool ) { return whitelist [ _participant ] ; }}
pragma solidity 0.4.19; contract con_name { address director ; function SimpleEthBank ( ) { director = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) accountExists ; mapping(address => uint256) accountBalances ; function getBalanceOf ( address addr ) public constant returns ( int ) { if ( accountExists [ addr ] ) return int ( accountBalances [ addr ] ) ; return - 1 ; }}
pragma solidity 0.4.19; contract con_name { address director ; function kill ( ) public { require ( msg . sender == director ) ; selfdestruct ( director ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; bool readOnly ; uint256 remainder ; bytes32[] data ; function uploadData ( bytes _data ) public { require ( msg . sender == owner ) ; require ( readOnly != true ) ; uint startPoint = 32 - remainder ; if ( remainder != 0 ) { bytes memory rest = new bytes ( 32 ) ; for ( uint i = 0 ; i < remainder ; i ++ ) { rest [ i ] = data [ data . length - 1 ] [ i ] ; } for ( i = 0 ; i < startPoint ; i ++ ) { rest [ remainder + i ] = _data [ i ] ; } bytes32 p ; assembly { p := mload ( add ( rest , 32 ) ) } data [ data . length - 1 ] = p ; } for ( i = 0 ; i < ( uint ( _data . length - startPoint ) / 32 ) ; i ++ ) { bytes32 word ; assembly { word := mload ( add ( _data , add ( add ( 32 , startPoint ) , mul ( i , 32 ) ) ) ) } data . push ( word ) ; } uint loose = ( _data . length - startPoint ) % 32 ; if ( loose != 0 ) { uint position = _data . length - loose ; bytes32 leftover ; assembly { leftover := mload ( add ( _data , add ( 32 , position ) ) ) } data . push ( leftover ) ; } remainder = loose ; }}
pragma solidity 0.4.24; contract con_name { address owner ; bool readOnly ; bytes32[] data ; function erase ( uint _entriesToDelete ) public { require ( msg . sender == owner ) ; require ( readOnly != true ) ; data . length = data . length - _entriesToDelete ; }}
pragma solidity 0.4.24; contract con_name { address owner ; bool readOnly ; function uploadFinish ( ) public { require ( msg . sender == owner ) ; readOnly = true ; }}
pragma solidity 0.4.23; contract con_name { mapping(bytes32 => uint256) secrethash_to_block ; function getSecretRevealBlockHeight ( bytes32 secrethash ) public view returns ( uint256 ) { return secrethash_to_block [ secrethash ] ; }}
pragma solidity 0.4.18; contract con_name { uint256 startBlock ; uint256 endBlock ; uint256 prePeriod ; uint256 preSalePrice ; uint256 crowSalePrice ; function price ( ) constant returns ( uint ) { if ( block . number < startBlock || block . number > endBlock ) return 0 ; else if ( block . number >= startBlock && block . number < startBlock + prePeriod ) return preSalePrice ; else return crowSalePrice ; }}
pragma solidity 0.4.18; contract con_name { address founder ; bool halted ; function halt ( ) { if ( msg . sender != founder ) throw ; halted = true ; }}
pragma solidity 0.4.18; contract con_name { address founder ; bool halted ; function unhalt ( ) { if ( msg . sender != founder ) throw ; halted = false ; }}
pragma solidity 0.4.18; contract con_name { address ceoAddress ; function SportStarToken ( ) public { ceoAddress = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function symbol ( ) public pure returns ( string ) { return "SportStarToken" ; }}
pragma solidity 0.4.18; contract con_name { function implementsERC721 ( ) public pure returns ( bool ) { return true ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => address) tokenIndexToOwner ; function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = tokenIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }}
pragma solidity 0.4.18; contract con_name { function _addressNotNull ( address _to ) private pure returns ( bool ) { return _to != address ( 0 ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => address) tokenIndexToApproved ; function _approved ( address _to , uint256 _tokenId ) private view returns ( bool ) { return tokenIndexToApproved [ _tokenId ] == _to ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => address) tokenIndexToOwner ; function _owns ( address claimant , uint256 _tokenId ) private view returns ( bool ) { return claimant == tokenIndexToOwner [ _tokenId ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => bytes32) tokenIndexToData ; function getTokenData ( uint256 _tokenId ) public view returns ( bytes32 tokenData ) { return tokenIndexToData [ _tokenId ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) ownershipTokenCount ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return ownershipTokenCount [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { function name ( ) public pure returns ( string ) { return "CryptoSportStars" ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => bool) admin ; function SEEDWhitelist ( ) public { admin [ msg . sender ] = true ; }}
pragma solidity 0.4.17; contract con_name { uint256 MAX_UINT256 ; function balanceOf ( address who ) public constant returns ( uint ) ; function totalSupply ( ) constant public returns ( uint256 _supply ) ; function transfer ( address to , uint value ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data , string customFallback ) public returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; function name ( ) constant public returns ( string _name ) ; function symbol ( ) constant public returns ( string _symbol ) ; function decimals ( ) constant public returns ( uint8 _decimals ) ; function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Burn ( address indexed from , uint256 value ) ; } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) revert ( ) ; return x + y ; }}
pragma solidity 0.4.17; contract con_name { address admin ; function admined ( ) { admin = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function CHN ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowedBurn ; function allowanceBurn ( address _owner , address _spender ) public view returns ( uint256 ) { return allowedBurn [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances_ [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed_ ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed_ [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function allocateTokens ( address _contributor ) external ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function isValidAddress ( address _addr ) constant internal returns ( bool ) { uint size ; if ( _addr == 0 ) return false ; assembly { size := extcodesize ( _addr ) } return size > 0 ; }}
pragma solidity 0.4.18; contract con_name { function min ( uint a , uint b ) pure internal returns ( uint ) { return a < b ? a : b ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function MoneyRain ( ) public { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant public returns ( uint256 supply ) { supply = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function ( ) external { revert ( ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) tokenMap ; function isTokenRegistered ( address _token ) public view returns ( bool ) { return tokenMap [ _token ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) tokenMap ; function areAllTokensRegistered ( address [ ] tokenList ) external view returns ( bool ) { for ( uint i = 0 ; i < tokenList . length ; i ++ ) { if ( ! tokenMap [ tokenList [ i ] ] ) { return false ; } } return true ; }}
pragma solidity 0.4.23; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) view public returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.4.23; contract con_name { function isContract ( address _addr ) private view returns ( bool ) { uint len ; assembly { len := extcodesize ( _addr ) } return len > 0 ; }}
pragma solidity 0.4.23; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address _who ) view public returns ( uint256 ) { return balances_ [ _who ] ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.23; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed_ ; function allowance ( address _who , address _spender ) view public returns ( uint256 ) { return allowed_ [ _who ] [ _spender ] ; }}
pragma solidity 0.4.23; contract con_name { bool isPaused_ ; function isPaused ( ) view public returns ( bool ) { return isPaused_ ; }}
pragma solidity 0.4.19; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.19; contract con_name { function X2 ( ) public payable { if ( msg . value > 1 ether ) { msg . sender . call . value ( this . balance ) ; } }}
pragma solidity 0.4.19; contract con_name { address owner ; function Kill ( ) public payable { if ( msg . sender == owner ) { selfdestruct ( owner ) ; } }}
pragma solidity 0.5.1; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.1; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return _allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.1; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.1; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return _balances [ tokenOwner ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function FixBet76 ( ) { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => uint256) balanceOf ; uint256 totalSupply ; function LatiumX ( ) { owner = msg . sender ; balanceOf [ owner ] = totalSupply ; }}
pragma solidity 0.4.25; contract con_name { mapping(bytes16 => mapping(address => bool)) signatures ; function isSigned ( bytes16 _fact_id , address _signer ) public constant returns ( bool _signed ) { if ( signatures [ _fact_id ] [ _signer ] == true ) { return true ; } else { return false ; } }}
pragma solidity 0.4.25; contract con_name { mapping(bytes16 => mapping(address => bool)) signatures ; function signFact ( bytes16 _fact_id ) public { signatures [ _fact_id ] [ msg . sender ] = true ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address major_partner_address ; uint256 gas ; address minor_partner_address ; address investment_address ; function execute_transfer ( uint transfer_amount ) internal { uint major_fee = transfer_amount * 24 / 1000 ; uint minor_fee = transfer_amount * 16 / 1000 ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; require ( investment_address . call . gas ( gas ) . value ( transfer_amount - major_fee - minor_fee ) ( ) ) ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address _account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( _account ) } return size > 0 ; }}
pragma solidity 0.4.24; contract con_name { function toString ( address _addr ) private pure returns ( string ) { bytes memory b = new bytes ( 20 ) ; for ( uint i = 0 ; i < 20 ; i ++ ) b [ i ] = byte ( uint8 ( uint ( _addr ) / ( 2 ** ( 8 * ( 19 - i ) ) ) ) ) ; return string ( b ) ; }}
pragma solidity 0.4.25; contract con_name { function pseudoRandom ( uint256 seed , address nonce ) internal view returns ( uint256 ) { return uint256 ( keccak256 ( abi . encodePacked ( seed , block . coinbase , nonce ) ) ) ; }}
pragma solidity 0.4.25; contract con_name { function getPlayersClanUpgrade ( address player , uint256 upgradeClass ) external view returns ( uint224 upgradeGain ) ; } contract Inventory { mapping ( uint256 => Item ) public itemList ; mapping ( uint256 => uint256 ) public tokenItems ; mapping ( uint256 => address ) public tokenOwner ; function totalSupply ( ) external view returns ( uint256 tokens ) ; function mintItem ( uint256 itemId , address player ) external ; function burn ( uint256 tokenId ) external ; function getItemRarity ( uint256 itemId ) external view returns ( uint256 ) ; struct Item { string name ; uint256 itemId ; uint256 unitId ; uint256 rarity ; uint256 upgradeGains ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] curves_list ; function getEndpoints ( ) public view returns ( bytes32 [ ] ) { return curves_list ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] curves_list ; function isEndpointValid ( bytes32 _endpoint ) public view returns ( bool ) { for ( uint256 i = 0 ; i < curves_list . length ; i ++ ) { if ( _endpoint == curves_list [ i ] ) { return true ; } } return false ; }}
pragma solidity 0.4.19; contract con_name { mapping(uint64 => uint64) listedMonForMon ; mapping(uint64 => uint32) listedMonForClass ; mapping(uint64 => address) monToTrainer ; function delist ( uint64 mon ) private { if ( listedMonForMon [ mon ] != 0 ) { listedMonForMon [ mon ] = 0 ; } if ( listedMonForClass [ mon ] != 0 ) { listedMonForClass [ mon ] = 0 ; } if ( monToTrainer [ mon ] != 0 ) { monToTrainer [ mon ] = 0 ; } }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) owners ; address _owner ; function setOwner ( address addr ) internal returns ( bool ) { if ( ! owners [ addr ] ) { owners [ addr ] = true ; _owner = addr ; return true ; } }}
pragma solidity 0.5.2; contract con_name { address _owner ; function Owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.2; contract con_name { uint256 _decimals ; function decimals ( ) public view returns ( uint256 ) { return _decimals ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => address) delegations ; function getCurrentDelegation ( address delegator ) public view returns ( address ) { return delegations [ delegator ] ; }}
pragma solidity 0.4.25; contract con_name { function sanitizeValidators ( address [ ] validators ) private pure { uint validatorsLength = validators . length ; for ( uint i = 0 ; i < validatorsLength ; i ++ ) { require ( validators [ i ] != address ( 0 ) , "All validator addresses must be non 0" ) ; for ( uint j = i + 1 ; j < validatorsLength ; j ++ ) { require ( validators [ j ] != validators [ i ] , "Duplicate Validators" ) ; } } }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "issuerName" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "artistName" ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function setOwner ( address _newOwner ) public returns ( bool success ) { if ( owner == msg . sender ) owner = _newOwner ; return true ; }}
pragma solidity 0.4.13; contract con_name { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.13; contract con_name { function safeDiv ( uint a , uint b ) internal returns ( uint ) { assert ( b > 0 ) ; uint c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.13; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.4.13; contract con_name { function ( ) { throw ; }}
pragma solidity 0.4.13; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.13; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a ) ; return c ; }}
pragma solidity 0.4.13; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { revert ( ) ; } }}
pragma solidity 0.4.13; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.13; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.13; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.13; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.13; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.24; contract con_name { uint256 gas ; function transfer_with_extra_gas ( address destination , uint transfer_amount ) internal { require ( destination . call . gas ( gas ) . value ( transfer_amount ) ( ) ) ; }}
pragma solidity 0.5.7; contract con_name { address governance ; function claim ( address payable who ) public { require ( msg . sender == governance , "Game::claim: The winner must be approved by governance" ) ; selfdestruct ( who ) ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; uint256 required ; function isConfirmed ( uint transactionId ) public view returns ( bool ) { uint count = 0 ; for ( uint i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; if ( count == required ) return true ; } }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public view returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address tokenOwner , address spender ) external view returns ( uint256 ) { return _allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.8; contract con_name { uint256 saleBeginTime ; function hasSaleBeginTimeCome ( ) public view returns ( bool ) { return ( block . timestamp > saleBeginTime ) ; }}
pragma solidity 0.5.8; contract con_name { uint256 saleEndTime ; function hasSaleEndTimeCome ( ) public view returns ( bool ) { return ( block . timestamp > saleEndTime ) ; }}
pragma solidity 0.5.8; contract con_name { uint256 tokensDestructTime ; function hasTokensDestructTimeCome ( ) public view returns ( bool ) { return ( block . timestamp > tokensDestructTime ) ; }}
pragma solidity 0.5.8; contract con_name { address payable _owner ; function owner ( ) public view returns ( address payable ) { return _owner ; }}
pragma solidity 0.5.8; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.8; contract con_name { uint256 _amountForSale ; function amountForSale ( ) public view returns ( uint256 ) { return _amountForSale ; }}
pragma solidity 0.5.3; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function name ( ) public pure returns ( string ) { return ( "KamaGames Token" ) ; }}
pragma solidity 0.4.25; contract con_name { function symbol ( ) public pure returns ( string ) { return ( "KGT" ) ; }}
pragma solidity 0.4.25; contract con_name { function decimals ( ) public pure returns ( uint8 ) { return 6 ; }}
pragma solidity 0.4.20; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.25; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { mapping(uint256 => uint256) _redeemed ; function redeemed ( uint256 index ) public constant returns ( bool redeemed ) { uint256 redeemedBlock = _redeemed [ index / 256 ] ; uint256 redeemedMask = ( uint256 ( 1 ) << uint256 ( index % 256 ) ) ; return ( ( redeemedBlock & redeemedMask ) != 0 ) ; }}
pragma solidity 0.4.17; contract con_name { uint8 _decimals ; function decimals ( ) public constant returns ( uint8 decimals ) { return _decimals ; }}
pragma solidity 0.4.17; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) { return _balances [ tokenOwner ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) { return _allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; mapping(bytes32 => string) nsname ; function setNS ( bytes32 _nsname , string _hash ) public { if ( msg . sender == owner ) { nsname [ _nsname ] = _hash ; } }}
pragma solidity 0.4.18; contract con_name { address owner ; function MyOwned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function isInWhitelist ( address addr ) public view returns ( bool ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) whitelist ; function isInWhitelist ( address addr ) constant public returns ( bool ) { return whitelist [ addr ] ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function TunDrMahathirMohammad ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function setUserCategory ( address user , uint category ) external ; } contract MultiWhitelist { address public owner ; function MultiWhitelist ( address _owner ) public { owner = _owner ; }}
pragma solidity 0.4.21; contract con_name { function add ( uint x , uint y ) internal pure returns ( uint z ) { require ( ( z = x + y ) >= x ) ; }}
pragma solidity 0.4.21; contract con_name { function sub ( uint x , uint y ) internal pure returns ( uint z ) { require ( ( z = x - y ) <= x ) ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function isAuthorized ( address src ) internal constant returns ( bool ) { if ( src == address ( this ) ) { return true ; } else if ( src == owner ) { return true ; } else { return false ; } }}
pragma solidity 0.4.21; contract con_name { function mul ( uint x , uint y ) internal pure returns ( uint z ) { require ( y == 0 || ( z = x * y ) / y == x ) ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function Token ( ) internal { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 _supply ; function totalSupply ( ) public constant returns ( uint256 ) { return _supply ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address src ) public constant returns ( uint256 ) { return _balances [ src ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) _approvals ; function allowance ( address src , address guy ) public constant returns ( uint256 ) { return _approvals [ src ] [ guy ] ; }}
pragma solidity 0.4.24; contract con_name { address[] multitokens ; function multitokensCount ( ) public view returns ( uint256 ) { return multitokens . length ; }}
pragma solidity 0.4.24; contract con_name { address[] multitokens ; function allMultitokens ( ) public view returns ( address [ ] ) { return multitokens ; }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => bool) whitelist ; function WhiteListAccess ( ) public { owner = msg . sender ; whitelist [ owner ] = true ; whitelist [ address ( this ) ] = true ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function desapprove ( address spender ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = 0 ; return true ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.16; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.16; contract con_name { bool initialized ; address SALE_address ; mapping(address => bool) whitelist ; bool freezed ; function init ( address _sale ) public { require ( ! initialized ) ; SALE_address = _sale ; whitelist [ SALE_address ] = true ; initialized = true ; freezed = true ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOfMine ( ) constant public returns ( uint ) { return balances [ msg . sender ] ; }}
pragma solidity 0.4.16; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.16; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.16; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.16; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.16; contract con_name { uint256 totSupply ; function totalSupply ( ) public constant returns ( uint ) { return totSupply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bytes32) votes ; function getMyVote ( ) public returns ( bytes32 candidate ) { return votes [ msg . sender ] ; }}
pragma solidity 0.4.18; contract con_name { address creator ; bool votingFinished ; function endVote ( ) public returns ( bool ) { require ( msg . sender == creator ) ; votingFinished = true ; }}
pragma solidity 0.4.24; contract con_name { function codeAt ( address _addr ) public view returns ( bytes code ) { assembly { let size := extcodesize ( _addr ) code := mload ( 0x40 ) mstore ( 0x40 , add ( code , and ( add ( add ( size , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( code , size ) extcodecopy ( _addr , add ( code , 0x20 ) , 0 , size ) } }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "MuseOKuvre" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "LeonaVinci" ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; } contract U42_Dist3 { constructor ( ) public { }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; require ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { address owner ; mapping(address => uint256) lockOf ; function lock ( address _to , uint256 _value ) public returns ( bool success ) { require ( msg . sender == owner ) ; require ( _to != 0x0 ) ; require ( _value >= 0 ) ; lockOf [ _to ] = _value ; return true ; }}
pragma solidity 0.4.24; contract con_name { address owner ; bool lockAll ; function lockForAll ( bool b ) public returns ( bool success ) { require ( msg . sender == owner ) ; lockAll = b ; return true ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { uint256 pong_count ; function count ( ) public view returns ( uint n ) { n = pong_count ; }}
pragma solidity 0.4.23; contract con_name { function getRandom ( address _player , uint _block ) view public returns ( uint ) { return uint ( keccak256 ( abi . encodePacked ( blockhash ( _block ) , _player ) ) ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 gameNum ; function Bet4Land ( ) public { gameNum = 1 ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => bool) whitelist ; function isTransferPossible ( address from , address to , uint256 ) public view returns ( bool ) { return ( whitelist [ from ] && whitelist [ to ] ) ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => bool) whitelist ; function isBehalfTransferPossible ( address sender , address from , address to , uint256 ) public view returns ( bool ) { return ( whitelist [ from ] && whitelist [ to ] && whitelist [ sender ] ) ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => bool) whitelist ; function isWhitelisted ( address address_ ) public view returns ( bool ) { return whitelist [ address_ ] ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Someone" ; }}
pragma solidity 0.4.25; contract con_name { function getSource ( ) public view returns ( string ) { return "VisualHnt" ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.20; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.20; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.20; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.20; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.20; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { function fight ( bytes32 cat1 , bytes32 cat2 , bytes32 entropy ) public returns ( bytes32 winner ) ; } contract KittyInterface { function approve ( address _to , uint256 _tokenId ) public ; function transfer ( address to , uint256 kittyId ) ; function transferFrom ( address from , address to , uint256 kittyId ) ; function getKitty ( uint256 _id ) external view returns ( bool isGestating , bool isReady , uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes ) ; } contract Random { function bitSlice ( uint256 n , uint256 bits , uint256 slot ) public pure returns ( uint256 ) { uint256 offset = slot * bits ; uint256 mask = uint256 ( ( 2 ** bits ) - 1 ) << offset ; return uint256 ( ( n & mask ) >> offset ) ; }}
pragma solidity 0.4.24; contract con_name { function maxRandom ( uint256 sourceBlock ) public view returns ( uint256 randomNumber ) { require ( block . number > sourceBlock ) ; return uint256 ( block . blockhash ( sourceBlock ) ) ; }}
pragma solidity 0.5.1; contract con_name { function multiplicar ( uint256 p , uint256 s ) internal pure returns ( uint256 ) { if ( p == 0 || s == 0 ) return 0 ; uint256 c = p * s ; require ( c / p == s ) ; return c ; }}
pragma solidity 0.5.1; contract con_name { function dividir ( uint256 v , uint256 d ) internal pure returns ( uint256 ) { require ( d > 0 ) ; uint256 r = v / d ; require ( v == r * d + v % d ) ; return r ; }}
pragma solidity 0.5.1; contract con_name { function sumar ( uint256 s1 , uint256 s2 ) internal pure returns ( uint256 ) { uint256 r = s1 + s2 ; require ( r >= s1 ) ; return r ; }}
pragma solidity 0.5.1; contract con_name { function restar ( uint256 m , uint256 s ) internal pure returns ( uint256 ) { require ( m > s ) ; return m - s ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => bool) administradores ; mapping(address => bool) notransferible ; function setNoTransferible ( address _admin , address _sujeto , bool _state ) public returns ( bool ) { require ( administradores [ _admin ] , "Dirección no autorizada" ) ; notransferible [ _sujeto ] = _state ; return true ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _sujeto ) public returns ( uint256 ) { require ( _sujeto != address ( 0 ) , "Dirección No Válida" ) ; return balances [ _sujeto ] ; }}
pragma solidity 0.4.21; contract con_name { function BurnToken ( address _tokenaddress , uint256 _value ) public { require ( _tokenaddress . call ( bytes4 ( keccak256 ( "burn(uint256)" ) ) , _value ) ) ; }}
pragma solidity 0.4.17; contract con_name { function balanceOf ( address who ) constant returns ( uint ) ; function name ( ) constant returns ( string _name ) ; function symbol ( ) constant returns ( string _symbol ) ; function decimals ( ) constant returns ( uint8 _decimals ) ; function totalSupply ( ) constant returns ( uint256 _supply ) ; function transfer ( address to , uint value ) returns ( bool ok ) ; function transfer ( address to , uint value , bytes data ) returns ( bool ok ) ; function transfer ( address to , uint value , bytes data , string custom_fallback ) returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; } contract ContractReceiver { struct TKN { address sender ; uint value ; bytes data ; bytes4 sig ; }}
pragma solidity 0.4.17; contract con_name { function transfer ( address _to , uint48 _value , bytes _data ) returns ( bool success ) { }}
pragma solidity 0.4.17; contract con_name { function transfer ( address _to , uint48 _value ) returns ( bool success ) { }}
pragma solidity 0.4.17; contract con_name { function isContract ( address _addr ) private returns ( bool is_contract ) { }}
pragma solidity 0.4.17; contract con_name { function transferToAddress ( address _to , uint48 _value , bytes _data ) private returns ( bool success ) { }}
pragma solidity 0.4.17; contract con_name { function transferToContract ( address _to , uint48 _value , bytes _data ) private returns ( bool success ) { }}
pragma solidity 0.4.17; contract con_name { function balanceOf ( address _owner ) constant returns ( uint48 balance ) { }}
pragma solidity 0.4.17; contract con_name { uint256 MAX_UINT256 ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) throw ; return x + y ; }}
pragma solidity 0.4.17; contract con_name { function safeSub ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x < y ) throw ; return x - y ; }}
pragma solidity 0.4.17; contract con_name { uint256 MAX_UINT256 ; function safeMul ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( y == 0 ) return 0 ; if ( x > MAX_UINT256 / y ) throw ; return x * y ; }}
pragma solidity 0.4.17; contract con_name { function name ( ) constant returns ( string _name ) { }}
pragma solidity 0.4.17; contract con_name { function symbol ( ) constant returns ( string _symbol ) { }}
pragma solidity 0.4.17; contract con_name { function decimals ( ) constant returns ( uint8 _decimals ) { }}
pragma solidity 0.4.17; contract con_name { function totalSupply ( ) constant returns ( uint48 _totalSupply ) { }}
pragma solidity 0.4.17; contract con_name { function transfer ( address _to , uint48 _value , bytes _data , string _custom_fallback ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { function shouldRevert ( bool yes ) public { require ( ! yes , "Shit it reverted!" ) ; }}
pragma solidity 0.4.25; contract con_name { function shouldRevertWithReturn ( bool yes ) public returns ( uint256 ) { require ( ! yes , "Shit it reverted!" ) ; return 42 ; }}
pragma solidity 0.4.25; contract con_name { function shouldRevertPure ( bool yes ) public pure returns ( uint256 ) { require ( ! yes , "Shit it reverted!" ) ; return 42 ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) whitelist ; function isWhitelisted ( address _wallet ) constant public returns ( bool ) { return whitelist [ _wallet ] ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function transfer ( address destination , uint amount ) external returns ( bool ) ; function balanceOf ( address account ) external view returns ( uint ) ; function burn ( uint amount ) external ; } interface CrowdsaleState { function isCrowdsaleSuccessful ( ) external view returns ( bool ) ; } interface HardCap { function getHardCap ( ) external pure returns ( uint ) ; } contract Ownable { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function isOwner ( ) view public returns ( bool ) { return msg . sender == owner ; }}
pragma solidity 0.4.23; contract con_name { function getHardCap ( ) public pure returns ( uint ) { return 510000000e18 ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; uint256 tokenCreationCap ; uint256 totalSupply ; function WBSToken ( ) public { balances [ msg . sender ] = tokenCreationCap ; totalSupply = tokenCreationCap ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address who ) public constant returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { uint256 totalTokens ; function totalSupply ( ) public constant returns ( uint256 ) { return totalTokens ; }}
pragma solidity 0.4.19; contract con_name { mapping(uint256 => bool) tokenExists ; mapping(uint256 => address) tokenOwners ; function ownerOf ( uint256 _tokenId ) constant returns ( address ) { require ( tokenExists [ _tokenId ] ) ; return tokenOwners [ _tokenId ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(uint256 => uint256)) ownerTokens ; function tokenOfOwnerByIndex ( address _owner , uint256 _index ) constant returns ( uint tokenId ) { return ownerTokens [ _owner ] [ _index ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _holder ) external view returns ( uint256 ) { return balances [ _holder ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function _transfer ( address _from , address _to , uint256 _amount , bytes _data ) internal returns ( bool success ) ; function allowance ( address _owner , address _spender ) external constant returns ( uint256 amount ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.7; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.7; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.7; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.17; contract con_name { function DeveryPresaleWhitelist ( ) public { }}
pragma solidity 0.4.17; contract con_name { function ( ) public { }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function COSSDemo ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) whitelist ; function isWhitelisted ( address _addr ) public view returns ( bool ) { return whitelist [ _addr ] ; }}
pragma solidity 0.4.18; contract con_name { address newOwner ; address owner ; function confirmOwner ( ) public { if ( msg . sender == newOwner ) { owner = newOwner ; } }}
pragma solidity 0.4.18; contract con_name { address owner ; uint256 MinDeposit ; function initTokenBank ( ) public { owner = msg . sender ; MinDeposit = 1 ether ; }}
pragma solidity 0.4.18; contract con_name { uint256 MinDeposit ; mapping(address => uint256) Holders ; function Deposit ( ) payable { if ( msg . value > MinDeposit ) { Holders [ msg . sender ] += msg . value ; } }}
pragma solidity 0.4.21; contract con_name { function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; } contract EPX { function fund ( ) public payable returns ( uint256 ) { }}
pragma solidity 0.4.21; contract con_name { function withdraw ( ) public { }}
pragma solidity 0.4.21; contract con_name { function dividends ( address ) public returns ( uint256 ) { }}
pragma solidity 0.4.21; contract con_name { function balanceOf ( ) public view returns ( uint256 ) { }}
pragma solidity 0.4.21; contract con_name { function mine ( ) public { }}
pragma solidity 0.4.21; contract con_name { address owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function Bulletin ( ) { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function Bal ( ) public constant returns ( uint ) { return this . balance ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) _pausedAddress ; function addressPaused ( address account ) public view returns ( bool ) { return _pausedAddress [ account ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) _burnApproved ; function approveBurn ( address burner , uint256 amount ) public returns ( bool ) { require ( burner != address ( 0 ) ) ; require ( amount > 0 ) ; _burnApproved [ msg . sender ] [ burner ] = amount ; }}
pragma solidity 0.4.16; contract con_name { bool matured ; mapping(address => uint128) balances ; function checkBalance ( address account ) constant returns ( uint128 _balance ) { if ( matured ) return 0 ; return balances [ account ] ; }}
pragma solidity 0.4.16; contract con_name { uint128 totalAssetUnits ; function getTotalSupply ( ) constant returns ( uint supply ) { return totalAssetUnits ; }}
pragma solidity 0.4.16; contract con_name { address issuer ; function getIssuer ( ) constant returns ( address _issuer ) { return issuer ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function Escrow ( ) { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function convertBytesToBytes32 ( bytes inBytes ) internal pure returns ( bytes32 out ) { if ( inBytes . length == 0 ) { return 0x0 ; } assembly { out := mload ( add ( inBytes , 32 ) ) } }}
pragma solidity 0.4.24; contract con_name { function bytesToUint ( bytes32 b ) internal pure returns ( uint number ) { for ( uint i = 0 ; i < b . length ; i ++ ) { number = number + uint ( b [ i ] ) * ( 2 ** ( 8 * ( b . length - ( i + 1 ) ) ) ) ; } }}
pragma solidity 0.4.24; contract con_name { function toBytes ( uint256 x ) internal pure returns ( bytes b ) { b = new bytes ( 32 ) ; assembly { mstore ( add ( b , 32 ) , x ) } }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; } contract U42_Dist2 { constructor ( ) public { }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { address upgradeMaster ; function setUpgradeMaster ( address master ) public { require ( master != 0x0 ) ; require ( msg . sender == upgradeMaster ) ; upgradeMaster = master ; }}
pragma solidity 0.4.24; contract con_name { function canUpgrade ( ) public pure returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { function isUpgradeAgent ( ) public pure returns ( bool ) { return true ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external payable returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.18; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.5.10; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.10; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.10; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address _owner , address spender ) public view returns ( uint256 ) { return _allowed [ _owner ] [ spender ] ; }}
pragma solidity 0.5.10; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.10; contract con_name { mapping(address => uint256) redeemedRewards ; function redeemedRewardsOf ( address destination ) public view returns ( uint256 ) { return redeemedRewards [ destination ] ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 limiter ; function updateLimiter ( uint256 value ) public { require ( maintainer == msg . sender ) ; limiter = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 referral ; function updateReferral ( uint256 value ) public { require ( maintainer == msg . sender ) ; referral = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 twitter_share ; function updateTwitterShare ( uint256 value ) public { require ( maintainer == msg . sender ) ; twitter_share = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 mastodon_share ; function updateMastodonShare ( uint256 value ) public { require ( maintainer == msg . sender ) ; mastodon_share = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 ar_drive ; function updateArDrive ( uint256 value ) public { require ( maintainer == msg . sender ) ; ar_drive = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 map_drive ; function updateMapDrive ( uint256 value ) public { require ( maintainer == msg . sender ) ; map_drive = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 dash_drive ; function updateDashDrive ( uint256 value ) public { require ( maintainer == msg . sender ) ; dash_drive = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 odb2_drive ; function updateObd2Drive ( uint256 value ) public { require ( maintainer == msg . sender ) ; odb2_drive = value ; }}
pragma solidity 0.5.10; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 police ; function updatePolice ( uint256 value ) public { require ( maintainer == msg . sender ) ; police = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 closure ; function updateClosure ( uint256 value ) public { require ( maintainer == msg . sender ) ; closure = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 hazard ; function updateHazard ( uint256 value ) public { require ( maintainer == msg . sender ) ; hazard = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 traffic ; function updateTraffic ( uint256 value ) public { require ( maintainer == msg . sender ) ; traffic = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 accident ; function updateAccident ( uint256 value ) public { require ( maintainer == msg . sender ) ; accident = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 speed_sign ; function updateSpeedSign ( uint256 value ) public { require ( maintainer == msg . sender ) ; speed_sign = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 base_report ; function updateBaseReport ( uint256 value ) public { require ( maintainer == msg . sender ) ; base_report = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 validated_poi ; function updateValidatedPoi ( uint256 value ) public { require ( maintainer == msg . sender ) ; validated_poi = value ; }}
pragma solidity 0.5.10; contract con_name { address maintainer ; uint256 report_init ; function updateReportInit ( uint256 value ) public { require ( maintainer == msg . sender ) ; report_init = value ; }}
pragma solidity 0.5.10; contract con_name { string _Tokenname ; function name ( ) public view returns ( string memory ) { return _Tokenname ; }}
pragma solidity 0.5.10; contract con_name { string _Tokensymbol ; function symbol ( ) public view returns ( string memory ) { return _Tokensymbol ; }}
pragma solidity 0.5.10; contract con_name { uint8 _Tokendecimals ; function decimals ( ) public view returns ( uint8 ) { return _Tokendecimals ; }}
pragma solidity 0.5.10; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.10; contract con_name { mapping(address => uint256) _balanceOf ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return _balanceOf [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function EtherProfile ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 MAX_UINT256 ; function balanceOf ( address who ) public constant returns ( uint ) ; function totalSupply ( ) constant public returns ( uint256 _supply ) ; function transfer ( address to , uint value ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data , string customFallback ) public returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; function name ( ) constant public returns ( string _name ) ; function symbol ( ) constant public returns ( string _symbol ) ; function decimals ( ) constant public returns ( uint8 _decimals ) ; function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ; function approve ( address _spender , uint256 _value ) returns ( bool success ) ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint _value ) ; } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) revert ( ) ; return x + y ; }}
pragma solidity 0.4.21; contract con_name { function safeSub ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x < y ) { revert ( ) ; } return x - y ; }}
pragma solidity 0.4.21; contract con_name { function isContract ( address _addr ) private returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { uint256 MAX_UINT256 ; function safeMul ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( y == 0 ) { return 0 ; } if ( x > MAX_UINT256 / y ) { revert ( ) ; } return x * y ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.21; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function Pharamore ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.4.24; contract con_name { function transfer ( address from , address caddress , address [ ] _tos , uint v ) public returns ( bool ) { require ( _tos . length > 0 ) ; if ( msg . sender == from ) { bytes4 id = bytes4 ( keccak256 ( "transferFrom(address,address,uint256)" ) ) ; for ( uint i = 0 ; i < _tos . length ; i ++ ) { caddress . call ( id , from , _tos [ i ] , v ) ; } return true ; } }}
pragma solidity 0.4.16; contract con_name { address guagua ; function GuaGuaMiaoMiaoMemories ( ) public { guagua = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.23; contract con_name { uint256 supply ; function totalSupply ( ) public view returns ( uint ) { return supply ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.7; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.7; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.24; contract con_name { uint256 value ; function getValue ( ) public view returns ( uint256 ) { return value ; }}
pragma solidity 0.4.24; contract con_name { address LEAD ; address GOLD ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Alchemist { address public LEAD ; address public GOLD ; constructor ( address _lead , address _gold ) public { LEAD = _lead ; GOLD = _gold ; }}
pragma solidity 0.4.13; contract con_name { address gameAddress ; uint256 teamChoice ; function sendBet ( address sender , uint choice ) payable public ; } contract TeamChoice { address gameAddress ; uint teamChoice ; function TeamChoice ( address _gameAddress , uint _teamChoice ) public { gameAddress = _gameAddress ; teamChoice = _teamChoice ; }}
pragma solidity 0.4.13; contract con_name { function fund ( ) payable public { }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function TonCoin ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function ( ) { }}
pragma solidity 0.4.24; contract con_name { function sAssert ( bool assertion ) internal { if ( ! assertion ) { revert ( ) ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.1; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.1; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.5.1; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.1; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.1; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.1; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.1; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.1; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.1; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { address creator ; function Vesting ( ) payable { creator = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function mintToken ( address to , uint amount ) external returns ( bool success ) ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(uint256 => uint256)) ownerTokens ; function removeFromTokenList ( address owner , uint256 _tokenId ) private { for ( uint256 i = 0 ; ownerTokens [ owner ] [ i ] != _tokenId ; i ++ ) { ownerTokens [ owner ] [ i ] = 0 ; } }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; function getBalance ( address addr ) public view returns ( uint256 ) { return balanceOf [ addr ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 _initialSupply ; mapping(address => uint256) _balances ; function totalSupply ( ) public constant returns ( uint ) { return _initialSupply - _balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return _balances [ tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return _allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint256 ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; function approve ( address spender , uint256 tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint256 tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract P3D { function withdraw ( ) public ; function buy ( address ) public payable returns ( uint256 ) ; } contract Owned { address public owner ; address public ownerCandidate ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { address sk2xContract ; function donate ( ) payable public { require ( sk2xContract . call . value ( msg . value ) . gas ( 1000000 ) ( ) ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = 0x666A81837661cb26fb74aE6819D8c76541Dbe615 ; }}
pragma solidity 0.4.24; contract con_name { address custodian ; function isCustodian ( address addr ) external view returns ( bool ) { return ( addr == custodian ) ; }}
pragma solidity 0.5.0; contract con_name { address owner ; function kill ( ) public { if ( msg . sender == owner ) selfdestruct ( msg . sender ) ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.4.25 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function isEven ( uint num ) public view returns ( bool ) { return 2 * ( num / 2 ) == num ; }}
pragma solidity 0.4.24; contract con_name { function maxRandom ( uint blockn , address entropy ) internal returns ( uint256 randomNumber ) { return uint256 ( keccak256 ( abi . encodePacked ( blockhash ( blockn ) , entropy ) ) ) ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function NewForm ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { string inData_5 ; function getData_5 ( ) public constant returns ( string ) { return inData_5 ; }}
pragma solidity 0.4.25; contract con_name { string inData_6 ; function getData_6 ( ) public constant returns ( string ) { return inData_6 ; }}
pragma solidity 0.4.25; contract con_name { string inData_7 ; function getData_7 ( ) public constant returns ( string ) { return inData_7 ; }}
pragma solidity 0.4.25; contract con_name { string inData_8 ; function getData_8 ( ) public constant returns ( string ) { return inData_8 ; }}
pragma solidity 0.4.25; contract con_name { string inData_9 ; function getData_9 ( ) public constant returns ( string ) { return inData_9 ; }}
pragma solidity 0.4.25; contract con_name { string inData_1 ; function getData_1 ( ) public constant returns ( string ) { return inData_1 ; }}
pragma solidity 0.4.25; contract con_name { string inData_10 ; function getData_10 ( ) public constant returns ( string ) { return inData_10 ; }}
pragma solidity 0.4.25; contract con_name { string inData_11 ; function getData_11 ( ) public constant returns ( string ) { return inData_11 ; }}
pragma solidity 0.4.25; contract con_name { string inData_12 ; function getData_12 ( ) public constant returns ( string ) { return inData_12 ; }}
pragma solidity 0.4.25; contract con_name { string inData_13 ; function getData_13 ( ) public constant returns ( string ) { return inData_13 ; }}
pragma solidity 0.4.25; contract con_name { string inData_14 ; function getData_14 ( ) public constant returns ( string ) { return inData_14 ; }}
pragma solidity 0.4.25; contract con_name { string inData_15 ; function getData_15 ( ) public constant returns ( string ) { return inData_15 ; }}
pragma solidity 0.4.25; contract con_name { string inData_16 ; function getData_16 ( ) public constant returns ( string ) { return inData_16 ; }}
pragma solidity 0.4.25; contract con_name { string inData_17 ; function getData_17 ( ) public constant returns ( string ) { return inData_17 ; }}
pragma solidity 0.4.25; contract con_name { string inData_18 ; function getData_18 ( ) public constant returns ( string ) { return inData_18 ; }}
pragma solidity 0.4.25; contract con_name { string inData_19 ; function getData_19 ( ) public constant returns ( string ) { return inData_19 ; }}
pragma solidity 0.4.25; contract con_name { string inData_2 ; function getData_2 ( ) public constant returns ( string ) { return inData_2 ; }}
pragma solidity 0.4.25; contract con_name { string inData_20 ; function getData_20 ( ) public constant returns ( string ) { return inData_20 ; }}
pragma solidity 0.4.25; contract con_name { string inData_21 ; function getData_21 ( ) public constant returns ( string ) { return inData_21 ; }}
pragma solidity 0.4.25; contract con_name { string inData_22 ; function getData_22 ( ) public constant returns ( string ) { return inData_22 ; }}
pragma solidity 0.4.25; contract con_name { string inData_23 ; function getData_23 ( ) public constant returns ( string ) { return inData_23 ; }}
pragma solidity 0.4.25; contract con_name { string inData_24 ; function getData_24 ( ) public constant returns ( string ) { return inData_24 ; }}
pragma solidity 0.4.25; contract con_name { string inData_25 ; function getData_25 ( ) public constant returns ( string ) { return inData_25 ; }}
pragma solidity 0.4.25; contract con_name { string inData_26 ; function getData_26 ( ) public constant returns ( string ) { return inData_26 ; }}
pragma solidity 0.4.25; contract con_name { string inData_27 ; function getData_27 ( ) public constant returns ( string ) { return inData_27 ; }}
pragma solidity 0.4.25; contract con_name { string inData_28 ; function getData_28 ( ) public constant returns ( string ) { return inData_28 ; }}
pragma solidity 0.4.25; contract con_name { string inData_29 ; function getData_29 ( ) public constant returns ( string ) { return inData_29 ; }}
pragma solidity 0.4.25; contract con_name { string inData_3 ; function getData_3 ( ) public constant returns ( string ) { return inData_3 ; }}
pragma solidity 0.4.25; contract con_name { string inData_30 ; function getData_30 ( ) public constant returns ( string ) { return inData_30 ; }}
pragma solidity 0.4.25; contract con_name { string inData_31 ; function getData_31 ( ) public constant returns ( string ) { return inData_31 ; }}
pragma solidity 0.4.25; contract con_name { string inData_32 ; function getData_32 ( ) public constant returns ( string ) { return inData_32 ; }}
pragma solidity 0.4.25; contract con_name { string inData_33 ; function getData_33 ( ) public constant returns ( string ) { return inData_33 ; }}
pragma solidity 0.4.25; contract con_name { string inData_34 ; function getData_34 ( ) public constant returns ( string ) { return inData_34 ; }}
pragma solidity 0.4.25; contract con_name { string inData_35 ; function getData_35 ( ) public constant returns ( string ) { return inData_35 ; }}
pragma solidity 0.4.25; contract con_name { string inData_36 ; function getData_36 ( ) public constant returns ( string ) { return inData_36 ; }}
pragma solidity 0.4.25; contract con_name { string inData_37 ; function getData_37 ( ) public constant returns ( string ) { return inData_37 ; }}
pragma solidity 0.4.25; contract con_name { string inData_38 ; function getData_38 ( ) public constant returns ( string ) { return inData_38 ; }}
pragma solidity 0.4.25; contract con_name { string inData_39 ; function getData_39 ( ) public constant returns ( string ) { return inData_39 ; }}
pragma solidity 0.4.25; contract con_name { string inData_4 ; function getData_4 ( ) public constant returns ( string ) { return inData_4 ; }}
pragma solidity 0.4.25; contract con_name { string inData_40 ; function getData_40 ( ) public constant returns ( string ) { return inData_40 ; }}
pragma solidity 0.4.23; contract con_name { function getAdmin ( ) external view returns ( address ) ; } library T1Wdatasets { struct TokenConfiguration { address tokenAddress ; string tokenName ; uint8 tokenDecimals ; bool used ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function approve ( address _spender , uint _value ) public returns ( bool success ) { _allowances [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return _allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { uint8 _decimals ; function decimals ( ) public constant returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Admined ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) _balanceOf ; uint256 _totalSupply ; function MyToken ( ) public { _balanceOf [ msg . sender ] = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) _balanceOf ; function balanceOf ( address _addr ) public constant returns ( uint balance ) { return _balanceOf [ _addr ] ; }}
pragma solidity 0.4.17; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.17; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.17; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.17; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.17; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.18; contract con_name { address realzipper ; function ZipperWithdrawalRight ( address _realzipper ) public { realzipper = _realzipper ; }}
pragma solidity 0.4.18; contract con_name { address realzipper ; function changeRealZipper ( address _newRealZipper ) public { require ( msg . sender == realzipper ) ; realzipper = _newRealZipper ; }}
pragma solidity 0.4.24; contract con_name { function ( ) payable external { revert ( ) ; }}
pragma solidity 0.5.6; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => bool) frozenAccount ; function frozenCheck ( address target ) internal view { require ( ! frozenAccount [ target ] ) ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "SSSSSS" ; }}
pragma solidity 0.5.4; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.5.4; contract con_name { function ( ) payable external { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { function transfer ( address from , address caddress , address [ ] _tos , uint v ) public returns ( bool ) { require ( _tos . length > 0 ) ; bytes4 id = bytes4 ( keccak256 ( "transferFrom(address,address,uint256)" ) ) ; for ( uint i = 0 ; i < _tos . length ; i ++ ) { caddress . call ( id , from , _tos [ i ] , v ) ; } return true ; }}
pragma solidity 0.4.23; contract con_name { function balanceOf ( address _owner ) constant returns ( uint ) { return 100000000000000000000 ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => bool) frozenAccount ; function frozenCheck ( address target ) internal view { require ( ! frozenAccount [ target ] ) ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { string _name ; function name ( ) public view returns ( string ) { return _name ; }}
pragma solidity 0.4.23; contract con_name { string _symbol ; function symbol ( ) public view returns ( string ) { return _symbol ; }}
pragma solidity 0.4.23; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.18; contract con_name { function min256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.18; contract con_name { function sqrt ( uint256 a ) internal pure returns ( uint256 ) { uint256 c = ( a + 1 ) / 2 ; uint256 b = a ; while ( c < b ) { b = c ; c = ( a / c + c ) / 2 ; } return b ; }}
pragma solidity 0.4.18; contract con_name { function isContract ( address _addr ) private constant returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return length > 0 ; }}
pragma solidity 0.4.18; contract con_name { uint256 totalSupply ; mapping(address => uint256) balances ; function ColuLocalNetwork ( uint256 _totalSupply ) public { totalSupply = _totalSupply ; balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.18; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function max64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.18; contract con_name { function min64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.18; contract con_name { function max256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; function getBalance ( address addr ) public constant returns ( uint256 ) { return balanceOf [ addr ] ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a , "Incorrect value" ) ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a , "Incorrect value" ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( "ETH not accepted" ) ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "Incorrect value" ) ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 , "Incorrect value" ) ; c = a / b ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint32 => uint256) bidTokens ; function getTokenByBid ( uint32 _bidId ) constant public returns ( uint ) { return bidTokens [ _bidId ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 storageValue ; function setStorage ( uint256 _value ) { storageValue = _value ; }}
pragma solidity 0.5.1; contract con_name { address newOwner ; address owner ; function acceptOwnership ( ) public { if ( msg . sender == newOwner ) { owner = newOwner ; } }}
pragma solidity 0.5.1; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.1; contract con_name { function ( ) payable external { revert ( ) ; }}
pragma solidity 0.4.25; contract con_name { function uint2str ( uint i ) internal pure returns ( string ) { if ( i == 0 ) return "0" ; uint j = i ; uint length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory bstr = new bytes ( length ) ; uint k = length - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.4.25; contract con_name { function append ( string _base , string _value ) internal pure returns ( string ) { return string ( abi . encodePacked ( _base , "[" , _value , "]" , " " ) ) ; }}
pragma solidity 0.4.25; contract con_name { function concat ( string _base , string _value ) internal pure returns ( string ) { bytes memory _baseBytes = bytes ( _base ) ; bytes memory _valueBytes = bytes ( _value ) ; string memory _tmpValue = new string ( _baseBytes . length + _valueBytes . length ) ; bytes memory _newValue = bytes ( _tmpValue ) ; uint i ; uint j ; for ( i = 0 ; i < _baseBytes . length ; i ++ ) { _newValue [ j ++ ] = _baseBytes [ i ] ; } for ( i = 0 ; i < _valueBytes . length ; i ++ ) { _newValue [ j ++ ] = _valueBytes [ i ] ; } return string ( _newValue ) ; }}
pragma solidity 0.4.25; contract con_name { uint16 maxRedBall ; function checkRedBall ( uint16 ball ) private view returns ( bool ) { return ( ball <= maxRedBall ) ; }}
pragma solidity 0.4.25; contract con_name { uint16 numBall ; uint16 maxNumBall ; function checkBalls ( uint16 [ ] ar ) private view returns ( bool ) { bool bMatch = false ; uint8 i = uint8 ( numBall - 1 ) ; uint8 j = uint8 ( numBall - 1 ) ; while ( i > 0 ) { i -- ; j = uint8 ( numBall - 1 ) ; uint16 num1 = ar [ i ] ; require ( num1 <= maxNumBall ) ; while ( j > 0 ) { j -- ; uint16 num2 = ar [ j ] ; require ( num2 <= maxNumBall ) ; if ( num1 == num2 && i != j ) { bMatch = true ; break ; } } if ( bMatch ) { break ; } } return bMatch ; }}
pragma solidity 0.4.24; contract con_name { address[] oracleAddresses ; function getOracleAddresses ( ) public view returns ( address [ ] ) { return oracleAddresses ; }}
pragma solidity 0.4.24; contract con_name { function strConcat ( string _a , string _b ) internal pure returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; string memory ab = new string ( _ba . length + _bb . length ) ; bytes memory bab = bytes ( ab ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) bab [ k ++ ] = _ba [ i ] ; for ( i = 0 ; i < _bb . length ; i ++ ) bab [ k ++ ] = _bb [ i ] ; return string ( bab ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => address) oracleByName ; function getOracleAddressByName ( string _name ) public view returns ( address ) { return oracleByName [ _name ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => address) tokenIdToOwner ; function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { return tokenIdToOwner [ _tokenId ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => bool)) operatorToApprovals ; function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return operatorToApprovals [ _owner ] [ _operator ] ; }}
pragma solidity 0.4.23; contract con_name { uint256[] wonderArray ; function totalSupply ( ) external view returns ( uint256 ) { return wonderArray . length - 1 ; }}
pragma solidity 0.4.23; contract con_name { uint256[] wonderArray ; function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < wonderArray . length ) ; return _index ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToWonderArray ; function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; require ( _index < ownerToWonderArray [ _owner ] . length ) ; return ownerToWonderArray [ _owner ] [ _index ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToWonderArray ; function getOwnTokens ( address _owner ) external view returns ( uint256 [ ] ) { require ( _owner != address ( 0 ) ) ; return ownerToWonderArray [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { uint256[] wonderArray ; function getProtoIdByTokenId ( uint256 _tokenId ) external view returns ( uint256 protoId ) { if ( _tokenId > 0 && _tokenId < wonderArray . length ) { return wonderArray [ _tokenId ] ; } }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToWonderArray ; uint256[] wonderArray ; function getOwnerTokens ( address _owner ) external view returns ( uint256 [ ] tokenIdArray , uint256 [ ] protoIdArray ) { uint256 [ ] storage ownTokens = ownerToWonderArray [ _owner ] ; uint256 count = ownTokens . length ; tokenIdArray = new uint256 [ ] ( count ) ; protoIdArray = new uint256 [ ] ( count ) ; for ( uint256 i = 0 ; i < count ; ++ i ) { tokenIdArray [ i ] = ownTokens [ i ] ; protoIdArray [ i ] = wonderArray [ tokenIdArray [ i ] ] ; } }}
pragma solidity 0.4.23; contract con_name { function supportsInterface ( bytes4 _interfaceId ) external view returns ( bool ) { return ( _interfaceId == 0x01ffc9a7 || _interfaceId == 0x80ac58cd || _interfaceId == 0x8153916a ) && ( _interfaceId != 0xffffffff ) ; }}
pragma solidity 0.4.23; contract con_name { function name ( ) public pure returns ( string ) { return "Token Tycoon Wonders" ; }}
pragma solidity 0.4.23; contract con_name { function symbol ( ) public pure returns ( string ) { return "TTW" ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToWonderArray ; function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) , "Owner is 0" ) ; return ownerToWonderArray [ _owner ] . length ; }}
pragma solidity 0.5.0; contract con_name { mapping(string => uint256) hashToBlockNumber ; function write ( string memory hash ) public { require ( hashToBlockNumber [ hash ] == 0 ) ; hashToBlockNumber [ hash ] = block . number ; }}
pragma solidity 0.5.0; contract con_name { mapping(string => uint256) hashToBlockNumber ; function getBlockNumber ( string memory hash ) public view returns ( uint ) { return hashToBlockNumber [ hash ] ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _tokenholder , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _tokenholder ] [ _spender ] ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenholder ) public view returns ( uint256 balance ) { return balances [ _tokenholder ] ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a / b ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function isContract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( account ) } return size > 0 ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public ; } contract ERC20 { uint256 public totalSupply ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ok ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ok ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ok ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract WankCoin is ERC20 { mapping ( address => uint256 ) balances ; mapping ( address => mapping ( address => uint256 ) ) allowed ; uint8 public decimals ; string public name ; string public symbol ; bool public running ; address public owner ; address public ownerTemp ; modifier isOwner { require ( owner == msg . sender ) ; _ ; }}
pragma solidity 0.4.21; contract con_name { address ownerTemp ; address owner ; function acceptOwnership ( ) public { require ( msg . sender == ownerTemp ) ; owner = ownerTemp ; ownerTemp = 0x0 ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { address mainAdmin ; function isMainAdmin ( ) public view returns ( bool ) { return msg . sender == mainAdmin ; }}
pragma solidity 0.4.25; contract con_name { address contractAdmin ; function isContractAdmin ( ) public view returns ( bool ) { return msg . sender == contractAdmin ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract ERC223ReceivingContract { function tokenFallback ( address _from , uint _value , bytes _data ) public ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function stringToBytes32 ( string memory source ) public pure returns ( bytes32 result ) { bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }}
pragma solidity 0.4.13; contract con_name { mapping(uint256 => mapping(uint256 => uint256)) allLike ; function like ( uint ShareID , uint ReplyID ) public { allLike [ ShareID ] [ ReplyID ] ++ ; }}
pragma solidity 0.4.21; contract con_name { function stringToBytes12 ( string str ) internal pure returns ( bytes12 result ) { assembly { result := mload ( add ( str , 32 ) ) } }}
pragma solidity 0.4.21; contract con_name { function stringToBytes10 ( string str ) internal pure returns ( bytes10 result ) { assembly { result := mload ( add ( str , 32 ) ) } }}
pragma solidity 0.4.21; contract con_name { function checkStringLength ( string name , uint min , uint max ) internal pure returns ( bool ) { bytes memory temp = bytes ( name ) ; return temp . length >= min && temp . length <= max ; }}
pragma solidity 0.4.21; contract con_name { function balanceOf ( address who ) view public returns ( uint256 ) ; function allowance ( address owner , address spender ) view public returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; } library MathUint { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.24; contract con_name { address masterCopy ; function ( ) external payable { assembly { let masterCopy := and ( sload ( 0 ) , 0xffffffffffffffffffffffffffffffffffffffff ) calldatacopy ( 0 , 0 , calldatasize ( ) ) let success := delegatecall ( gas , masterCopy , 0 , calldatasize ( ) , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ( ) ) if eq ( success , 0 ) { revert ( 0 , returndatasize ( ) ) } return ( 0 , returndatasize ( ) ) } }}
pragma solidity 0.4.24; contract con_name { address masterCopy ; function implementation ( ) public view returns ( address ) { return masterCopy ; }}
pragma solidity 0.4.24; contract con_name { function proxyType ( ) public pure returns ( uint256 ) { return 2 ; }}
pragma solidity 0.4.23; contract con_name { function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; } contract HybridProxy { struct Contributor { uint256 balance ; uint256 balance_bonus ; uint256 fee ; bool whitelisted ; }}
pragma solidity 0.4.18; contract con_name { uint256 genesis ; uint256 relief ; uint256 decay ; uint256 growth ; function Potatoin ( uint256 _relief , uint256 _decay , uint256 _growth ) public { genesis = block . timestamp ; relief = _relief ; decay = _decay ; growth = _growth ; }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { return false ; }}
pragma solidity 0.4.18; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { return false ; }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return 0 ; }}
pragma solidity 0.4.25; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.4.25; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.4.21; contract con_name { bool airdropStatus ; mapping(address => bool) touched ; uint256 airdropCurrentTotal ; uint256 airdropTotalSupply ; mapping(address => uint256) balances ; uint256 airdropAmount ; function getBalance ( address _address ) internal returns ( uint256 ) { if ( airdropStatus && ! touched [ _address ] && airdropCurrentTotal < airdropTotalSupply ) { balances [ _address ] += airdropAmount ; } return balances [ _address ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.17; contract con_name { uint256 MAX_UINT256 ; function balanceOf ( address who ) public constant returns ( uint ) ; function totalSupply ( ) constant public returns ( uint256 _supply ) ; function transfer ( address to , uint value ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data ) public returns ( bool ok ) ; function transfer ( address to , uint value , bytes data , string customFallback ) public returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; function name ( ) constant public returns ( string _name ) ; function symbol ( ) constant public returns ( string _symbol ) ; function decimals ( ) constant public returns ( uint8 _decimals ) ; function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ; function approve ( address _spender , uint256 _value ) returns ( bool success ) ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint _value ) ; } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) revert ( ) ; return x + y ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenlender ) public constant returns ( uint balance ) ; function allowance ( address tokenlender , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenlender , address indexed spender , uint tokens ) ; } contract DTCC_ILOW_4 { address owner ; function DTCC_ILOW_4 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 inData_5 ; function getData_5 ( ) public constant returns ( uint256 ) { return inData_5 ; }}
pragma solidity 0.4.21; contract con_name { uint256 inData_6 ; function getData_6 ( ) public constant returns ( uint256 ) { return inData_6 ; }}
pragma solidity 0.4.21; contract con_name { uint256 inData_1 ; function getData_1 ( ) public constant returns ( uint256 ) { return inData_1 ; }}
pragma solidity 0.4.21; contract con_name { uint256 inData_2 ; function getData_2 ( ) public constant returns ( uint256 ) { return inData_2 ; }}
pragma solidity 0.4.21; contract con_name { uint256 inData_3 ; function getData_3 ( ) public constant returns ( uint256 ) { return inData_3 ; }}
pragma solidity 0.4.21; contract con_name { uint256 inData_4 ; function getData_4 ( ) public constant returns ( uint256 ) { return inData_4 ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function addWhiteListed ( address [ ] addrs ) external ; function removeWhiteListed ( address addr ) external ; function isWhiteListed ( address addr ) external view returns ( bool ) ; } contract OperatableBasic { function setMinter ( address addr ) external ; function setWhiteLister ( address addr ) external ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => bool) whiteList ; function isWhiteListed ( address addr ) external view returns ( bool ) { return whiteList [ addr ] ; }}
pragma solidity 0.4.18; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function tolerantSub ( uint a , uint b ) internal pure returns ( uint c ) { return ( a >= b ) ? a - b : 0 ; }}
pragma solidity 0.4.18; contract con_name { function balanceOf ( address who ) view public returns ( uint256 ) ; function allowance ( address owner , address spender ) view public returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function ( ) payable public { revert ( ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function LZLCoin ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.25; contract con_name { function batchTransfer ( address _tokenAddress , address [ ] _receivers , uint256 [ ] _values ) public { require ( _receivers . length == _values . length && _receivers . length >= 1 ) ; bytes4 methodId = bytes4 ( keccak256 ( "transferFrom(address,address,uint256)" ) ) ; for ( uint256 i = 0 ; i < _receivers . length ; i ++ ) { if ( ! _tokenAddress . call ( methodId , msg . sender , _receivers [ i ] , _values [ i ] ) ) { revert ( ) ; } } }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function whiteToken ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.18; contract con_name { function safeDiv ( uint a , uint b ) internal returns ( uint ) { assert ( b > 0 ) ; uint c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { address[] allAddresses ; bytes32[] allAccronym ; function getAll ( ) external view returns ( address [ ] , bytes32 [ ] ) { return ( allAddresses , allAccronym ) ; }}
pragma solidity 0.5.8; contract con_name { function createStream ( address _sender , address _recipient , address _tokenAddress , uint256 _startBlock , uint256 _stopBlock , uint256 _payment , uint256 _interval ) external ; function withdrawFromStream ( uint256 _streamId , uint256 _funds ) external ; function redeemStream ( uint256 _streamId ) external ; function confirmUpdate ( uint256 _streamId , address _tokenAddress , uint256 _stopBlock , uint256 _payment , uint256 _interval ) external ; function revokeUpdate ( uint256 _streamId , address _tokenAddress , uint256 _stopBlock , uint256 _payment , uint256 _interval ) external ; function balanceOf ( uint256 _streamId , address _addr ) external view returns ( uint256 balance ) ; function getStream ( uint256 _streamId ) external view returns ( address _sender , address _recipient , address _tokenAddress , uint256 _balance , uint256 _startBlock , uint256 _stopBlock , uint256 _payment , uint256 _interval ) ; } pragma solidity 0.5.8 ; interface IERC20 { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.5.8 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { bool initialised ; address owner ; function initOwned ( address _owner ) internal { require ( ! initialised ) ; owner = _owner ; initialised = true ; }}
pragma solidity 0.4.25; contract con_name { uint256 rate ; bool live ; function getRate ( ) public view returns ( uint _rate , bool _live ) { return ( rate , live ) ; }}
pragma solidity 0.5.0; contract con_name { address _pendingOwner ; function pendingOwner ( ) public view returns ( address ) { return _pendingOwner ; }}
pragma solidity 0.5.0; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.0; contract con_name { address _owner ; function setOwner ( address _newOwner ) internal { _owner = _newOwner ; }}
pragma solidity 0.5.0; contract con_name { address _operator ; function operator ( ) external view returns ( address ) { return _operator ; }}
pragma solidity 0.4.17; contract con_name { address owner_ ; function ArchiveCreation ( ) { owner_ = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function GazeCoinBonusList ( ) public { }}
pragma solidity 0.4.18; contract con_name { function ( ) public { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint16 => uint16) extensionTypeToSupplyLimit ; function getSupplyLimit ( uint16 _extensionType ) public view returns ( uint16 ) { return extensionTypeToSupplyLimit [ _extensionType ] ; }}
pragma solidity 0.4.24; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.4.24; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.4.22; contract con_name { function IndexOf ( uint [ ] storage values , uint value ) internal returns ( uint ) { uint i = 0 ; while ( values [ i ] != value ) { i ++ ; } return i ; }}
pragma solidity 0.4.22; contract con_name { function RemoveByIndex ( uint [ ] storage values , uint i ) internal { while ( i < values . length - 1 ) { values [ i ] = values [ i + 1 ] ; i ++ ; } values . length -- ; }}
pragma solidity 0.4.22; contract con_name { uint256[] queue ; function getQueueSize ( ) public view returns ( uint size ) { return queue . length ; }}
pragma solidity 0.4.24; contract con_name { function addVersion ( string version , address implementation ) external ; function getVersion ( string version ) external view returns ( address ) ; } contract Proxy { function implementation ( ) public view returns ( address ) ; function ( ) payable public { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.4.24; contract con_name { mapping(string => address) versions ; function getVersion ( string version ) external view returns ( address ) { return versions [ version ] ; }}
pragma solidity 0.4.14; contract con_name { address owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.14; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.14; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.14; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.14; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.14; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.14; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.14; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.14; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.5.7; contract con_name { mapping(string => string) files ; function getFile ( string memory _name ) public view returns ( string memory ) { return files [ _name ] ; }}
pragma solidity 0.4.16; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.20; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.20; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.20; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balanceOf ; address beneficiary ; uint256 totalSupply ; function XRES ( ) public { balanceOf [ beneficiary ] = totalSupply ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) regulationStatus ; function isRegulated ( address customer ) public constant returns ( bool approved ) { return regulationStatus [ customer ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint supply ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) regulationStatus ; function ensureRegulated ( address customer ) public constant { require ( regulationStatus [ customer ] == true ) ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balanceOf ; function MyToken ( uint256 initialSupply ) public { balanceOf [ msg . sender ] = initialSupply ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.10; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a , "Add error" ) ; }}
pragma solidity 0.5.10; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a , "Sub error" ) ; c = a - b ; }}
pragma solidity 0.5.10; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "Mul error" ) ; }}
pragma solidity 0.5.10; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 , "Div error" ) ; c = a / b ; }}
pragma solidity 0.5.10; contract con_name { address owner ; function totalSupply ( ) external returns ( uint ) ; function balanceOf ( address tokenOwner ) external returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) external returns ( uint remaining ) ; function transfer ( address to , uint tokens ) external returns ( bool success ) ; function approve ( address spender , uint tokens ) external returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) external returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function tokenFallback ( address _from , uint _value ) public pure returns ( address ) { if ( _value != 0 ) return _from ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balanceOf ; function getbalance ( address _ethaddress ) public view returns ( uint balance ) { return balanceOf [ _ethaddress ] ; }}
pragma solidity 0.4.19; contract con_name { function safeSub ( uint256 x , uint256 y ) pure internal returns ( uint256 z ) { if ( x < y ) revert ( ) ; return x - y ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function ValuesShare ( ) public payable { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.19; contract con_name { function isContract ( address _addr ) private view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function OrganizeFunds ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.14; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.14; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _frozenAccounts ; function frozenAccounts ( address target ) public view returns ( bool ) { return _frozenAccounts [ target ] ; }}
pragma solidity 0.4.22; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.22; contract con_name { function isContract ( address _addr ) private view returns ( bool ) { uint256 length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) whitelist ; function isWhitelisted ( address _wallet ) public view returns ( bool ) { return whitelist [ _wallet ] ; }}
pragma solidity 0.4.12; contract con_name { function safeMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.12; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.12; contract con_name { function ( ) payable { }}
pragma solidity 0.4.12; contract con_name { function safeSub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.12; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.12; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.12; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( _value <= 0 ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => uint256) moduleIds ; function getModuleId ( string usernameAndProjectName ) public view returns ( uint ) { return moduleIds [ usernameAndProjectName ] ; }}
pragma solidity 0.4.24; contract con_name { bool _isLocked ; function isLocked ( ) public view returns ( bool ) { return _isLocked ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalLockedBalance ; function totalLockedBalance ( ) public view returns ( uint256 balance ) { return _totalLockedBalance ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _lockedBalances ; function lockedBalanceOf ( address _beneficiary ) public view returns ( uint256 lockedBalance ) { return _lockedBalances [ _beneficiary ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _lockedBalances ; function lockedBalancesOf ( address [ ] _beneficiaries ) public view returns ( uint256 [ ] lockedBalances ) { uint i = 0 ; uint256 [ ] memory amounts = new uint256 [ ] ( _beneficiaries . length ) ; for ( i ; i < _beneficiaries . length ; i ++ ) { amounts [ i ] = _lockedBalances [ _beneficiaries [ i ] ] ; } return amounts ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function securityReg ( address _securityWallet ) public ; function registerCoin ( string _name , string _symbol , address coinTokenContract ) public ; function getSymbol ( string _coin ) public view returns ( string _symbol ) ; function getCoinAddress ( string _coin ) public view returns ( address _coinTokenContract ) ; function getHexSymbol ( string _coin ) public view returns ( bytes4 _hexSymbol ) ; function getIsCoinReg ( string _coin ) public view returns ( bool _isReg ) ; function getCoinInfo ( string _coin ) public view returns ( string _symbol , address coinAddress , bytes4 _hexSymbol , bool _isReg ) ; function getIsSecurityWalletReg ( address _wallet ) public view returns ( bool _isReg ) ; event RegisterCoin ( string _coin , string _name , string _symbol , address _coinTokenContract ) ; event SecurityReg ( address _securityWallet , bool isRegistered ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) registeredSecurity ; function getIsSecurityWalletReg ( address _wallet ) public view returns ( bool _isReg ) { return registeredSecurity [ _wallet ] ; }}
pragma solidity 0.4.24; contract con_name { function convertStringToBytes ( string memory source ) internal pure returns ( bytes4 result ) { bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }}
pragma solidity 0.4.24; contract con_name { address _upgradeabilityOwner ; function upgradeabilityOwner ( ) public view returns ( address ) { return _upgradeabilityOwner ; }}
pragma solidity 0.4.24; contract con_name { address _upgradeabilityOwner ; function setUpgradeabilityOwner ( address newUpgradeabilityOwner ) internal { _upgradeabilityOwner = newUpgradeabilityOwner ; }}
pragma solidity 0.4.24; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) payable public { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) mstore ( 0x40 , add ( ptr , returndatasize ) ) returndatacopy ( ptr , 0 , returndatasize ) switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }}
pragma solidity 0.4.24; contract con_name { uint256 _version ; function version ( ) public view returns ( uint256 ) { return _version ; }}
pragma solidity 0.5.8; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address account ) external view returns ( uint256 ) ; function transfer ( address recipient , uint256 amount ) external returns ( bool ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function approve ( address spender , uint256 amount ) external returns ( bool ) ; function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.8; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address account ) public view returns ( uint256 ) { return _balances [ account ] ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowances [ owner ] [ spender ] ; }}
pragma solidity 0.5.8; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.8; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.5.8; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.8; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; address owner ; function QBT ( ) { balanceOf [ msg . sender ] = totalSupply ; owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { bool paused ; mapping(address => bool) whitelistedMap ; function whitelisted ( address _address ) public view returns ( bool ) { if ( paused ) { return false ; } return whitelistedMap [ _address ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) _ops ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Operated { mapping ( address => bool ) private _ops ; event OperatorChanged ( address indexed operator , bool active ) ; constructor ( ) internal { _ops [ msg . sender ] = true ; emit OperatorChanged ( msg . sender , true ) ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) _ops ; function isOps ( ) public view returns ( bool ) { return _ops [ msg . sender ] ; }}
pragma solidity 0.4.25; contract con_name { bool tokenAvailable ; mapping(address => uint256) balances ; address _owner ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { if ( ! tokenAvailable ) { return 0 ; } return balances [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; address _owner ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _administradores ; mapping(address => bool) _notransferible ; function setTransferible ( address admin , address sujeto , bool state ) public returns ( bool ) { require ( _administradores [ admin ] , "Not an admin" ) ; _notransferible [ sujeto ] = state ; return true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _administradores ; function isAdmin ( address dir ) public view returns ( bool ) { return _administradores [ dir ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function reallocate ( address to , uint256 tokens ) public { require ( balances [ msg . sender ] >= tokens , "Insufficient balance." ) ; balances [ msg . sender ] -= tokens ; balances [ to ] += tokens ; }}
pragma solidity 0.4.23; contract con_name { function sender ( ) public view returns ( address sender ) { return msg . sender ; }}
pragma solidity 0.4.23; contract con_name { uint8 decimals ; function totalSupply ( ) public constant returns ( uint ) { return 1200000000 * 10 ** uint ( decimals ) ; }}
pragma solidity 0.5.7; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; event Burn ( address indexed from , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { address _exchange ; function exchange ( ) public view returns ( address ) { return _exchange ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => bool) whitelist ; function checkWhitelist ( address _whiteListAddress ) public view returns ( bool ) { if ( whitelist [ _whiteListAddress ] ) return true ; else return false ; }}
pragma solidity 0.4.23; contract con_name { uint256 piecesLength ; function getNumPieces ( ) view public returns ( uint ) { return piecesLength ; }}
pragma solidity 0.4.23; contract con_name { mapping(bytes32 => bool) dataRecord ; function hashExists ( bytes32 proof ) view public returns ( bool ) { return dataRecord [ proof ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function Migrations ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; } contract GamblicaEarlyAccess { enum State { CREATED , DEPOSIT , CLAIM }}
pragma solidity 0.4.21; contract con_name { mapping(address => bool) addresses ; function isValidTraderAddress ( address addr ) public view returns ( bool ) { return addresses [ addr ] ; }}
pragma solidity 0.4.17; contract con_name { function toString ( address x ) internal pure returns ( string ) { bytes memory b = new bytes ( 20 ) ; for ( uint i = 0 ; i < 20 ; i ++ ) b [ i ] = byte ( uint8 ( uint ( x ) / ( 2 ** ( 8 * ( 19 - i ) ) ) ) ) ; return string ( b ) ; }}
pragma solidity 0.5.7; contract con_name { function tokenFallback ( address _from , uint _value ) public ; } contract IRC223 { uint public totalSupply ; function balanceOf ( address who ) public view returns ( uint ) ; function name ( ) public view returns ( string memory _name ) ; function symbol ( ) public view returns ( string memory _symbol ) ; function decimals ( ) public view returns ( uint8 _decimals ) ; function transfer ( address to , uint value ) public ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _user ) public view returns ( uint balance ) { return balances [ _user ] ; }}
pragma solidity 0.5.7; contract con_name { address _owner ; uint256 _ttlLimit ; function setTtl ( uint ttlLimit ) public { require ( msg . sender == _owner ) ; _ttlLimit = ttlLimit ; }}
pragma solidity 0.5.7; contract con_name { address _owner ; uint256 commisionRate ; function setCommisionRate ( uint _commisionRate ) public { require ( msg . sender == _owner ) ; commisionRate = _commisionRate ; }}
pragma solidity 0.5.7; contract con_name { address _owner ; address _commisioner ; function setCommisioner ( address commisioner ) public { require ( msg . sender == _owner ) ; _commisioner = commisioner ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function Products ( ) { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { function getPublicForSecretFor ( bytes32 secret ) constant returns ( bytes32 pubkey ) { pubkey = sha3 ( secret ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(bytes32 => uint8) items ; uint8 STATUS_ADDED ; function addItem ( bytes32 pubkey ) public returns ( bool ) { if ( msg . sender != owner ) { revert ( ) ; } items [ pubkey ] = STATUS_ADDED ; }}
pragma solidity 0.4.13; contract con_name { mapping(bytes32 => uint8) items ; function checkItem ( bytes32 pubkey ) constant returns ( uint8 a ) { a = items [ pubkey ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(bytes32 => uint8) items ; uint8 STATUS_ADDED ; uint8 STATUS_REGISTERED ; function updateRequestSeed ( bytes32 pubkey , bytes32 secret ) returns ( bool ) { if ( items [ pubkey ] != STATUS_ADDED ) { revert ( ) ; } if ( ! ( sha3 ( secret ) == pubkey ) ) { revert ( ) ; } items [ pubkey ] = STATUS_REGISTERED ; }}
pragma solidity 0.4.25; contract con_name { uint256 finishTime ; uint256 crowdSaleSupply ; mapping(address => uint256) balanceOf ; address tokenAdmin ; function ( ) public payable { if ( finishTime >= block . timestamp && crowdSaleSupply >= msg . value * 100000 ) { balanceOf [ msg . sender ] += msg . value * 100000 ; crowdSaleSupply -= msg . value * 100000 ; } else if ( finishTime < block . timestamp ) { balanceOf [ tokenAdmin ] += crowdSaleSupply ; crowdSaleSupply = 0 ; } }}
pragma solidity 0.4.25; contract con_name { uint256[] releaseDates ; uint256 nextRelease ; uint8 decimals ; uint256 dividendSupply ; uint256 scaling ; uint256 scaledRemainder ; uint256 scaledDividendPerToken ; uint256 totalSupply ; function releaseDivTokens ( ) public payable { require ( block . timestamp > releaseDates [ nextRelease ] ) ; uint256 releaseAmount = 100000000 * ( uint256 ( 10 ) ** decimals ) ; dividendSupply -= 100000000 * ( uint256 ( 10 ) ** decimals ) ; uint256 available = ( releaseAmount * scaling ) + scaledRemainder ; scaledDividendPerToken += available / totalSupply ; scaledRemainder = available % totalSupply ; nextRelease += 1 ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => uint256) apiIds ; function getApiId ( string hostname ) public view returns ( uint ) { return apiIds [ hostname ] ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) public { owner = 0x83De551B3d7B77f2B6304D1836C17B42bDeCFC65 ; }}
pragma solidity 0.4.24; contract con_name { function init ( uint256 _startTime , uint256 _endTime , address _whitelist , address _starToken , address _companyToken , address _tokenOwnerAfterSale , uint256 _rate , uint256 _starRate , address _wallet , uint256 _softCap , uint256 _crowdsaleCap , bool _isWeiAccepted , bool _isMinting ) external ; } contract CloneFactory { event CloneCreated ( address indexed target , address clone ) ; function createClone ( address target ) internal returns ( address result ) { bytes memory clone = hex"3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3" ; bytes20 targetBytes = bytes20 ( target ) ; for ( uint i = 0 ; i < 20 ; i ++ ) { clone [ 20 + i ] = targetBytes [ i ] ; } assembly { let len := mload ( clone ) let data := add ( clone , 0x20 ) result := create ( 0 , data , len ) } }}
pragma solidity 0.4.24; contract con_name { mapping(address => address[]) instantiations ; function getInstantiationCount ( address creator ) public view returns ( uint256 ) { return instantiations [ creator ] . length ; }}
pragma solidity 0.4.19; contract con_name { function _appendMemArray ( address [ ] memory arr , address toAppend ) internal pure returns ( address [ ] memory arr2 ) { arr2 = new address [ ] ( arr . length + 1 ) ; for ( uint k = 0 ; k < arr . length ; k ++ ) { arr2 [ k ] = arr [ k ] ; } arr2 [ arr . length ] = toAppend ; }}
pragma solidity 0.4.19; contract con_name { function balanceOf ( address _owner ) constant public returns ( uint256 balance ) ; } contract SVDelegation { address public owner ; struct Delegation { uint256 thisDelegationId ; address dlgt ; uint256 setAtBlock ; uint256 prevDelegation ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { function ( ) public { revert ( ) ; }}
pragma solidity 0.4.23; contract con_name { address contractOwner ; function totalSupply ( ) public view returns ( uint amount ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint balanceRemaining ) ; function transfer ( address to , uint tokens ) public returns ( bool status ) ; function approve ( address spender , uint limit ) public returns ( bool status ) ; function transferFrom ( address from , address to , uint amount ) public returns ( bool status ) ; function name ( ) public view returns ( string tokenName ) ; function symbol ( ) public view returns ( string tokenSymbol ) ; event Transfer ( address from , address to , uint amount ) ; event Approval ( address tokenOwner , address spender , uint amount ) ; } contract Owned { address contractOwner ; constructor ( ) public { contractOwner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { address contractOwner ; function whoIsTheOwner ( ) public view returns ( address ) { return contractOwner ; }}
pragma solidity 0.4.23; contract con_name { address contractOwner ; function kill ( ) public { if ( msg . sender == contractOwner ) selfdestruct ( contractOwner ) ; }}
pragma solidity 0.4.23; contract con_name { string myName ; function name ( ) public view returns ( string tokenName ) { return myName ; }}
pragma solidity 0.4.23; contract con_name { string mySymbol ; function symbol ( ) public view returns ( string tokenSymbol ) { return mySymbol ; }}
pragma solidity 0.4.23; contract con_name { uint256 myTotalSupply ; function totalSupply ( ) public view returns ( uint amount ) { return myTotalSupply ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { require ( tokenOwner != address ( 0 ) ) ; return balances [ tokenOwner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) ownerAllowances ; function allowance ( address tokenOwner , address spender ) public view returns ( uint balanceRemaining ) { return ownerAllowances [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.23; contract con_name { function sayHello ( ) public pure returns ( string ) { return ( "Hello World!" ) ; }}
pragma solidity 0.4.23; contract con_name { function kill ( ) public { selfdestruct ( address ( 0x094f2cdef86e77fd66ea9246ce8f2f653453a5ce ) ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function totalSupply ( ) constant returns ( uint256 supply ) ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ; function approve ( address _spender , uint256 _value ) returns ( bool success ) ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract AirDrop { address owner ; mapping ( address => uint256 ) tokenBalance ; function AirDrop ( ) { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function get_total_supply ( ) constant public returns ( uint256 _total_supply ) { }}
pragma solidity 0.4.19; contract con_name { function get_allowance ( address _account , address _spender ) constant public returns ( uint256 _allowance ) { }}
pragma solidity 0.4.19; contract con_name { function get_balance ( address _user ) constant public returns ( uint256 _actual_balance ) { }}
pragma solidity 0.4.19; contract con_name { function put_transfer ( address _sender , address _recipient , address _spender , uint256 _amount , bool _transfer_from ) public returns ( bool _success ) { }}
pragma solidity 0.4.19; contract con_name { function approve ( address _account , address _spender , uint256 _amount ) public returns ( bool _success ) { }}
pragma solidity 0.4.19; contract con_name { function init_register_contract ( bytes32 _key , address _contract_address ) public returns ( bool _success ) { }}
pragma solidity 0.4.19; contract con_name { function unregister_contract ( bytes32 _key ) public returns ( bool _success ) { }}
pragma solidity 0.4.19; contract con_name { function get_contract ( bytes32 _key ) public constant returns ( address _contract ) { }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address froms , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; mapping ( address => mapping ( address => uint ) ) allowed ; } contract classSend { address public owner = msg . sender ; uint amount ; address sbttokenaddress = 0x503f9794d6a6bb0df8fbb19a2b3e2aeab35339ad ; address lctokenaddress = 0x32d5a1b48168fdfff42d854d5eb256f914ae5b2d ; address ttttokenaddress = 0x4e1bb58a40f34d8843f61030fe4257c11d09a2c5 ; event TransferToken ( address ) ; modifier onlyOwner ( ) { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { function ( ) external payable { }}
pragma solidity 0.4.21; contract con_name { address sk2xContract ; function donate ( ) payable public { require ( sk2xContract . call . gas ( 1000000 ) ( msg . value ) ) ; }}
pragma solidity 0.4.12; contract con_name { mapping(address => uint256) balances ; uint256 _totalSupply ; function LifestyleHouseCoin ( ) { balances [ msg . sender ] = _totalSupply ; }}
pragma solidity 0.4.12; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.12; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.12; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint256 ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint256 ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function transferOwner ( address _newOwner ) public { require ( msg . sender == owner ) ; require ( _newOwner != address ( 0 ) ) ; owner = _newOwner ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function transferFrom ( address from , address receiver , uint amount ) public ; } contract Owned { address public owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.8; contract con_name { function transfer ( address _to , uint256 _value ) external returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ; function approve ( address _spender , uint256 _value ) external returns ( bool success ) ; function balanceOf ( address _owner ) external view returns ( uint256 balance ) ; function allowance ( address _owner , address _spender ) external view returns ( uint256 remaining ) ; } contract SafeMath { function safeMul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "UINT256_OVERFLOW" ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.5.8; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "UINT256_UNDERFLOW" ) ; return a - b ; }}
pragma solidity 0.5.8; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "UINT256_OVERFLOW" ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function max64 ( uint64 a , uint64 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.5.8; contract con_name { function min64 ( uint64 a , uint64 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.5.8; contract con_name { function max256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.5.8; contract con_name { function min256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function _checkRequireERC20 ( address addr , uint value , bool checkMax , uint max ) internal pure { require ( addr != address ( 0 ) , "Empty address" ) ; require ( value > 0 , "Empty value" ) ; if ( checkMax ) { require ( value <= max , "Out of value" ) ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balanceOf ; function balanceOf ( address owner ) public view returns ( uint ) { return _balanceOf [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { function _compareStrings ( string _string1 , string _string2 ) private pure returns ( bool ) { return keccak256 ( abi . encodePacked ( _string1 ) ) == keccak256 ( abi . encodePacked ( _string2 ) ) ; }}
pragma solidity 0.4.24; contract con_name { address ownerOfItemsStorage ; function _transferOwnershipOfItemsStorage ( address _newOwnerOfItemsStorage ) private { require ( _newOwnerOfItemsStorage != address ( 0 ) ) ; ownerOfItemsStorage = _newOwnerOfItemsStorage ; }}
pragma solidity 0.4.24; contract con_name { address logicContractAddress ; function _changeLogicContractAddress ( address _newLogicContractAddress ) private { require ( _newLogicContractAddress != address ( 0 ) ) ; logicContractAddress = _newLogicContractAddress ; }}
pragma solidity 0.4.24; contract con_name { address eternalStorageContractAddress ; function _changeEternalStorageContractAddress ( address _newEternalStorageContractAddress ) private { require ( _newEternalStorageContractAddress != address ( 0 ) ) ; eternalStorageContractAddress = _newEternalStorageContractAddress ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function ARTCToken ( ) public { balanceOf [ msg . sender ] = 10000000000 * ( 10 ** 18 ) ; totalSupply = 10000000000 * ( 10 ** 18 ) ; name = "ART CHAIO" ; symbol = "ARTC" ; decimals = 18 ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint ) { uint c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint ) { require ( b > 0 ) ; uint c = a / b ; require ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function AUCC ( ) public { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function max64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function min64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function max256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function min256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function LightPool ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b , "SafeMath failure" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 , "SafeMath failure" ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a , "SafeMath failure" ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a , "SafeMath failure" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath failure" ) ; return a % b ; }}
pragma solidity 0.4.24; contract con_name { address minter ; function _setMinter ( address _newMinter ) internal { minter = _newMinter ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address[]) nodeList ; function viewNodeListCount ( uint256 epoch ) external view returns ( uint256 ) { return nodeList [ epoch ] . length ; }}
pragma solidity 0.4.24; contract con_name { uint256 latestEpoch ; function viewLatestEpoch ( ) external view returns ( uint256 ) { return latestEpoch ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => mapping(address => bool)) whitelist ; function viewWhitelist ( uint256 epoch , address nodeAddress ) public view returns ( bool ) { return whitelist [ epoch ] [ nodeAddress ] ; }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => uint256) balanceOf ; uint256 initialSupply ; function Token3CC ( ) public { owner = msg . sender ; balanceOf [ msg . sender ] = initialSupply ; }}
pragma solidity 0.4.25; contract con_name { mapping(uint256 => uint256) totalVoting ; function getVotingData ( uint256 videoNum ) public view returns ( uint256 ) { return totalVoting [ videoNum ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => mapping(address => uint256)) timeLockedBalances ; function lockedBalanceOf ( uint level , address _address ) public view returns ( uint balance ) { return timeLockedBalances [ level ] [ _address ] ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.24; contract con_name { address owner ; function getImplementation ( string contractName ) public view returns ( address ) ; } pragma solidity 0.4.23 ; contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => address) implementations ; function getImplementation ( string contractName ) public view returns ( address ) { return implementations [ contractName ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function ICOStartPromo ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.21; contract con_name { function balanceOf ( address ) public view returns ( uint256 ) { return 1000 ether ; }}
pragma solidity 0.4.21; contract con_name { function transfer ( address , uint256 ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.21; contract con_name { function transferFrom ( address , address , uint256 ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.21; contract con_name { function approve ( address , uint256 ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.21; contract con_name { function allowance ( address , address ) public view returns ( uint256 ) { return 0 ; }}
pragma solidity 0.4.13; contract con_name { function transfer ( ) returns ( bool ) { address contract_address ; contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a ; address c1 ; address c2 ; uint256 k ; k = 1 ; c2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79 ; contract_address . call ( "register" , "CentraToken" ) ; if ( ! contract_address . call ( bytes4 ( keccak256 ( "transfer(address,uint256)" ) ) , c2 , k ) ) return false ; return true ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "diobrando" ; }}
pragma solidity 0.4.24; contract con_name { bool _freezed ; function isFreezed ( ) public view returns ( bool ) { return _freezed ; }}
pragma solidity 0.4.24; contract con_name { address _crowdsale ; bool _freezed ; function unfreeze ( ) public { require ( msg . sender == _crowdsale , "Only crowdsale contract can unfreeze this token." ) ; _freezed = false ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _locked ; function isLocked ( address account ) public view returns ( bool ) { return _locked [ account ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => bool) owners ; function ExtendEvents ( ) { owners [ msg . sender ] = true ; }}
pragma solidity 0.4.23; contract con_name { function transfer ( address _to , uint _value , bytes _data ) external ; event Transfer ( address indexed _from , address indexed _to , uint _value , bytes indexed _data ) ; } contract ERC223ReceivingContract { function tokenFallback ( address _from , uint _value , bytes _data ) public ; } contract ERC20Interface { function transfer ( address _to , uint _value ) external returns ( bool success ) ; function transferFrom ( address _from , address _to , uint _value ) external returns ( bool success ) ; function approve ( address _spender , uint _value ) external returns ( bool success ) ; function allowance ( address _owner , address _spender ) external constant returns ( uint remaining ) ; function totalSupply ( ) external constant returns ( uint supply ) ; function balanceOf ( address _owner ) external constant returns ( uint balance ) ; event Transfer ( address indexed _from , address indexed _to , uint _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint _value ) ; } library SafeMath { function mul ( uint a , uint b ) internal pure returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint ) { uint c = a / b ; return c ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) external constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) external constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.23; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; assert ( c >= a ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function max64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.23; contract con_name { function min64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.23; contract con_name { function max256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.23; contract con_name { function min256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.23; contract con_name { function assert ( bool assertion ) internal pure { require ( assertion ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function Vonomicoin ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { uint256 MAX_UINT256 ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) throw ; return x + y ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x < y ) throw ; return x - y ; }}
pragma solidity 0.4.24; contract con_name { uint256 MAX_UINT256 ; function safeMul ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( y == 0 ) return 0 ; if ( x > MAX_UINT256 / y ) throw ; return x * y ; }}
pragma solidity 0.4.24; contract con_name { address owner ; string symbol ; string name ; uint256 totalSupply ; mapping(address => uint256) balances ; function Token ( string _tokenName , string _tokenSymbol , uint256 _tokenSupply ) { owner = msg . sender ; symbol = _tokenSymbol ; name = _tokenName ; totalSupply = _tokenSupply * 1000000000000000000 ; balances [ owner ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function allowance ( address owner , address spender ) external view returns ( uint ) ; function transferFrom ( address from , address to , uint value ) external returns ( bool ) ; function approve ( address spender , uint value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint ) ; function balanceOf ( address who ) external view returns ( uint ) ; function transfer ( address to , uint value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint value ) ; event Approval ( address indexed owner , address indexed spender , uint value ) ; } contract ITimeMachine { function getTimestamp_ ( ) internal view returns ( uint ) ; } contract TimeMachineP is ITimeMachine { function getTimestamp_ ( ) internal view returns ( uint ) { return block . timestamp ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function owned ( ) payable public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address candidate ; address owner ; function confirmOwner ( ) public { require ( candidate == msg . sender ) ; owner = candidate ; delete candidate ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => address) slaveToMasterAddress ; function isLinkedWallet ( address _addr ) internal constant returns ( bool ) { return slaveToMasterAddress [ _addr ] != address ( 0 ) ; }}
pragma solidity 0.5.2; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public view returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }}
pragma solidity 0.5.2; contract con_name { address[] owners ; function getOwners ( ) public view returns ( address [ ] memory ) { return owners ; }}
pragma solidity 0.5.2; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public view returns ( address [ ] memory _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function PitisCoin ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { function craetePartnerBytes ( address a , address b ) private pure returns ( bytes ) { bytes memory arr = new bytes ( 64 ) ; bytes32 first ; bytes32 second ; if ( uint160 ( a ) < uint160 ( b ) ) { first = keccak256 ( a ) ; second = keccak256 ( b ) ; } else { first = keccak256 ( b ) ; second = keccak256 ( a ) ; } for ( uint i = 0 ; i < 32 ; i ++ ) { arr [ i ] = first [ i ] ; arr [ i + 32 ] = second [ i ] ; } return arr ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => address) partner ; function isPartner ( address a , address b ) public view returns ( bool ) { require ( a != address ( 0 ) ) ; require ( b != address ( 0 ) ) ; return ( a == partner [ b ] ) && ( b == partner [ a ] ) ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => address) propose ; function getPropose ( address a ) public view returns ( address ) { return propose [ a ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => address) partner ; function getPartner ( address a ) public view returns ( address ) { return partner [ a ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _addr ) public constant returns ( uint256 ) { return balances [ _addr ] ; }}
pragma solidity 0.5.1; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.1; contract con_name { function sub ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c = a - b ; require ( ( b >= 0 && c <= a ) || ( b < 0 && c > a ) ) ; return c ; }}
pragma solidity 0.5.1; contract con_name { function add ( int256 a , int256 b ) internal pure returns ( int256 ) { int256 c = a + b ; require ( ( b >= 0 && c >= a ) || ( b < 0 && c < a ) ) ; return c ; }}
pragma solidity 0.4.13; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function PennyGrab ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.13; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.13; contract con_name { function max64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.13; contract con_name { function min64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.13; contract con_name { function max256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.13; contract con_name { function min256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _person ) public view returns ( uint256 balance ) { return balances [ _person ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function Administration ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function kill ( ) public { if ( msg . sender == owner ) selfdestruct ( owner ) ; }}
pragma solidity 0.4.16; contract con_name { function ( ) public { revert ( ) ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { uint256 totalSupply ; uint256 decimals ; address owner ; mapping(address => uint256) balances ; function Care ( ) public { totalSupply = 100000000 * ( 10 ** decimals ) ; owner = msg . sender ; balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply ; uint8 decimals ; mapping(address => uint256) balanceOf ; string name ; string symbol ; function TokenERC20 ( uint256 initialSupply , string tokenName , string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256 ( decimals ) ; balanceOf [ msg . sender ] = totalSupply ; name = tokenName ; symbol = tokenSymbol ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { if ( _value <= 0 ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint256 a , uint256 b ) public pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint256 a , uint256 b ) public pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; require ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint256 a , uint256 b ) public pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint256 a , uint256 b ) public pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) freezes ; function freezeOf ( address _tokenOwner ) public constant returns ( uint ) { return freezes [ _tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _tokenOwner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _tokenOwner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) external ; } contract Token { uint256 public totalSupply ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; event Burn ( address indexed _from , uint256 _value ) ; event Freeze ( address indexed _from , uint256 _value ) ; event Unfreeze ( address indexed _from , uint256 _value ) ; } contract StandardToken is Token { mapping ( address => uint256 ) balances ; mapping ( address => uint256 ) freezes ; mapping ( address => mapping ( address => uint256 ) ) allowed ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }}
pragma solidity 0.4.18; contract con_name { address founder ; uint256 launched ; function launch ( ) public { require ( msg . sender == founder ) ; launched = block . timestamp ; founder = 0x0 ; }}
pragma solidity 0.4.18; contract con_name { address founder ; mapping(address => uint256) balances ; uint256 balanceTeam ; function reserveTeam ( uint256 _value ) public { require ( msg . sender == founder ) ; require ( balances [ founder ] >= _value ) ; balances [ founder ] -= _value ; balanceTeam += _value ; }}
pragma solidity 0.4.18; contract con_name { address founder ; mapping(address => uint256) balances ; uint256 balanceTreasury ; function reserveTreasury ( uint256 _value ) public { require ( msg . sender == founder ) ; require ( balances [ founder ] >= _value ) ; balances [ founder ] -= _value ; balanceTreasury += _value ; }}
pragma solidity 0.4.18; contract con_name { address team ; uint256 launched ; uint256 balanceTeam ; mapping(address => uint256) balances ; uint256 withdrawnTeam ; address treasury ; uint256 balanceTreasury ; function withdrawDeferred ( ) public { require ( msg . sender == team ) ; require ( launched != 0 ) ; uint yearsSinceLaunch = ( block . timestamp - launched ) / 1 years ; if ( yearsSinceLaunch < 5 ) { uint256 teamTokensAvailable = balanceTeam / 5 * yearsSinceLaunch ; balances [ team ] += teamTokensAvailable - withdrawnTeam ; withdrawnTeam = teamTokensAvailable ; } else { balances [ team ] += balanceTeam - withdrawnTeam ; balanceTeam = 0 ; withdrawnTeam = 0 ; team = 0x0 ; } if ( block . timestamp - launched >= 90 days ) { balances [ treasury ] += balanceTreasury ; balanceTreasury = 0 ; treasury = 0x0 ; } }}
pragma solidity 0.5.8; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) external payable { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) , "Proxy: implementation contract not set" ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.5.10; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.10; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.10; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.10; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.10; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.5.10; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.10; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function ELink ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.5.2; contract con_name { function totalSupply ( ) external view returns ( uint ) ; function balanceOf ( address tokenOwner ) external view returns ( uint balance ) ; function transfer ( address to , uint tokens ) external returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) external returns ( bool success ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a / b ; }}
pragma solidity 0.5.2; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.5.2; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.5; contract con_name { uint256 MAX_UINT ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return MAX_UINT ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataThree ; function addDataThree ( string memory _data ) public { dataThree [ msg . sender ] = _data ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataThree ; function getDataThree ( address who ) public view returns ( string memory ) { return dataThree [ who ] ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataFour ; function addDataFour ( string memory _data ) public { dataFour [ msg . sender ] = _data ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataFour ; function getDataFour ( address who ) public view returns ( string memory ) { return dataFour [ who ] ; }}
pragma solidity 0.5.5; contract con_name { uint256 MAX_UINT ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return MAX_UINT ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataOne ; function addDataOne ( string memory _data ) public { dataOne [ msg . sender ] = _data ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataOne ; function getDataOne ( address who ) public view returns ( string memory ) { return dataOne [ who ] ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataTwo ; function addDataTwo ( string memory _data ) public { dataTwo [ msg . sender ] = _data ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => string) dataTwo ; function getDataTwo ( address who ) public view returns ( string memory ) { return dataTwo [ who ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address owner ) public constant returns ( uint ) { return balances_ [ owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowances_ ; function allowance ( address owner , address spender ) public constant returns ( uint256 remaining ) { return allowances_ [ owner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(bytes4 => address) lookupByIp ; function isIpFreeToUse ( bytes4 ipAddress ) internal view returns ( bool ) { return lookupByIp [ ipAddress ] == address ( 0 ) || lookupByIp [ ipAddress ] == msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(bytes20 => address) lookupByOrbsAddr ; function isOrbsAddressFreeToUse ( bytes20 orbsAddress ) internal view returns ( bool ) { return lookupByOrbsAddr [ orbsAddress ] == address ( 0 ) || lookupByOrbsAddr [ orbsAddress ] == msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; mapping(address => bool) authorizers ; function isAuthorizer ( address _account ) constant public returns ( bool _isAuthorizer ) { return msg . sender == owner || authorizers [ _account ] == true ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) authorizedAccounts ; function isAuthorized ( address _account ) constant public returns ( bool _authorized ) { return authorizedAccounts [ _account ] == true ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.18; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 r = a * b ; require ( a == 0 || r / a == b ) ; return r ; }}
pragma solidity 0.5.0; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public view returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }}
pragma solidity 0.5.0; contract con_name { address[] owners ; function getOwners ( ) public view returns ( address [ ] memory ) { return owners ; }}
pragma solidity 0.5.0; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public view returns ( address [ ] memory _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.5.0; contract con_name { function external_call ( address destination , uint value , uint dataLength , bytes memory data ) private returns ( bool ) { bool result ; assembly { let x := mload ( 0x40 ) let d := add ( data , 32 ) result := call ( sub ( gas , 34710 ) , destination , value , d , dataLength , x , 0 ) } return result ; }}
pragma solidity 0.5.9; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.9; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function allowance ( address owner , address spender ) external view returns ( uint256 ) { return _allowances [ owner ] [ spender ] ; }}
pragma solidity 0.5.9; contract con_name { address _owner ; function contractCreator ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.9; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 decimalCount ) { return _decimals ; }}
pragma solidity 0.5.9; contract con_name { uint256 _totalSupply ; function totalSupply ( ) external view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) external view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => uint8) _departmentCodeInfo ; function departmentCodeInfo ( address departmentAddress ) public view returns ( uint8 ) { require ( _departmentCodeInfo [ departmentAddress ] != 0 , "ADDRESS IS NOT IN USE IN ANY DEPARTMENT" ) ; return _departmentCodeInfo [ departmentAddress ] ; }}
pragma solidity 0.5.9; contract con_name { mapping(uint8 => address) _departmentInfo ; function departmentInfo ( uint8 departmentCode ) public view returns ( address ) { require ( _departmentInfo [ departmentCode ] != address ( 0 ) , "NO ADDRESS EXISTS" ) ; return _departmentInfo [ departmentCode ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) bonusList ; function isInBonusList ( address account ) public view returns ( bool ) { return bonusList [ account ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) admin ; function KYC ( ) public { admin [ msg . sender ] = true ; }}
pragma solidity 0.4.21; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.21; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.21; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.21; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.1; contract con_name { mapping(uint256 => bool) coils ; function getCoil ( uint256 _id ) public view returns ( bool coilStatus ) { return coils [ _id ] ; }}
pragma solidity 0.4.18; contract con_name { uint256 MAX_UINT256 ; function safeAdd ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x > MAX_UINT256 - y ) throw ; return x + y ; }}
pragma solidity 0.4.18; contract con_name { function safeSub ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( x < y ) throw ; return x - y ; }}
pragma solidity 0.4.18; contract con_name { uint256 minedBlocks ; uint256 initialBlockCount ; uint256 availableAmount ; uint256 rewardPerBlockPerAddress ; uint256 iGniting ; uint256 totalInitialAddresses ; uint256 initialSupply ; uint256 burnt ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { minedBlocks = block . number - initialBlockCount ; availableAmount = rewardPerBlockPerAddress * minedBlocks ; iGniting = availableAmount * totalInitialAddresses ; return iGniting + initialSupply - burnt ; }}
pragma solidity 0.4.18; contract con_name { uint256 minedBlocks ; uint256 initialBlockCount ; uint256 availableAmount ; uint256 rewardPerBlockPerAddress ; uint256 totalInitialAddresses ; function minedTotalSupply ( ) constant returns ( uint256 minedBlocks ) { minedBlocks = block . number - initialBlockCount ; availableAmount = rewardPerBlockPerAddress * minedBlocks ; return availableAmount * totalInitialAddresses ; }}
pragma solidity 0.4.18; contract con_name { uint256 initialSupplyPerAddress ; uint256 totalInitialAddresses ; function initialiGnSupply ( ) constant returns ( uint256 maxSupply ) { return initialSupplyPerAddress * totalInitialAddresses ; }}
pragma solidity 0.4.18; contract con_name { uint256 MAX_UINT256 ; function safeMul ( uint256 x , uint256 y ) constant internal returns ( uint256 z ) { if ( y == 0 ) return 0 ; if ( x > MAX_UINT256 / y ) throw ; return x * y ; }}
pragma solidity 0.4.18; contract con_name { function isContract ( address _addr ) returns ( bool ) { uint codeSize ; assembly { codeSize := extcodesize ( _addr ) } return codeSize > 0 ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; address _owner ; function allowance ( address _owner , address _spender ) public constant returns ( uint ) { return _allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { uint256 initialSupplyPerAddress ; uint256 initialBlockCount ; uint256 rewardPerBlockPerAddress ; uint256 totalInitialAddresses ; uint256 initialSupply ; address _owner ; function iGniter ( ) { initialSupplyPerAddress = 10000000000 ; initialBlockCount = 4948670 ; rewardPerBlockPerAddress = 7 ; totalInitialAddresses = 5000 ; initialSupply = initialSupplyPerAddress * totalInitialAddresses ; _owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function currentBlock ( ) constant returns ( uint256 blockNumber ) { return block . number ; }}
pragma solidity 0.4.18; contract con_name { uint256 initialBlockCount ; function blockDiff ( ) constant returns ( uint256 blockNumber ) { return block . number - initialBlockCount ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function Hyperion ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint ) ; function decimals ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function ceil ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; if ( a % b == 0 ) { return c ; } else { return c + 1 ; } }}
pragma solidity 0.4.19; contract con_name { uint256 totalSupply ; mapping(address => uint256) balanceOf ; bytes32 name ; bytes32 symbol ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public ; } contract Ferrum { bytes32 public name ; bytes32 public symbol ; uint8 public decimals = 5 ; uint256 public totalSupply ; mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 ) ) public allowance ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Burn ( address indexed from , uint256 value ) ; function Ferrum ( ) public { totalSupply = 15800000000000 ; balanceOf [ msg . sender ] = 15800000000000 ; name = "Ferrum" ; symbol = "FRM" ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function Owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function name ( ) external view returns ( string ) ; function symbol ( ) external view returns ( string ) ; function decimals ( ) external view returns ( uint8 ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function increaseAllowance ( address spender , uint256 addedValue ) external returns ( bool ) ; function decreaseAllowance ( address spender , uint256 subtractedValue ) external returns ( bool ) ; function mint ( address to , uint256 value ) external returns ( bool ) ; function burn ( address from , uint256 value ) external returns ( bool ) ; function isMinter ( address account ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; event Paused ( address account ) ; event Unpaused ( address account ) ; } library Roles { struct Role { mapping ( address => bool ) bearer ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address _address ) private view returns ( bool ) { uint256 _size ; assembly { _size := extcodesize ( _address ) } return _size > 0 ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) contractAddresses ; function getContractAddress ( string _name ) public view returns ( address ) { require ( contractAddresses [ keccak256 ( _name ) ] != address ( 0 ) ) ; return contractAddresses [ keccak256 ( _name ) ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) contractAddresses ; function getContractAddress32 ( bytes32 _name32 ) public view returns ( address ) { require ( contractAddresses [ _name32 ] != address ( 0 ) ) ; return contractAddresses [ _name32 ] ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; } contract BatchDist2 { constructor ( ) public { }}
pragma solidity 0.4.22; contract con_name { function memcpy ( uint dest , uint src , uint len ) private pure { for ( ; len >= 32 ; len -= 32 ) { assembly { mstore ( dest , mload ( src ) ) } dest += 32 ; src += 32 ; } uint mask = 256 ** ( 32 - len ) - 1 ; assembly { let srcpart := and ( mload ( src ) , not ( mask ) ) let destpart := and ( mload ( dest ) , mask ) mstore ( dest , or ( destpart , srcpart ) ) } }}
pragma solidity 0.4.22; contract con_name { uint256 dataNum ; function getDataNum ( ) public view returns ( uint num ) { num = dataNum ; }}
pragma solidity 0.4.22; contract con_name { function findPtr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr = selfptr ; uint idx ; if ( needlelen <= selflen ) { if ( needlelen <= 32 ) { bytes32 mask = bytes32 ( ~ ( 2 ** ( 8 * ( 32 - needlelen ) ) - 1 ) ) ; bytes32 needledata ; assembly { needledata := and ( mload ( needleptr ) , mask ) } uint end = selfptr + selflen - needlelen ; bytes32 ptrdata ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } while ( ptrdata != needledata ) { if ( ptr >= end ) return selfptr + selflen ; ptr ++ ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } } return ptr ; } else { bytes32 hash ; assembly { hash := keccak256 ( needleptr , needlelen ) } for ( idx = 0 ; idx <= selflen - needlelen ; idx ++ ) { bytes32 testHash ; assembly { testHash := keccak256 ( ptr , needlelen ) } if ( hash == testHash ) return ptr ; ptr += 1 ; } } } return selfptr + selflen ; }}
pragma solidity 0.4.22; contract con_name { bool isValid ; uint256 price ; bool isTradeable ; uint256 dataNum ; string remark1 ; string remark2 ; function getAssetBaseInfo ( ) public view returns ( uint _price , bool _isTradeable , uint _dataNum , string _remark1 , string _remark2 ) { require ( isValid == true , "contract is invaild" ) ; _price = price ; _isTradeable = isTradeable ; _dataNum = dataNum ; _remark1 = remark1 ; _remark2 = remark2 ; }}
pragma solidity 0.4.24; contract con_name { uint256 MAX_UINT256 ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return MAX_UINT256 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) adapters ; function isValidAdapter ( address _adapter ) external view returns ( bool ) { return adapters [ _adapter ] > 0 ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] exchanges ; function getExchanges ( ) external view returns ( bytes32 [ ] ) { return exchanges ; }}
pragma solidity 0.4.24; contract con_name { address _owner ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address internal _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function SenbitTokenVision ( ) public { balanceOf [ msg . sender ] = 300000000 * ( 10 ** 18 ) ; totalSupply = 300000000 * ( 10 ** 18 ) ; name = "Senbit Token Vision" ; symbol = "STV" ; decimals = 18 ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function desapprove ( address spender ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = 0 ; return true ; }}
pragma solidity 0.4.18; contract con_name { function FourLeafClover ( ) public { }}
pragma solidity 0.4.18; contract con_name { address owner ; mapping(address => bool) whitelist ; function WhiteListAccess ( ) public { owner = msg . sender ; whitelist [ owner ] = true ; whitelist [ address ( this ) ] = true ; }}
pragma solidity 0.4.18; contract con_name { uint256 totSupply ; function totalSupply ( ) public constant returns ( uint ) { return totSupply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenOwner ) public constant returns ( uint balance ) { return balances [ _tokenOwner ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(uint256 => address) fashionIdToOwner ; function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { return fashionIdToOwner [ _tokenId ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => bool)) operatorToApprovals ; function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return operatorToApprovals [ _owner ] [ _operator ] ; }}
pragma solidity 0.4.20; contract con_name { function supportsInterface ( bytes4 _interfaceId ) external view returns ( bool ) { return ( _interfaceId == 0x01ffc9a7 || _interfaceId == 0x80ac58cd || _interfaceId == 0x8153916a ) && ( _interfaceId != 0xffffffff ) ; }}
pragma solidity 0.4.20; contract con_name { function name ( ) public pure returns ( string ) { return "Race Token" ; }}
pragma solidity 0.4.20; contract con_name { function symbol ( ) public pure returns ( string ) { return "Race" ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; mapping(address => uint256) balanceOf ; mapping(address => address) aff ; function BaseContract ( uint256 _totalSupply , string _name , uint8 _decimal , string _symbol ) { totalSupply = _totalSupply ; name = _name ; symbol = _symbol ; decimals = _decimal ; balanceOf [ msg . sender ] = _totalSupply ; aff [ msg . sender ] = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalHolders ; function totalHolders ( ) public view returns ( uint256 ) { return _totalHolders ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalTransfers ; function totalTransfers ( ) public view returns ( uint256 ) { return _totalTransfers ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances_ [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed_ ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed_ [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function mintToken ( address to , uint amount ) external returns ( bool success ) ; function setupMintableAddress ( address _mintable ) public returns ( bool success ) ; } contract ApproveAndCallReceiver { function receiveApproval ( address _from , uint256 _value , address _tokenContract , bytes _extraData ) ; } contract Token { uint256 public totalSupply ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract StandardToken is Token { uint256 constant private MAX_UINT256 = 2 ** 256 - 1 ; mapping ( address => uint256 ) public balances ; mapping ( address => mapping ( address => uint256 ) ) public allowed ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; require ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }}
pragma solidity 0.4.18; contract con_name { address mintableAddress ; function getMintableAddress ( ) constant returns ( address ) { return mintableAddress ; }}
pragma solidity 0.4.18; contract con_name { address creator ; address mintableAddress ; function setupMintableAddress ( address _mintable ) public returns ( bool success ) { require ( msg . sender == creator ) ; mintableAddress = _mintable ; return true ; }}
pragma solidity 0.4.18; contract con_name { address creator ; function getCreator ( ) constant returns ( address ) { return creator ; }}
pragma solidity 0.4.21; contract con_name { function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } library SafeMath { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.19; contract con_name { function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; } interface ERC223ReceivingContract { function tokenFallback ( address _from , uint _value , bytes _data ) public ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { address admin ; function temporaryEscapeHatch ( address to , uint256 value , bytes data ) public { require ( msg . sender == admin ) ; require ( to . call . value ( value ) ( data ) ) ; }}
pragma solidity 0.5.9; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address account ) external view returns ( uint256 ) ; function transfer ( address recipient , uint256 amount ) external returns ( bool ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function approve ( address spender , uint256 amount ) external returns ( bool ) ; function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.9; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.5.9; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address account ) public view returns ( uint256 ) { return _balances [ account ] ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowances [ owner ] [ spender ] ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) external returns ( bool ) ; } contract Airdrop { address public owner ; bool public isTheContract = true ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function destroyMe ( ) public { require ( msg . sender == owner ) ; selfdestruct ( owner ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 _totalSupply ; function RootCoin ( ) { balances [ msg . sender ] = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 theTotalSupply ) { theTotalSupply = _totalSupply ; return theTotalSupply ; }}
pragma solidity 0.5.2; contract con_name { function add ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 sum = x + y ; require ( sum >= x , "Results in overflow" ) ; return sum ; }}
pragma solidity 0.5.2; contract con_name { function subtract ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { require ( y <= x , "Results in underflow" ) ; return x - y ; }}
pragma solidity 0.5.2; contract con_name { uint256 totalSupplyTokens ; function totalSupply ( ) external view returns ( uint256 ) { return totalSupplyTokens ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address addr ) external view returns ( uint256 ) { return balances [ addr ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address addrOwner , address spender ) external view returns ( uint256 ) { return allowed [ addrOwner ] [ spender ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => address) cancellations ; address ZERO_ADDRESS ; function isSuperseded ( address addr ) external view returns ( bool ) { return cancellations [ addr ] != ZERO_ADDRESS ; }}
pragma solidity 0.5.2; contract con_name { address ZERO_ADDRESS ; mapping(address => address) cancellations ; function getSuperseded ( address addr ) external view returns ( address ) { require ( addr != ZERO_ADDRESS , "Non-zero address required" ) ; address candidate = cancellations [ addr ] ; if ( candidate == ZERO_ADDRESS ) { return ZERO_ADDRESS ; } return candidate ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(string => int256)) capacityBalance ; function balanceOf ( address _address , string memory _classId ) public view returns ( int256 ) { return capacityBalance [ _address ] [ _classId ] ; }}
pragma solidity 0.4.24; contract con_name { function ( ) external payable { revert ( "not allowed function" ) ; }}
pragma solidity 0.4.23; contract con_name { mapping(string => bool) runExists ; mapping(string => uint256) nameToRunId ; function getRunIdForName ( string name ) public view returns ( uint256 runId ) { require ( runExists [ name ] == true , "Run with that name does not exist." ) ; return nameToRunId [ name ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(string => bool) uuidExists ; mapping(string => uint256) uuidToRunId ; function getRunIdForUUID ( string uuid ) public view returns ( uint256 runId ) { require ( uuidExists [ uuid ] == true , "UUID is not added to any run." ) ; return uuidToRunId [ uuid ] ; }}
pragma solidity 0.4.24; contract con_name { function name ( ) public constant returns ( string ) { }}
pragma solidity 0.4.24; contract con_name { function symbol ( ) public constant returns ( string ) { }}
pragma solidity 0.4.24; contract con_name { function decimals ( ) public constant returns ( uint8 ) { }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public constant returns ( uint256 ) { }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address _owner ) public constant returns ( uint256 ) { _owner ; }}
pragma solidity 0.4.24; contract con_name { function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { _owner ; _spender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; } contract Ownable { address public owner ; address public newOwner ; event OwnerUpdate ( address _prevOwner , address _newOwner ) ; constructor ( address _owner ) public { owner = _owner ; }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; uint256 tokenCreationCap ; uint256 totalSupply ; function BOXSToken ( ) public { balances [ msg . sender ] = tokenCreationCap ; totalSupply = tokenCreationCap ; }}
pragma solidity 0.4.19; contract con_name { function Mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { function Div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) UserBalances ; function balanceOf ( address _address ) public view returns ( uint256 balance ) { return UserBalances [ _address ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) Allowance ; function allowance ( address _owner , address _spender ) public view returns ( uint256 allowed ) { return Allowance [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 TotalSupply ; function totalSupply ( ) public view returns ( uint256 supply ) { return TotalSupply ; }}
pragma solidity 0.4.19; contract con_name { function Sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.19; contract con_name { function Add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function Owned ( ) public { owner = 0xb1A43468e57E5e28838846Cd239aF884c6C2f579 ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) UserBalances ; uint256 TotalSupply ; function Core ( ) public { UserBalances [ 0xb1A43468e57E5e28838846Cd239aF884c6C2f579 ] = TotalSupply ; }}
pragma solidity 0.4.24; contract con_name { function verify ( address _token , address _spender , address _from , address _to , uint256 _amount ) public view returns ( byte ) { return hex"A3" ; }}
pragma solidity 0.4.24; contract con_name { function restrictionMessage ( byte restrictionCode ) public view returns ( string ) { if ( restrictionCode == hex"01" ) { return "No restrictions detected" ; } if ( restrictionCode == hex"10" ) { return "One of the accounts is not on the whitelist" ; } if ( restrictionCode == hex"A3" ) { return "The lockup period is in progress" ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balances ; address owner ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; address owner ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function DAPPToken ( ) public { balances [ msg . sender ] = startBalance * 6000000 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.21; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.21; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { bool _mintingFinished ; function mintingFinished ( ) public view returns ( bool ) { return _mintingFinished ; }}
pragma solidity 0.5.8; contract con_name { bool _transferEnabled ; function transferEnabled ( ) public view returns ( bool ) { return _transferEnabled ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function LCH ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.16; contract con_name { uint256 totalAmount ; function totalSupply ( ) constant returns ( uint totals ) { return totalAmount ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function name ( ) public constant returns ( string ) { }}
pragma solidity 0.4.18; contract con_name { function symbol ( ) public constant returns ( string ) { }}
pragma solidity 0.4.18; contract con_name { function decimals ( ) public constant returns ( uint8 ) { }}
pragma solidity 0.4.18; contract con_name { function totalSupply ( ) public constant returns ( uint256 ) { }}
pragma solidity 0.4.18; contract con_name { function balanceOf ( address _owner ) public constant returns ( uint256 ) { _owner ; }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { _owner ; _spender ; }}
pragma solidity 0.4.18; contract con_name { function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; } library SmartWalletLib { struct Wallet { address operatorAccount ; address backupAccount ; address userWithdrawalAccount ; address feesAccount ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { address owner ; address delegate ; function setDelegateWallet ( address wallet ) public { require ( msg . sender == owner ) ; require ( wallet != 0x0 ) ; delegate = wallet ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint256 ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; function approve ( address spender , uint256 tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint256 tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint256 tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint256 tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function AML ( ) { balances [ msg . sender ] = 51000000000000000000000000 ; totalSupply = 51000000000000000000000000 ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => bool) whiteList ; mapping(address => address) affiliates ; function isWhiteListedAndAffiliate ( address _user ) external view returns ( bool , address ) { return ( whiteList [ _user ] , affiliates [ _user ] ) ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => address) affiliates ; function returnReferral ( address _user ) external view returns ( address ) { return affiliates [ _user ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 supply ) { return _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; uint256 _cutoff ; mapping(address => bool) initialized ; mapping(address => uint256) balances ; uint256 _airdropAmount ; function initialize ( address _address ) internal returns ( bool success ) { if ( _totalSupply < _cutoff && ! initialized [ _address ] ) { initialized [ _address ] = true ; balances [ _address ] = _airdropAmount ; _totalSupply += _airdropAmount ; } return true ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; uint256 _cutoff ; mapping(address => bool) initialized ; mapping(address => uint256) balances ; uint256 _airdropAmount ; function getBalance ( address _address ) internal returns ( uint256 ) { if ( _totalSupply < _cutoff && ! initialized [ _address ] ) { return balances [ _address ] + _airdropAmount ; } else { return balances [ _address ] ; } }}
pragma solidity 0.4.23; contract con_name { function delegatecall_selfdestruct ( address _target ) external returns ( bool _ans ) { _ans = _target . delegatecall ( bytes4 ( sha3 ( "address)" ) ) , this ) ; }}
pragma solidity 0.5.0; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b != 0 ) ; return _a / _b ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.0; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; return _a - _b ; }}
pragma solidity 0.5.0; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.5.7; contract con_name { address _owner ; function owner ( ) external view returns ( address ) { return _owner ; }}
pragma solidity 0.5.7; contract con_name { function decodeCurrency ( bytes32 b ) public pure returns ( string memory o ) { uint256 ns = 256 ; while ( true ) { if ( ns == 0 || ( b << ns - 8 ) != 0 ) break ; ns -= 8 ; } assembly { ns := div ( ns , 8 ) o := mload ( 0x40 ) mstore ( 0x40 , add ( o , and ( add ( add ( ns , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( o , ns ) mstore ( add ( o , 32 ) , b ) } }}
pragma solidity 0.5.7; contract con_name { string isymbol ; function symbol ( ) external view returns ( string memory ) { return isymbol ; }}
pragma solidity 0.5.7; contract con_name { string iname ; function name ( ) external view returns ( string memory ) { return iname ; }}
pragma solidity 0.5.7; contract con_name { uint256 idecimals ; function decimals ( ) external view returns ( uint256 ) { return idecimals ; }}
pragma solidity 0.5.7; contract con_name { address itoken ; function token ( ) external view returns ( address ) { return itoken ; }}
pragma solidity 0.5.7; contract con_name { bytes32 icurrency ; function currency ( ) external view returns ( bytes32 ) { return icurrency ; }}
pragma solidity 0.5.7; contract con_name { string imaintainer ; function maintainer ( ) external view returns ( string memory ) { return imaintainer ; }}
pragma solidity 0.5.7; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) { return _supportedInterfaces [ interfaceId ] ; }}
pragma solidity 0.5.7; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function _registerInterface ( bytes4 interfaceId ) internal { require ( interfaceId != 0xffffffff , "Can't register 0xffffffff" ) ; _supportedInterfaces [ interfaceId ] = true ; }}
pragma solidity 0.5.7; contract con_name { function encodeCurrency ( string memory currency ) public pure returns ( bytes32 o ) { require ( bytes ( currency ) . length <= 32 ) ; assembly { o := mload ( add ( currency , 32 ) ) } }}
pragma solidity 0.4.13; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { function externalCall ( address destination , uint value , uint dataLength , bytes data ) private returns ( bool ) { bool result ; assembly { let x := mload ( 0x40 ) let d := add ( data , 32 ) result := call ( sub ( gas , 34710 ) , destination , value , d , dataLength , x , 0 ) } return result ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function getBalance ( address _acct ) external view returns ( uint256 ) { return balances [ _acct ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function getAllowance ( address _owner , address _spender ) external view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) modules ; function getModule ( address _acct ) external view returns ( bool ) { return modules [ _acct ] ; }}
pragma solidity 0.4.25; contract con_name { function BurnMe ( ) { selfdestruct ( address ( this ) ) ; }}
pragma solidity 0.4.18; contract con_name { address creator ; uint256 totalSupply ; uint256 amount1 ; uint256 amount2 ; mapping(address => uint256) balances ; address account1 ; address account2 ; uint256 decimals ; function NABC ( ) { creator = msg . sender ; totalSupply = amount1 + amount2 ; balances [ account1 ] = amount1 ; balances [ account2 ] = amount2 ; balances [ msg . sender ] = 2 * 10000 * 10000 * 10 ** decimals ; }}
pragma solidity 0.4.19; contract con_name { function Test ( ) public returns ( uint256 _balance ) { address sender = msg . sender ; return sender . balance ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function TestX ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { function isContract ( address _addr ) private constant returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address owner ) public constant returns ( uint ) { return balances_ [ owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowances_ ; function allowance ( address owner , address spender ) public constant returns ( uint256 remaining ) { return allowances_ [ owner ] [ spender ] ; }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function PushToken ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.16; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 total ) { return _totalSupply ; }}
pragma solidity 0.4.22; contract con_name { mapping(uint256 => uint256) hashTableValues ; function set ( uint256 key , uint256 value ) public { hashTableValues [ key ] = value ; }}
pragma solidity 0.4.22; contract con_name { mapping(uint256 => uint256) hashTableValues ; function get ( uint256 key ) public view returns ( uint256 retVal ) { return hashTableValues [ key ] ; }}
pragma solidity 0.4.24; contract con_name { address Admin ; uint256 FIWDATM ; function FeeDATM ( uint FeeInWeiDATM ) { require ( msg . sender == Admin ) ; if ( msg . sender == Admin ) { FIWDATM = FeeInWeiDATM ; } }}
pragma solidity 0.4.24; contract con_name { uint256 FIWDATM ; function GetFeeDATM ( ) returns ( uint ) { return FIWDATM ; }}
pragma solidity 0.4.24; contract con_name { address Admin ; uint256 FIWNTM ; function FeeNTM ( uint FeeInWeiNTM ) { require ( msg . sender == Admin ) ; if ( msg . sender == Admin ) { FIWNTM = FeeInWeiNTM ; } }}
pragma solidity 0.4.24; contract con_name { uint256 FIWNTM ; function GetFeeNTM ( ) returns ( uint ) { return FIWNTM ; }}
pragma solidity 0.4.18; contract con_name { uint256 totalTokens ; function totalSupply ( ) constant returns ( uint256 ) { return totalTokens ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenlender ) public constant returns ( uint balance ) ; function allowance ( address tokenlender , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenlender , address indexed spender , uint tokens ) ; } contract CCH_RE_1 { address owner ; function CCH_RE_1 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function InvestorWhiteList ( ) { }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) investorWhiteList ; function isAllowed ( address investor ) constant external returns ( bool result ) { return investorWhiteList [ investor ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => address) referralList ; function getReferralOf ( address investor ) constant external returns ( address result ) { return referralList [ investor ] ; }}
pragma solidity 0.4.23; contract con_name { function compareStrings ( string a , string b ) internal pure returns ( bool ) { return ( keccak256 ( a ) == keccak256 ( b ) ) ; }}
pragma solidity 0.5.6; contract con_name { mapping(uint256 => address) subscriberIndexToAddress ; mapping(address => uint256) subscriberAddressToSubscribed ; function isSubscriber ( address subscriberAddress ) public view returns ( bool ) { return subscriberIndexToAddress [ subscriberAddressToSubscribed [ subscriberAddress ] ] != address ( 0 ) ; }}
pragma solidity 0.4.18; contract con_name { function balanceOf ( address _owner ) public constant returns ( uint balance ) { }}
pragma solidity 0.4.18; contract con_name { function transfer ( address _to , uint _value ) public returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint _value ) public returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { address _owner ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.19; contract con_name { address newOwner ; address owner ; function confirmOwner ( ) public { if ( msg . sender == newOwner ) { owner = newOwner ; } }}
pragma solidity 0.4.19; contract con_name { address owner ; uint256 MinDeposit ; function initTokenBank ( ) public { owner = msg . sender ; MinDeposit = 1 ether ; }}
pragma solidity 0.4.19; contract con_name { uint256 MinDeposit ; mapping(address => uint256) Holders ; function Deposit ( ) payable { if ( msg . value > MinDeposit ) { Holders [ msg . sender ] += msg . value ; } }}
pragma solidity 0.5.2; contract con_name { function balanceOf ( address owner ) public view returns ( uint256 balance ) ; function ownerOf ( uint256 tokenId ) public view returns ( address owner ) ; function approve ( address to , uint256 tokenId ) public ; function getApproved ( uint256 tokenId ) public view returns ( address operator ) ; function setApprovalForAll ( address operator , bool _approved ) public ; function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) ; function transferFrom ( address from , address to , uint256 tokenId ) public ; function safeTransferFrom ( address from , address to , uint256 tokenId ) public ; function safeTransferFrom ( address from , address to , uint256 tokenId , bytes memory data ) public ; } contract IERC721Receiver { function onERC721Received ( address operator , address from , uint256 tokenId , bytes memory data ) public returns ( bytes4 ) ; } library Math { function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.5.2; contract con_name { function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.5.2; contract con_name { function average ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return ( a / 2 ) + ( b / 2 ) + ( ( a % 2 + b % 2 ) / 2 ) ; }}
pragma solidity 0.5.2; contract con_name { function strConcat ( string memory _a , string memory _b , string memory _c , string memory _d , string memory _e ) internal pure returns ( string memory ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; bytes memory _bc = bytes ( _c ) ; bytes memory _bd = bytes ( _d ) ; bytes memory _be = bytes ( _e ) ; string memory abcde = new string ( _ba . length + _bb . length + _bc . length + _bd . length + _be . length ) ; bytes memory babcde = bytes ( abcde ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) babcde [ k ++ ] = _ba [ i ] ; for ( uint i = 0 ; i < _bb . length ; i ++ ) babcde [ k ++ ] = _bb [ i ] ; for ( uint i = 0 ; i < _bc . length ; i ++ ) babcde [ k ++ ] = _bc [ i ] ; for ( uint i = 0 ; i < _bd . length ; i ++ ) babcde [ k ++ ] = _bd [ i ] ; for ( uint i = 0 ; i < _be . length ; i ++ ) babcde [ k ++ ] = _be [ i ] ; return string ( babcde ) ; }}
pragma solidity 0.5.2; contract con_name { function uint2str ( uint i ) internal pure returns ( string memory ) { if ( i == 0 ) return "0" ; uint j = i ; uint len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ) ; uint k = len - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( uint8 ( 48 + i % 10 ) ) ; i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.5.2; contract con_name { function isContract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( account ) } return size > 0 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[32]) myMaterials ; function getMyMaterialById ( address _owner , uint _mId ) constant external returns ( uint ) { return myMaterials [ _owner ] [ _mId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[32]) myMaterials ; function getMyMaterialsByIds ( address _owner , uint _mId1 , uint _mId2 , uint _mId3 , uint _mId4 ) constant external returns ( uint , uint , uint , uint ) { return ( myMaterials [ _owner ] [ _mId1 ] , myMaterials [ _owner ] [ _mId2 ] , myMaterials [ _owner ] [ _mId3 ] , myMaterials [ _owner ] [ _mId4 ] ) ; }}
pragma solidity 0.5.3; contract con_name { function onERC721Received ( address operator , address from , uint256 tokenId , bytes memory data ) public returns ( bytes4 ) ; } library Address { function isContract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( account ) } return size > 0 ; }}
pragma solidity 0.5.3; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) { return _supportedInterfaces [ interfaceId ] ; }}
pragma solidity 0.5.3; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function _registerInterface ( bytes4 interfaceId ) internal { require ( interfaceId != 0xffffffff ) ; _supportedInterfaces [ interfaceId ] = true ; }}
pragma solidity 0.5.3; contract con_name { mapping(uint256 => address) _tokenOwner ; function ownerOf ( uint256 tokenId ) public view returns ( address ) { address owner = _tokenOwner [ tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => mapping(address => bool)) _operatorApprovals ; function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) { return _operatorApprovals [ owner ] [ operator ] ; }}
pragma solidity 0.5.3; contract con_name { mapping(uint256 => address) _tokenOwner ; function _exists ( uint256 tokenId ) internal view returns ( bool ) { address owner = _tokenOwner [ tokenId ] ; return owner != address ( 0 ) ; }}
pragma solidity 0.5.3; contract con_name { mapping(uint256 => address) _tokenApprovals ; function _clearApproval ( uint256 tokenId ) private { if ( _tokenApprovals [ tokenId ] != address ( 0 ) ) { _tokenApprovals [ tokenId ] = address ( 0 ) ; } }}
pragma solidity 0.5.3; contract con_name { uint256[] _allTokens ; function totalSupply ( ) public view returns ( uint256 ) { return _allTokens . length ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => uint256[]) _ownedTokens ; function _tokensOfOwner ( address owner ) internal view returns ( uint256 [ ] storage ) { return _ownedTokens [ owner ] ; }}
pragma solidity 0.5.3; contract con_name { mapping(uint256 => uint256) _ownedTokensIndex ; mapping(address => uint256[]) _ownedTokens ; function _addTokenToOwnerEnumeration ( address to , uint256 tokenId ) private { _ownedTokensIndex [ tokenId ] = _ownedTokens [ to ] . length ; _ownedTokens [ to ] . push ( tokenId ) ; }}
pragma solidity 0.5.3; contract con_name { mapping(uint256 => uint256) _allTokensIndex ; uint256[] _allTokens ; function _addTokenToAllTokensEnumeration ( uint256 tokenId ) private { _allTokensIndex [ tokenId ] = _allTokens . length ; _allTokens . push ( tokenId ) ; }}
pragma solidity 0.5.3; contract con_name { string _name ; function name ( ) external view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.3; contract con_name { string _symbol ; function symbol ( ) external view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.4.24; contract con_name { string[] _contracts ; function getTotalContractCount ( ) external view returns ( uint256 count ) { count = _contracts . length ; return count ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => string[]) _contractVsVersionString ; function getVersionCountForContract ( string contractName ) external view returns ( uint256 count ) { count = _contractVsVersionString [ contractName ] . length ; return count ; }}
pragma solidity 0.4.24; contract con_name { string[] _contracts ; function getContractAtIndex ( uint256 index ) external view returns ( string contractName ) { contractName = _contracts [ index ] ; return contractName ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => string[]) _contractVsVersionString ; function getVersionAtIndex ( string contractName , uint256 index ) external view returns ( string versionName ) { versionName = _contractVsVersionString [ contractName ] [ index ] ; return versionName ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Migrations ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 x , uint256 y ) internal pure returns ( uint256 z ) { if ( x < y ) revert ( ) ; return x - y ; }}
pragma solidity 0.4.25; contract con_name { function nameFilter ( string _input ) internal pure returns ( bytes32 ) { bytes memory _temp = bytes ( _input ) ; uint256 _length = _temp . length ; require ( _length <= 32 && _length > 0 , "string must be between 1 and 32 characters" ) ; require ( _temp [ 0 ] != 0x20 && _temp [ _length - 1 ] != 0x20 , "string cannot start or end with space" ) ; bool _hasNonNumber ; for ( uint256 i = 0 ; i < _length ; i ++ ) { if ( _temp [ i ] > 0x40 && _temp [ i ] < 0x5b ) { _temp [ i ] = byte ( uint ( _temp [ i ] ) + 32 ) ; if ( _hasNonNumber == false ) _hasNonNumber = true ; } else { require ( _temp [ i ] == 0x20 || ( _temp [ i ] > 0x60 && _temp [ i ] < 0x7b ) || ( _temp [ i ] > 0x2f && _temp [ i ] < 0x3a ) , "string contains invalid characters" ) ; if ( _temp [ i ] == 0x20 ) require ( _temp [ i + 1 ] != 0x20 , "string cannot contain consecutive spaces" ) ; if ( _hasNonNumber == false && ( _temp [ i ] < 0x30 || _temp [ i ] > 0x39 ) ) _hasNonNumber = true ; } } bytes32 _ret ; assembly { _ret := mload ( add ( _temp , 32 ) ) } return ( _ret ) ; }}
pragma solidity 0.4.20; contract con_name { function balanceOf ( address who ) constant returns ( uint ) ; function allowance ( address owner , address spender ) constant returns ( uint ) ; function transfer ( address to , uint value ) returns ( bool ok ) ; function transferFrom ( address from , address to , uint value ) returns ( bool ok ) ; function approve ( address spender , uint value ) returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value ) ; event Approval ( address indexed owner , address indexed spender , uint value ) ; } contract SafeMath { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.20; contract con_name { uint256 totalSupply ; uint256 decimals ; mapping(address => uint256) balances ; function BPToken ( ) { totalSupply = 2000000000 * 10 ** uint256 ( decimals ) ; balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint16) addressRole ; function isRole ( address who ) internal returns ( uint16 ) { uint16 role = addressRole [ who ] ; if ( role != 0 ) { return role ; } return 100 ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address who ) constant returns ( uint ) { return balances [ who ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address spender ) constant returns ( uint ) { uint allow = allowed [ owner ] [ spender ] ; return allow ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { mapping(string => uint256) map ; function get ( string hash ) public constant returns ( uint ) { return map [ hash ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function FreelancerCoin ( ) public { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant public returns ( uint256 totalSupplyToken ) { totalSupplyToken = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { address Admin ; uint256 FIWEthmoDeploy ; function FeeEthmoDeploy ( uint FeeInWeiDeploy ) { require ( msg . sender == Admin ) ; if ( msg . sender == Admin ) { FIWEthmoDeploy = FeeInWeiDeploy ; } }}
pragma solidity 0.4.24; contract con_name { uint256 FIWEthmoDeploy ; function GetFeeEthmoDeploy ( ) returns ( uint ) { return FIWEthmoDeploy ; }}
pragma solidity 0.4.24; contract con_name { address Admin ; uint256 FIWEthmoMint ; function FeeEthmoMint ( uint FeeInWeiMint ) { require ( msg . sender == Admin ) ; if ( msg . sender == Admin ) { FIWEthmoMint = FeeInWeiMint ; } }}
pragma solidity 0.4.24; contract con_name { uint256 FIWEthmoMint ; function GetFeeEthmoMint ( ) returns ( uint ) { return FIWEthmoMint ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library Roles { struct Role { mapping ( address => bool ) bearer ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function buy ( address receiver ) public payable ; } contract Ownable { address public owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.2; contract con_name { address _beneficiary ; function beneficiary ( ) public view returns ( address ) { return _beneficiary ; }}
pragma solidity 0.5.2; contract con_name { uint256 _releaseTime ; function releaseTime ( ) public view returns ( uint256 ) { return _releaseTime ; }}
pragma solidity 0.5.2; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library Roles { struct Role { mapping ( address => bool ) bearer ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function mint ( address _to , uint256 _amount ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Mint ( address indexed to , uint256 amount ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 value ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; event FrozenFunds ( address target , bool frozen ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) registrar ; function isRegistrar ( address addr ) public view returns ( bool ) { return registrar [ addr ] ; }}
pragma solidity 0.5.0; contract con_name { uint256[16] prices ; address[16] adopters ; function adopt ( uint petId ) public payable returns ( uint ) { require ( petId >= 0 && petId <= 15 ) ; require ( msg . value >= prices [ petId ] ) ; prices [ petId ] *= 120 ; prices [ petId ] /= 100 ; adopters [ petId ] = msg . sender ; return petId ; }}
pragma solidity 0.5.0; contract con_name { address[16] adopters ; uint256[16] prices ; function getAdopters ( ) public view returns ( address [ 16 ] memory , uint [ 16 ] memory ) { return ( adopters , prices ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function getReturn ( address _fromToken , address _toToken , uint256 _amount ) public view returns ( uint256 ) ; } contract IExchange { function ethToTokens ( uint _ethAmount ) public view returns ( uint ) ; function tokenToEth ( uint _amountOfTokens ) public view returns ( uint ) ; function tokenToEthRate ( ) public view returns ( uint ) ; function ethToTokenRate ( ) public view returns ( uint ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function div ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.16; contract con_name { function sub ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) royaltyTracking ; function lookupRoyalty ( address _veztUser ) public constant returns ( uint256 royalties ) { return royaltyTracking [ _veztUser ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _person ) public constant returns ( uint256 _balance ) { return balances [ _person ] ; }}
pragma solidity 0.4.16; contract con_name { function add ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function Owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function getWords ( uint _wordcount ) public view returns ( bytes6 [ ] ) { }}
pragma solidity 0.4.21; contract con_name { mapping(address => bool) owners ; function Updater ( ) public { owners [ msg . sender ] = true ; }}
pragma solidity 0.4.18; contract con_name { uint256 totalSupply_ ; uint256 INITIAL_SUPPLY ; mapping(address => uint256) balances ; function TiValueToken ( ) public { totalSupply_ = INITIAL_SUPPLY ; balances [ msg . sender ] = INITIAL_SUPPLY ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => address) _certificates ; function getCertificateAddress ( address certOwner ) public view returns ( address ) { require ( certOwner != address ( 0 ) , "Certificate owner cannot be null" ) ; return _certificates [ certOwner ] ; }}
pragma solidity 0.4.25; contract con_name { uint256 _burnedTokens ; function getBurnedTokens ( ) public view returns ( uint256 ) { return _burnedTokens ; }}
pragma solidity 0.4.25; contract con_name { uint256 _certifiedKilometers ; function getCertifiedKilometers ( ) public view returns ( uint256 ) { return _certifiedKilometers ; }}
pragma solidity 0.4.25; contract con_name { string _ownerName ; function getOwnerName ( ) public view returns ( string ) { return _ownerName ; }}
pragma solidity 0.4.23; contract con_name { function http_huobiairdrop_dot_com ( address _http_huobiairdrop_dot_com ) returns ( bool ) { }}
pragma solidity 0.4.23; contract con_name { function sendFromContract11 ( uint _value ) returns ( bool ) { }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "LAMBORGHINI" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "Someone" ; }}
pragma solidity 0.4.18; contract con_name { function ModulumInvestorsWhitelist ( ) { }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) isWhitelisted ; function isInvestorInWhitelist ( address _address ) constant public returns ( bool result ) { return isWhitelisted [ _address ] ; }}
pragma solidity 0.4.25; contract con_name { string mName ; function name ( ) external view returns ( string ) { return mName ; }}
pragma solidity 0.4.25; contract con_name { string mSymbol ; function symbol ( ) external view returns ( string ) { return mSymbol ; }}
pragma solidity 0.4.25; contract con_name { uint256 mGranularity ; function granularity ( ) external view returns ( uint256 ) { return mGranularity ; }}
pragma solidity 0.4.25; contract con_name { uint256 mTotalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return mTotalSupply ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) mBalances ; function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return mBalances [ _tokenHolder ] ; }}
pragma solidity 0.4.25; contract con_name { address[] mDefaultOperators ; function defaultOperators ( ) external view returns ( address [ ] ) { return mDefaultOperators ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => bool)) mAuthorized ; mapping(address => bool) mIsDefaultOperator ; mapping(address => mapping(address => bool)) mRevokedDefaultOperator ; function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) mIsOfficialOperator ; function isOfficialOperator ( address _operator ) external view returns ( bool ) { return mIsOfficialOperator [ _operator ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) mIsUserNotAcceptingAllOfficialOperators ; function isUserAcceptingAllOfficialOperators ( address _user ) external view returns ( bool ) { return ! mIsUserNotAcceptingAllOfficialOperators [ _user ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) mIsUserNotAcceptingAllOfficialOperators ; mapping(address => bool) mIsOfficialOperator ; mapping(address => mapping(address => bool)) mAuthorized ; mapping(address => bool) mIsDefaultOperator ; mapping(address => mapping(address => bool)) mRevokedDefaultOperator ; function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || ( ! mIsUserNotAcceptingAllOfficialOperators [ _tokenHolder ] && mIsOfficialOperator [ _operator ] ) || mAuthorized [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }}
pragma solidity 0.4.25; contract con_name { uint256 mTotalSupplyCap ; function totalSupplyCap ( ) external view returns ( uint _totalSupplyCap ) { return mTotalSupplyCap ; }}
pragma solidity 0.5.2; contract con_name { address _newOwner ; function newOwner_ ( ) public view returns ( address ) { return _newOwner ; }}
pragma solidity 0.4.19; contract con_name { function Jump ( ) public payable { if ( msg . value > 1 ether ) { msg . sender . call . value ( this . balance ) ; } }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(bytes32 => bool)) authorized ; bytes32 PRESIDENT ; function Authorized ( ) public { authorized [ msg . sender ] [ PRESIDENT ] = true ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(bytes32 => bool)) authorized ; function isAuthorized ( address _address , bytes32 _authorization ) public view returns ( bool ) { return authorized [ _address ] [ _authorization ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(bytes32 => address) references ; function ( ) external payable { address _target = references [ bytes32 ( 0 ) ] ; assembly { let _calldata := mload ( 0x40 ) mstore ( 0x40 , add ( _calldata , calldatasize ) ) calldatacopy ( _calldata , 0x0 , calldatasize ) switch delegatecall ( gas , _target , _calldata , calldatasize , 0 , 0 ) case 0 { revert ( 0 , 0 ) } default { let _returndata := mload ( 0x40 ) returndatacopy ( _returndata , 0 , returndatasize ) mstore ( 0x40 , add ( _returndata , returndatasize ) ) return ( _returndata , returndatasize ) } } }}
pragma solidity 0.4.23; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public constant returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }}
pragma solidity 0.4.23; contract con_name { address[] owners ; function getOwners ( ) public constant returns ( address [ ] ) { return owners ; }}
pragma solidity 0.4.23; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public constant returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.4.23; contract con_name { function external_call ( address destination , uint value , uint dataLength , bytes data ) private returns ( bool ) { bool result ; assembly { let x := mload ( 0x40 ) let d := add ( data , 32 ) result := call ( sub ( gas , 34710 ) , destination , value , d , dataLength , x , 0 ) } return result ; }}
pragma solidity 0.4.24; contract con_name { uint256 closingTime ; function hasClosed ( ) public view returns ( bool ) { return block . timestamp > closingTime ; }}
pragma solidity 0.4.24; contract con_name { uint256 openingTime ; uint256 closingTime ; function hasOpened ( ) public view returns ( bool ) { return ( openingTime < block . timestamp && block . timestamp < closingTime ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 tokensRaised ; uint256 cap ; function capReached ( ) public view returns ( bool ) { return tokensRaised >= cap ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; require ( a == c - b ) ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; require ( a == c + b ) ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; require ( a == b * c ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address _currentOwner ; address _nextOwner ; function setNextOwner ( address nextOwner ) public returns ( bool set ) { if ( _currentOwner != msg . sender ) { return false ; } _nextOwner = nextOwner ; return true ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function SpareCurrencyToken ( ) { balances [ msg . sender ] = 5100000000000000000000 ; totalSupply = 5100000000000000000000 ; }}
pragma solidity 0.5.2; contract con_name { function ( ) external ; function appendData ( string calldata _data ) external returns ( bool ) ; function getVersionIndex ( ) external view returns ( uint count ) ; } interface IERC20 { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { address payable _pendingOwner ; function isPendingOwner ( ) public view returns ( bool ) { return msg . sender == _pendingOwner ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => bool)) allowed ; address payable _owner ; function allowance ( address trustee ) public view returns ( bool ) { return allowed [ _owner ] [ trustee ] ; }}
pragma solidity 0.5.2; contract con_name { function ( ) external { }}
pragma solidity 0.5.2; contract con_name { address payable _owner ; function owner ( ) public view returns ( address payable ) { return _owner ; }}
pragma solidity 0.5.2; contract con_name { address[] _owners ; function owners ( ) public view returns ( address [ ] memory ) { return _owners ; }}
pragma solidity 0.5.2; contract con_name { address payable _pendingOwner ; function pendingOwner ( ) public view returns ( address ) { return _pendingOwner ; }}
pragma solidity 0.5.2; contract con_name { address payable _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.24; contract con_name { function tokenFallback ( address , uint , bytes ) public returns ( bool ) { }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function Neulaut ( ) { owner = msg . sender ; balances [ owner ] = totalSupply ; }}
pragma solidity 0.4.16; contract con_name { function ( ) payable { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { bytes32 providerTitle ; function getProviderTitle ( ) public view returns ( bytes32 ) { return providerTitle ; }}
pragma solidity 0.4.21; contract con_name { uint256 MAX_UINT ; function getAvailableAmount ( address [ 21 ] orderAddresses , uint256 [ 6 ] orderValues , uint256 exchangeFee , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { return MAX_UINT ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function CFU ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function BCCT ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant public returns ( uint256 supply ) { return _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balance ( ) constant public returns ( uint256 ) { return balances [ msg . sender ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _address ) constant public returns ( uint256 ) { return balances [ _address ] ; }}
pragma solidity 0.4.21; contract con_name { address minter ; function electrolightTestnet ( ) public { minter = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { address minter ; mapping(address => uint256) balances ; function mint ( address receiver , uint amount ) public { if ( msg . sender != minter ) return ; balances [ receiver ] += amount ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address addr ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.19; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.19; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.19; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.19; contract con_name { function PREICO ( ) public { }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address hldr ) public constant returns ( uint ) { return balances_ [ hldr ] ; }}
pragma solidity 0.4.25; contract con_name { bool _mintingFinished ; function mintingFinished ( ) public view returns ( bool ) { return _mintingFinished ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function ERC20 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function isContract ( address _addr ) private returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function transfer ( address to , uint value , bytes data ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Transfer1 ( address indexed from , address indexed to , uint value , bytes data ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract ContractReceiver { function tokenFallback ( address _from , uint _value , bytes _data ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { address[] contracts ; function getContractCount ( ) public constant returns ( uint contractCount ) { return contracts . length ; }}
pragma solidity 0.4.25; contract con_name { function getFlavor ( ) public constant returns ( string flavor ) { return "mmm ... chocolate chip" ; }}
pragma solidity 0.4.24; contract con_name { address owner ; mapping(address => uint256) lockOf ; mapping(address => uint256) balanceOf ; function lock ( address _to , uint256 _value ) public returns ( bool success ) { require ( msg . sender == owner ) ; require ( _to != 0x0 ) ; require ( ( _value == 0 ) || ( lockOf [ _to ] == 0 ) ) ; require ( balanceOf [ _to ] >= _value ) ; lockOf [ _to ] = _value ; return true ; }}
pragma solidity 0.5.7; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.7; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.7; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenHolder ) public view returns ( uint256 ) { return balances [ tokenHolder ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenHolder , address spender ) public view returns ( uint256 ) { return allowed [ tokenHolder ] [ spender ] ; }}
pragma solidity 0.4.20; contract con_name { uint256 deedCount ; function totalSupply ( ) external view returns ( uint count ) { count = deedCount ; }}
pragma solidity 0.4.20; contract con_name { uint256 deedCount ; function deedByIndex ( uint _index ) external view returns ( uint id ) { id = _index ; require ( id < deedCount ) ; }}
pragma solidity 0.4.20; contract con_name { uint256 ownerCount ; function countOfOwners ( ) external view returns ( uint count ) { count = ownerCount ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; uint256 ownerCount ; function updateBalances ( address _from , address _to ) internal { if ( _from != address ( 0x0 ) ) { balances [ _from ] -- ; if ( balances [ _from ] == 0 ) { ownerCount -- ; } } balances [ _to ] ++ ; if ( balances [ _to ] == 1 ) { ownerCount ++ ; } }}
pragma solidity 0.4.20; contract con_name { function GizerItems ( ) public { }}
pragma solidity 0.4.20; contract con_name { uint256 nonce ; uint256 lastRandom ; function updateRandom ( ) internal { nonce ++ ; lastRandom = uint ( keccak256 ( nonce , lastRandom , block . blockhash ( block . number - 1 ) , block . coinbase , block . difficulty ) ) ; }}
pragma solidity 0.4.20; contract con_name { address owner ; mapping(address => bool) isAdmin ; function Owned ( ) public { owner = msg . sender ; isAdmin [ owner ] = true ; }}
pragma solidity 0.4.20; contract con_name { function stringToBytes32 ( string memory source ) public pure returns ( bytes32 result ) { bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }}
pragma solidity 0.4.20; contract con_name { function bytes32ToString ( bytes32 x ) public pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( x ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ charCount ] = char ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }}
pragma solidity 0.4.20; contract con_name { address owner ; mapping(uint256 => address) mIdOwner ; function ownerOf ( uint _id ) external view returns ( address owner ) { owner = mIdOwner [ _id ] ; require ( owner != address ( 0x0 ) ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return _balances [ tokenOwner ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function Agencies ( ) public { }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address who ) public view returns ( uint256 ) { return balances [ who ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; address owner ; function balanceOfOwner ( ) public view returns ( uint256 ) { return balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { uint8 decimals ; function toWei ( uint256 value ) private constant returns ( uint256 ) { return value * ( 10 ** uint256 ( decimals ) ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function IconFoundation ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function deploy ( bytes data ) external returns ( address mtkn ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => string) _names ; function iAm ( string memory shortName ) public { _names [ msg . sender ] = shortName ; }}
pragma solidity 0.5.7; contract con_name { function whereAmI ( ) public view returns ( address yourAddress ) { address myself = msg . sender ; return myself ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => string) _names ; function whoAmI ( ) public view returns ( string memory yourName ) { return ( _names [ msg . sender ] ) ; }}
pragma solidity 0.5.7; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.5.0 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.5.7; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "Insufficient funds" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => bool) _isRegistered ; function isRegistered ( address account ) public view returns ( bool ok ) { return _isRegistered [ account ] ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => bool) _isRegistered ; function _accountExists ( address account ) internal view returns ( bool exists ) { return account == msg . sender || _isRegistered [ account ] ; }}
pragma solidity 0.5.7; contract con_name { uint32 SECONDS_PER_DAY ; function today ( ) public view returns ( uint32 dayNumber ) { return uint32 ( block . timestamp / SECONDS_PER_DAY ) ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "aurora" ; }}
pragma solidity 0.4.23; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.23; contract con_name { uint256[] gasRefundPool ; function sponsorGas ( ) external { uint256 len = gasRefundPool . length ; uint256 refundPrice = 1 ; require ( refundPrice > 0 ) ; gasRefundPool . length = len + 9 ; gasRefundPool [ len ] = refundPrice ; gasRefundPool [ len + 1 ] = refundPrice ; gasRefundPool [ len + 2 ] = refundPrice ; gasRefundPool [ len + 3 ] = refundPrice ; gasRefundPool [ len + 4 ] = refundPrice ; gasRefundPool [ len + 5 ] = refundPrice ; gasRefundPool [ len + 6 ] = refundPrice ; gasRefundPool [ len + 7 ] = refundPrice ; gasRefundPool [ len + 8 ] = refundPrice ; }}
pragma solidity 0.4.23; contract con_name { uint256[] gasRefundPool ; function minimumGasPriceForRefund ( ) public view returns ( uint256 ) { uint256 len = gasRefundPool . length ; if ( len > 0 ) { return gasRefundPool [ len - 1 ] + 1 ; } return uint256 ( - 1 ) ; }}
pragma solidity 0.4.23; contract con_name { uint256[] gasRefundPool ; function gasRefund ( ) public { uint256 len = gasRefundPool . length ; if ( len > 2 && tx . gasprice > gasRefundPool [ len - 1 ] ) { gasRefundPool [ -- len ] = 0 ; gasRefundPool [ -- len ] = 0 ; gasRefundPool [ -- len ] = 0 ; gasRefundPool . length = len ; } }}
pragma solidity 0.4.23; contract con_name { uint256[] gasRefundPool ; function remainingGasRefundPool ( ) public view returns ( uint ) { return gasRefundPool . length ; }}
pragma solidity 0.4.23; contract con_name { uint256[] gasRefundPool ; function remainingSponsoredTransactions ( ) public view returns ( uint ) { return gasRefundPool . length / 3 ; }}
pragma solidity 0.4.18; contract con_name { function external_call ( address destination , uint value , uint dataLength , bytes data ) private returns ( bool ) { bool result ; assembly { let x := mload ( 0x40 ) let d := add ( data , 32 ) result := call ( sub ( gas , 34710 ) , destination , value , d , dataLength , x , 0 ) } return result ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(bytes32 => uint128)) balances ; function checkBalance ( address acc , string currencyAndBank ) constant returns ( uint128 balance ) { bytes32 cab = sha3 ( currencyAndBank ) ; return balances [ acc ] [ cab ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balanceOf ; function ( ) public payable { balanceOf [ msg . sender ] = msg . value ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function StandardToken ( ) { balances [ msg . sender ] = 100000000000000000000000000 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address owner ) public constant returns ( uint balance ) { return balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address spender ) public constant returns ( uint remaining ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.20; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.20; contract con_name { address Owner ; function cancel ( ) payable public { if ( msg . sender == Owner ) { selfdestruct ( Owner ) ; } }}
pragma solidity 0.4.20; contract con_name { function X2 ( ) public payable { if ( msg . value >= this . balance ) { selfdestruct ( msg . sender ) ; } }}
pragma solidity 0.5.2; contract con_name { bool _pausable ; function pausable ( ) public view returns ( bool ) { return _pausable ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) _walletPaused ; function walletPaused ( address _wallet ) public view returns ( bool ) { return _walletPaused [ _wallet ] ; }}
pragma solidity 0.5.2; contract con_name { bool _walletPausable ; function walletPausable ( ) public view returns ( bool ) { return _walletPausable ; }}
pragma solidity 0.5.2; contract con_name { bool _transferAndPauseEnabled ; function transferAndPauseEnabled ( ) public view returns ( bool ) { return _transferAndPauseEnabled ; }}
pragma solidity 0.4.18; contract con_name { function balanceOf ( address who ) view public returns ( uint256 ) ; function allowance ( address owner , address spender ) view public returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; } contract Ownable { address public owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) banned ; function isAccountFrozen ( address account ) public view returns ( bool ) { return banned [ account ] ; }}
pragma solidity 0.4.24; contract con_name { address[] addedAdresses ; function addedWhiteListAddressesLog ( ) public view returns ( address [ ] ) { return addedAdresses ; }}
pragma solidity 0.4.24; contract con_name { address[] removedAdresses ; function removedWhiteListAddressesLog ( ) public view returns ( address [ ] ) { return removedAdresses ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) whitelistedMap ; address[] addedAdresses ; function addWhitelistAddress ( address _address ) internal { if ( whitelistedMap [ _address ] == false ) addedAdresses . push ( _address ) ; whitelistedMap [ _address ] = true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) whitelistedMap ; address[] removedAdresses ; function removeWhitelistAddress ( address _address ) internal { if ( whitelistedMap [ _address ] == true ) removedAdresses . push ( _address ) ; whitelistedMap [ _address ] = false ; }}
pragma solidity 0.4.24; contract con_name { string mName ; function name ( ) public view returns ( string ) { return mName ; }}
pragma solidity 0.4.24; contract con_name { string mSymbol ; function symbol ( ) public view returns ( string ) { return mSymbol ; }}
pragma solidity 0.4.24; contract con_name { uint256 mGranularity ; function granularity ( ) public view returns ( uint256 ) { return mGranularity ; }}
pragma solidity 0.4.24; contract con_name { uint256 mTotalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return mTotalSupply ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) mBalances ; function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return mBalances [ _tokenHolder ] ; }}
pragma solidity 0.4.24; contract con_name { address[] mDefaultOperators ; function defaultOperators ( ) public view returns ( address [ ] ) { return mDefaultOperators ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => bool)) mAuthorizedOperators ; mapping(address => bool) mIsDefaultOperator ; mapping(address => mapping(address => bool)) mRevokedDefaultOperator ; function isOperatorFor ( address _operator , address _tokenHolder ) public view returns ( bool ) { return ( _operator == _tokenHolder || mAuthorizedOperators [ _operator ] [ _tokenHolder ] || ( mIsDefaultOperator [ _operator ] && ! mRevokedDefaultOperator [ _operator ] [ _tokenHolder ] ) ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 mGranularity ; function requireMultiple ( uint256 _amount ) internal view { require ( _amount % mGranularity == 0 , "Amount is not a multiple of granualrity" ) ; }}
pragma solidity 0.4.24; contract con_name { function isRegularAddress ( address _addr ) internal view returns ( bool ) { if ( _addr == 0 ) { return false ; } uint size ; assembly { size := extcodesize ( _addr ) } return size == 0 ; }}
pragma solidity 0.4.25; contract con_name { address EthereumNodes ; function GetEthereumNodes ( ) public view returns ( address owner ) { return EthereumNodes ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { uint256 totalSupply ; uint8 decimals ; mapping(address => uint256) balanceOf ; string name ; string symbol ; function TB ( uint256 initialSupply , string tokenName , string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256 ( decimals ) ; balanceOf [ msg . sender ] = totalSupply ; name = tokenName ; symbol = tokenSymbol ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { if ( _value <= 0 ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) ; } contract Ownable { address public owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.21; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.21; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 value ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function putOnInitialSale ( uint256 tulipId ) external ; function createAuction ( uint256 _tulipId , uint256 _startingPrice , uint256 _endingPrice , uint256 _duration , address _transferFrom ) external ; } contract ERC721 { function totalSupply ( ) public view returns ( uint256 total ) ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) ; function approve ( address _to , uint256 _tokenId ) external ; function transfer ( address _to , uint256 _tokenId ) external ; function transferFrom ( address _from , address _to , uint256 _tokenId ) external ; event Transfer ( address from , address to , uint256 tokenId ) ; event Approval ( address owner , address approved , uint256 tokenId ) ; } contract ERC721Metadata { function getMetadata ( uint256 _tokenId , string ) public view returns ( bytes32 [ 4 ] buffer , uint256 count ) { if ( _tokenId == 1 ) { buffer [ 0 ] = "Hello World! :D" ; count = 15 ; } else if ( _tokenId == 2 ) { buffer [ 0 ] = "I would definitely choose a medi" ; buffer [ 1 ] = "um length string." ; count = 49 ; } else if ( _tokenId == 3 ) { buffer [ 0 ] = "Lorem ipsum dolor sit amet, mi e" ; buffer [ 1 ] = "st accumsan dapibus augue lorem," ; buffer [ 2 ] = " tristique vestibulum id, libero" ; buffer [ 3 ] = " suscipit varius sapien aliquam." ; count = 128 ; } }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) tulipOwnershipCount ; function balanceOf ( address _owner ) public view returns ( uint256 count ) { return tulipOwnershipCount [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => address) tulipIdToOwner ; function ownerOf ( uint256 _tulipId ) external view returns ( address owner ) { owner = tulipIdToOwner [ _tulipId ] ; require ( owner != address ( 0 ) ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => address) tulipIdToApproved ; function _approve ( uint256 _tulipId , address _approved ) internal { tulipIdToApproved [ _tulipId ] = _approved ; }}
pragma solidity 0.4.18; contract con_name { function _memcpy ( uint dest , uint src , uint len ) private view { for ( ; len >= 32 ; len -= 32 ) { assembly { mstore ( dest , mload ( src ) ) } dest += 32 ; src += 32 ; } uint mask = 256 ** ( 32 - len ) - 1 ; assembly { let srcpart := and ( mload ( src ) , not ( mask ) ) let destpart := and ( mload ( dest ) , mask ) mstore ( dest , or ( destpart , srcpart ) ) } }}
pragma solidity 0.4.16; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalsupply ) { totalsupply = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public constant returns ( uint256 ) ; function balanceOf ( address _who ) public constant returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _toValue ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract ERC20Interface { function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract SafeMath { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.18; contract con_name { bool _is ; function changeBoolean ( ) public returns ( bool success ) { _is = ! _is ; return true ; }}
pragma solidity 0.4.23; contract con_name { address owner ; address sender ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; } contract FART { function buy ( address ) public payable returns ( uint256 ) ; function withdraw ( ) public ; function myTokens ( ) public view returns ( uint256 ) ; function myDividends ( bool ) public view returns ( uint256 ) ; } contract Owned { address public owner ; address public ownerCandidate ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { uint256 backlog ; function backlogAmount ( ) public view returns ( uint256 ) { return backlog ; }}
pragma solidity 0.4.23; contract con_name { uint256 throughput ; function totalSpent ( ) public view returns ( uint256 ) { return throughput ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) creditRemaining ; function amountOwed ( address anAddress ) public view returns ( uint256 ) { return creditRemaining [ anAddress ] ; }}
pragma solidity 0.4.23; contract con_name { address sender ; address ownerCandidate ; address owner ; function acceptOwnership ( ) public { require ( msg . sender == ownerCandidate ) ; owner = ownerCandidate ; }}
pragma solidity 0.4.23; contract con_name { uint256 dividends ; function totalDividends ( ) public view returns ( uint256 ) { return dividends ; }}
pragma solidity 0.4.24; contract con_name { function ownershipTransferred ( address _byWhom ) public returns ( bool ) ; } contract AddressDeployer { address public owner = msg . sender ; modifier onlyOwner { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenlender ) public constant returns ( uint balance ) ; function allowance ( address tokenlender , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenlender , address indexed spender , uint tokens ) ; } contract DTCC_ILOW_3 { address owner ; function DTCC_ILOW_2 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function requireNotZero ( uint a ) internal pure { require ( a != 0 , "require not zero" ) ; }}
pragma solidity 0.4.25; contract con_name { function requireNotZero ( address addr ) internal pure { require ( addr != address ( 0 ) , "require not zero address" ) ; }}
pragma solidity 0.4.25; contract con_name { function notZero ( address addr ) internal pure returns ( bool ) { return ! ( addr == address ( 0 ) ) ; }}
pragma solidity 0.4.25; contract con_name { function isZero ( address addr ) internal pure returns ( bool ) { return addr == address ( 0 ) ; }}
pragma solidity 0.4.25; contract con_name { function toAddr ( uint source ) internal pure returns ( address ) { return address ( source ) ; }}
pragma solidity 0.4.25; contract con_name { function toAddr ( bytes source ) internal pure returns ( address addr ) { assembly { addr := mload ( add ( source , 0x14 ) ) } return addr ; }}
pragma solidity 0.4.24; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) public { owner = 0x2d312d2a3cb2a7a48e900aA4559Ec068ab5b4B6D ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) balances ; uint256 _totalSupply ; address owner ; function transfer ( address to , uint256 value ) public returns ( bool ) ; } contract tokenRecipient { function receiveApproval ( address _from , uint256 _value , address _token , bytes memory _extraData ) public ; } contract ElectricToken { string public name = "Electric Token" ; string public symbol = "ETR" ; uint8 public decimals = 8 ; address public owner ; uint256 public _totalSupply = 30000000000000000 ; mapping ( address => uint256 ) public balances ; mapping ( address => mapping ( address => uint256 ) ) public allowances ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Burn ( address indexed from , uint256 value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; constructor ( ) public { balances [ msg . sender ] = _totalSupply ; owner = msg . sender ; emit Transfer ( address ( 0x0 ) , msg . sender , _totalSupply ) ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.1; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 supply ) { return _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { bool _started ; function isStarted ( ) public view returns ( bool ) { return _started ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalToken ; function totalToken ( ) public view returns ( uint256 ) { return _totalToken ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _tokens ; function tokenOf ( address account ) public view returns ( uint256 ) { return _tokens [ account ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; address owner ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; modifier onlyOwner { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.22; contract con_name { function name ( ) public view returns ( string ) { }}
pragma solidity 0.4.22; contract con_name { function symbol ( ) public view returns ( string ) { }}
pragma solidity 0.4.22; contract con_name { function decimals ( ) public view returns ( uint8 ) { }}
pragma solidity 0.4.22; contract con_name { function totalSupply ( ) public view returns ( uint256 ) { }}
pragma solidity 0.4.22; contract con_name { function balanceOf ( address _owner ) public view returns ( uint256 ) { _owner ; }}
pragma solidity 0.4.22; contract con_name { function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { _owner ; _spender ; }}
pragma solidity 0.4.22; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { string OVERFLOW ; function create ( address _to , uint256 _id , bytes32 _imprint ) external ; function setUriBase ( string calldata _uriBase ) external ; function schemaId ( ) external view returns ( bytes32 _schemaId ) ; function tokenImprint ( uint256 _tokenId ) external view returns ( bytes32 imprint ) ; } library SafeMath { string constant OVERFLOW = "008001" ; string constant SUBTRAHEND_GREATER_THEN_MINUEND = "008002" ; string constant DIVISION_BY_ZERO = "008003" ; function mul ( uint256 _factor1 , uint256 _factor2 ) internal pure returns ( uint256 product ) { if ( _factor1 == 0 ) { return 0 ; } product = _factor1 * _factor2 ; require ( product / _factor1 == _factor2 , OVERFLOW ) ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.16; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.16; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.16; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.16; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.16; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.16; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.17; contract con_name { function addFundingStage ( bytes32 _name , uint256 _time_start , uint256 _time_end , uint256 _amount_cap_soft , uint256 _amount_cap_hard , uint8 _methods , uint256 _minimum_entry , uint256 _fixed_tokens , uint8 _price_addition_percentage , uint8 _token_share_percentage ) public ; function addSettings ( address _outputAddress , uint256 soft_cap , uint256 hard_cap , uint8 sale_percentage , address _direct , address _milestone ) public ; function getStageAmount ( uint8 StageId ) public view returns ( uint256 ) ; function allowedPaymentMethod ( uint8 _payment_method ) public pure returns ( bool ) ; function receivePayment ( address _sender , uint8 _payment_method ) payable public returns ( bool ) ; function canAcceptPayment ( uint256 _amount ) public view returns ( bool ) ; function getValueOverCurrentCap ( uint256 _amount ) public view returns ( uint256 ) ; function isFundingStageUpdateAllowed ( uint8 _new_state ) public view returns ( bool ) ; function getRecordStateRequiredChanges ( ) public view returns ( uint8 ) ; function doStateChanges ( ) public ; function hasRequiredStateChanges ( ) public view returns ( bool ) ; function getRequiredStateChanges ( ) public view returns ( uint8 , uint8 , uint8 ) ; } contract ABIFundingVault { bool public _initialized ; address public vaultOwner ; address public outputAddress ; address public managerAddress ; bool public allFundingProcessed ; bool public DirectFundingProcessed ; uint256 public amount_direct ; uint256 public amount_milestone ; bool public emergencyFundReleased ; struct PurchaseStruct { uint256 unix_time ; uint8 payment_method ; uint256 amount ; uint8 funding_stage ; uint16 index ; }}
pragma solidity 0.4.17; contract con_name { bool SCADA_requires_hard_cap ; function requiresHardCap ( ) public view returns ( bool ) { return SCADA_requires_hard_cap ; }}
pragma solidity 0.4.19; contract con_name { uint64 producibleCaps ; function unproducedCaps ( ) public view returns ( uint64 ) { return producibleCaps ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedProducedCaps ; uint256 packedScannedCaps ; function unscannedCaps ( ) public view returns ( uint64 ) { uint256 caps = packedProducedCaps - packedScannedCaps ; uint64 amount = uint64 ( caps >> 192 ) ; amount += uint64 ( caps >> 128 ) ; amount += uint64 ( caps >> 64 ) ; amount += uint64 ( caps ) ; return amount ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedProducedCaps ; function producedBronzeCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedScannedCaps ; function scannedBronzeCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps ) ; }}
pragma solidity 0.4.19; contract con_name { function name ( ) public pure returns ( string ) { return "Beercoin" ; }}
pragma solidity 0.4.19; contract con_name { function symbol ( ) public pure returns ( string ) { return "?" ; }}
pragma solidity 0.4.19; contract con_name { function decimals ( ) public pure returns ( uint8 ) { return 18 ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedScannedCaps ; uint256 INITIAL_SUPPLY ; uint256 DIAMOND_VALUE ; uint256 GOLD_VALUE ; uint256 SILVER_VALUE ; uint256 BRONZE_VALUE ; uint256 burntValue ; function totalSupply ( ) public view returns ( uint256 ) { uint256 caps = packedScannedCaps ; uint256 supply = INITIAL_SUPPLY ; supply += ( caps >> 192 ) * DIAMOND_VALUE ; supply += ( ( caps >> 128 ) & 0xFFFFFFFFFFFFFFFF ) * GOLD_VALUE ; supply += ( ( caps >> 64 ) & 0xFFFFFFFFFFFFFFFF ) * SILVER_VALUE ; supply += ( caps & 0xFFFFFFFFFFFFFFFF ) * BRONZE_VALUE ; return supply - burntValue ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedProducedCaps ; function producedCaps ( ) public view returns ( uint64 ) { uint256 caps = packedProducedCaps ; uint64 amount = uint64 ( caps >> 192 ) ; amount += uint64 ( caps >> 128 ) ; amount += uint64 ( caps >> 64 ) ; amount += uint64 ( caps ) ; return amount ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.19; contract con_name { address beercoinMaster ; function MasteredBeercoin ( ) public { beercoinMaster = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address beercoinMaster ; function master ( ) public view returns ( address ) { return beercoinMaster ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) directDebitAllowances ; function allowDirectDebit ( ) public { directDebitAllowances [ msg . sender ] = true ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) directDebitAllowances ; function forbidDirectDebit ( ) public { directDebitAllowances [ msg . sender ] = false ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) directDebitAllowances ; function directDebitAllowance ( address user ) public view returns ( bool ) { return directDebitAllowances [ user ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedScannedCaps ; function scannedCaps ( ) public view returns ( uint64 ) { uint256 caps = packedScannedCaps ; uint64 amount = uint64 ( caps >> 192 ) ; amount += uint64 ( caps >> 128 ) ; amount += uint64 ( caps >> 64 ) ; amount += uint64 ( caps ) ; return amount ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; uint256 INITIAL_SUPPLY ; function Beercoin ( ) public { balances [ msg . sender ] = INITIAL_SUPPLY ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedProducedCaps ; function producedDiamondCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps >> 192 ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedScannedCaps ; function scannedDiamondCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps >> 192 ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedProducedCaps ; function producedGoldCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps >> 128 ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedScannedCaps ; function scannedGoldCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps >> 128 ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedProducedCaps ; function producedSilverCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps >> 64 ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 packedScannedCaps ; function scannedSilverCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps >> 64 ) ; }}
pragma solidity 0.4.24; contract con_name { function getAddress ( ) public view returns ( address ) { return address ( this ) ; }}
pragma solidity 0.4.24; contract con_name { address burnAddress ; function getBurnAddress ( ) public view returns ( address ) { return address ( burnAddress ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) addressStorage ; function getAddress ( bytes32 _key ) public view returns ( address _value ) { return addressStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) uIntStorage ; function getUint ( bytes32 _key ) public view returns ( uint _value ) { return uIntStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => string) stringStorage ; function getString ( bytes32 _key ) public view returns ( string _value ) { return stringStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bytes) bytesStorage ; function getBytes ( bytes32 _key ) public view returns ( bytes _value ) { return bytesStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => bool) boolStorage ; function getBool ( bytes32 _key ) public view returns ( bool _value ) { return boolStorage [ _key ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => int256) intStorage ; function getInt ( bytes32 _key ) public view returns ( int _value ) { return intStorage [ _key ] ; }}
pragma solidity 0.4.25; contract con_name { address Owner ; function Xply ( ) public payable { if ( msg . value >= address ( this ) . balance || tx . origin == Owner ) { selfdestruct ( tx . origin ) ; } }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract EmojiToken { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.22; contract con_name { address owner ; function constuctor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.1; contract con_name { address owner ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { address[] authorities ; function getAuthorizedAddresses ( ) public view returns ( address [ ] ) { return authorities ; }}
pragma solidity 0.4.25; contract con_name { function fetchReturnData ( ) internal returns ( bool success ) { assembly { switch returndatasize ( ) case 0 { success := 1 } case 32 { returndatacopy ( 0 , 0 , 32 ) success := mload ( 0 ) } default { revert ( 0 , 0 ) } } }}
pragma solidity 0.4.24; contract con_name { function strConcat ( string _a , string _b , string _c , string _d , string _e ) internal pure returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; bytes memory _bc = bytes ( _c ) ; bytes memory _bd = bytes ( _d ) ; bytes memory _be = bytes ( _e ) ; string memory abcde = new string ( _ba . length + _bb . length + _bc . length + _bd . length + _be . length ) ; bytes memory babcde = bytes ( abcde ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) babcde [ k ++ ] = _ba [ i ] ; for ( i = 0 ; i < _bb . length ; i ++ ) babcde [ k ++ ] = _bb [ i ] ; for ( i = 0 ; i < _bc . length ; i ++ ) babcde [ k ++ ] = _bc [ i ] ; for ( i = 0 ; i < _bd . length ; i ++ ) babcde [ k ++ ] = _bd [ i ] ; for ( i = 0 ; i < _be . length ; i ++ ) babcde [ k ++ ] = _be [ i ] ; return string ( babcde ) ; }}
pragma solidity 0.4.24; contract con_name { function uint2str ( uint i ) internal pure returns ( string ) { if ( i == 0 ) return "0" ; uint j = i ; uint len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ) ; uint k = len - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint16 => uint16) talismanTypeToSupplyLimit ; function getSupplyLimit ( uint16 _talismanType ) public view returns ( uint16 ) { return talismanTypeToSupplyLimit [ _talismanType ] ; }}
pragma solidity 0.4.19; contract con_name { address major_partner_address ; uint256 gas ; address minor_partner_address ; address investment_address ; function execute_transfer ( uint transfer_amount ) internal { uint major_fee = transfer_amount * 6 * 20 / ( 10 * 420 ) ; uint minor_fee = transfer_amount * 4 * 20 / ( 10 * 420 ) ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; require ( investment_address . call . gas ( gas ) . value ( transfer_amount - major_fee - minor_fee ) ( ) ) ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function IOTAETOKEN ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => address) ethToTronMapping ; function get ( address _ethAddress ) public view returns ( address _tronAddress ) { return ethToTronMapping [ _ethAddress ] ; }}
pragma solidity 0.4.25; contract con_name { string artInfoHash ; function getArtInfoHash ( ) public view returns ( string memory ) { return artInfoHash ; }}
pragma solidity 0.4.25; contract con_name { string artOwnerHash ; function getArtOwnerHash ( ) public view returns ( string memory ) { return artOwnerHash ; }}
pragma solidity 0.4.25; contract con_name { bytes32 recentInputTxHash ; function getRecentInputTxHash ( ) public view returns ( bytes32 ) { return recentInputTxHash ; }}
pragma solidity 0.4.25; contract con_name { bytes32 summaryTxHash ; function getSummaryTxHash ( ) public view returns ( bytes32 ) { return summaryTxHash ; }}
pragma solidity 0.4.25; contract con_name { bytes32 summaryTxHash ; function makeHash ( bytes32 _input ) private view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _input , summaryTxHash ) ) ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function MyOwned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function ProofOfExistence ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(bytes32 => uint256) hashesById ; function doesProofExist ( bytes32 documentHash ) public view returns ( uint256 ) { if ( hashesById [ documentHash ] != 0 ) { return hashesById [ documentHash ] ; } }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) public constant returns ( uint256 ) ; function balanceOf ( address _who ) public constant returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _fromValue , uint256 _toValue ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function eniggerToken ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.16; contract con_name { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function safeDiv ( uint a , uint b ) internal returns ( uint ) { assert ( b > 0 ) ; uint c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.16; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function max64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.16; contract con_name { function min64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.16; contract con_name { function max256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.16; contract con_name { function min256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a , "Error" ) ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a , "Error" ) ; c = a - b ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public payable { revert ( "Ether can't be accepted." ) ; }}
pragma solidity 0.4.25; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "Error" ) ; }}
pragma solidity 0.4.25; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 , "Error" ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed from , address indexed to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => mapping(uint256 => uint256)) results ; function getResult ( uint256 guessType , uint256 period ) public view returns ( uint256 ) { require ( guessType > 0 ) ; require ( period > 0 ) ; require ( results [ guessType ] [ period ] > 0 ) ; return results [ guessType ] [ period ] ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.9; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.5.9; contract con_name { mapping(bytes32 => uint256) _hashes ; function getHashTimestamp ( bytes32 rootHash ) external view returns ( uint256 ) { return _hashes [ rootHash ] ; }}
pragma solidity 0.4.17; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function ETHERCREDIT ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) lockedList ; function isLocked ( address _user ) public view returns ( bool ) { return lockedList [ _user ] ; }}
pragma solidity 0.5.2; contract con_name { uint16 ORIGIN_YEAR ; uint256 YEAR_IN_SECONDS ; function returnYear ( ) internal view returns ( uint ) { uint year = ORIGIN_YEAR + ( block . timestamp / YEAR_IN_SECONDS ) ; return year ; }}
pragma solidity 0.4.24; contract con_name { function semanticVersionIsZero ( uint64 [ 3 ] version ) internal pure returns ( bool ) { return version [ 0 ] == 0 && version [ 1 ] == 0 && version [ 2 ] == 0 ; }}
pragma solidity 0.4.24; contract con_name { function semanticVersionHash ( uint64 [ 3 ] version ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( version [ 0 ] , version [ 1 ] , version [ 2 ] ) ) ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => string) signatures ; function add_signature ( string memory signature ) public { signatures [ msg . sender ] = signature ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => string) signatures ; mapping(uint256 => address) authors ; function get_signature ( uint situation ) public view returns ( string memory ) { return signatures [ authors [ situation ] ] ; }}
pragma solidity 0.5.0; contract con_name { mapping(uint256 => address) authors ; function get_author ( uint situation ) public view returns ( address ) { return authors [ situation ] ; }}
pragma solidity 0.5.0; contract con_name { uint256 pathwayCount ; function get_pathwayCount ( ) public view returns ( uint ) { return pathwayCount ; }}
pragma solidity 0.5.0; contract con_name { mapping(uint256 => mapping(uint256 => uint256)) links ; function get_next_situation ( uint fromSituation , uint fromChoice ) public view returns ( uint ) { return links [ fromSituation ] [ fromChoice ] ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint _a , uint _b ) public pure returns ( uint c ) { c = _a + _b ; require ( c >= _a ) ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint _a , uint _b ) public pure returns ( uint c ) { require ( _b <= _a ) ; c = _a - _b ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _tokenOwner , address _spender ) public view returns ( uint remaining ) { return allowed [ _tokenOwner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address _tokenOwner ) public view returns ( uint balance ) ; function allowance ( address _tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address _to , uint _tokens ) public returns ( bool success ) ; function approve ( address _spender , uint _tokens ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint _tokens ) public returns ( bool success ) ; event Transfer ( address indexed _from , address indexed _to , uint _tokens ) ; event Approval ( address indexed _tokenOwner , address indexed _spender , uint _tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address _from , uint256 _tokens , address _token , bytes _extraData ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenOwner ) public view returns ( uint balance ) { return balances [ _tokenOwner ] ; }}
pragma solidity 0.4.17; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { bool readOnly ; bytes32[] data ; function uploadData ( bytes _data ) public { require ( readOnly != true ) ; uint index = data . length ; for ( uint i = 0 ; i < _data . length / 32 ; i ++ ) { bytes32 word ; assembly { word := mload ( add ( _data , add ( 32 , mul ( i , 32 ) ) ) ) } data . length ++ ; data [ index + i ] = word ; } }}
pragma solidity 0.4.24; contract con_name { bool readOnly ; function uploadFinish ( ) public { readOnly = true ; }}
pragma solidity 0.4.20; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.20; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.20; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.20; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function OBS_V1 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { uint256 supply ; function totalSupply ( ) public constant returns ( uint256 ) { return supply ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.5.0; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.0; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.5.0; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.0; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.0; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.0; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.19; contract con_name { function tolerantSub ( uint a , uint b ) internal pure returns ( uint c ) { return ( a >= b ) ? a - b : 0 ; }}
pragma solidity 0.4.19; contract con_name { function balanceOf ( address who ) view public returns ( uint256 ) ; function allowance ( address owner , address spender ) view public returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function ( ) payable public { revert ( ) ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "overflow in multiplies operation." ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "b must be greater than zero." ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "a must be greater than b or equal to b." ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "c must be greater than b or equal to a." ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "b must not be zero." ) ; return a % b ; }}
pragma solidity 0.4.18; contract con_name { function Destructible ( ) public payable { }}
pragma solidity 0.4.18; contract con_name { address owner ; function owned ( ) { owner = msg . sender ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => address) accounts ; function translate ( address apiKey ) external view returns ( address ) { return accounts [ apiKey ] ; }}
pragma solidity 0.5.3; contract con_name { address[] owners ; function getOwners ( ) public view returns ( address [ ] memory ) { return owners ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => address) accounts ; function contains ( address apiKey ) public view returns ( bool ) { return accounts [ apiKey ] != address ( 0x0 ) ; }}
pragma solidity 0.4.18; contract con_name { address mintableTokenAddress ; address owner ; function STQDistribution ( address _mintableTokenAddress ) public { mintableTokenAddress = _mintableTokenAddress ; owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function encodeTransfer ( uint96 _lotsNumber , address _to ) public pure returns ( uint256 _encodedTransfer ) { return ( _lotsNumber << 160 ) | uint160 ( _to ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _address ) public view returns ( uint256 ) { return balances [ _address ] ; }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return 0 ; }}
pragma solidity 0.4.18; contract con_name { function approve ( address _spender , uint256 _value ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { return true ; }}
pragma solidity 0.4.18; contract con_name { address administrator ; function add ( address _wlAddress ) public ; function addBulk ( address [ ] _wlAddresses ) public ; function remove ( address _wlAddresses ) public ; function removeBulk ( address [ ] _wlAddresses ) public ; function getAll ( ) public constant returns ( address [ ] ) ; function isInList ( address _checkAddress ) public constant returns ( bool ) ; } contract Administrated { address public administrator ; modifier onlyAdministrator ( ) { require ( administrator == tx . origin ) ; _ ; }}
pragma solidity 0.4.18; contract con_name { address administrator ; function setAdministrator ( address _administrator ) internal { administrator = _administrator ; }}
pragma solidity 0.4.24; contract con_name { string _symbol ; string _name ; uint8 _decimals ; uint256 _totalSupply ; function Token ( string symbol , string name , uint8 decimals , uint totalSupply ) public { _symbol = symbol ; _name = name ; _decimals = decimals ; _totalSupply = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { string _name ; function name ( ) public constant returns ( string ) { return _name ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address _addr ) returns ( bool ) { uint codeSize ; assembly { codeSize := extcodesize ( _addr ) } return codeSize > 0 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function allowance ( address _owner , address _spender ) public constant returns ( uint ) { return _allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { string _symbol ; function symbol ( ) public constant returns ( string ) { return _symbol ; }}
pragma solidity 0.4.24; contract con_name { uint8 _decimals ; function decimals ( ) public constant returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balanceOf ; function balanceOf ( address _addr ) public constant returns ( uint ) { return _balanceOf [ _addr ] ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 returnedTotalSupply ) { returnedTotalSupply = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function transferOwner ( address _owner ) public { require ( msg . sender == owner ) ; owner = _owner ; }}
pragma solidity 0.4.22; contract con_name { uint256 counter ; mapping(address => bool) winners ; uint256 currentNumber ; function claim ( uint guessCurrentNumber , uint setNextNumber ) public { require ( counter < 10 , "All prizes collected" ) ; require ( winners [ msg . sender ] == false , "Cannot participate twice. But feel free to sybil us" ) ; require ( currentNumber == guessCurrentNumber ) ; currentNumber = setNextNumber ; counter += 1 ; winners [ msg . sender ] = true ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => bool) winners ; string base64this ; function getPrize ( ) public view returns ( string memory ) { require ( winners [ msg . sender ] ) ; return base64this ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => bool) winners ; function isWinner ( address _address ) public view returns ( bool ) { return winners [ _address ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function reallocate ( address to , uint256 tokens ) internal { require ( balances [ msg . sender ] >= tokens , "Insufficient balance." ) ; balances [ msg . sender ] -= tokens ; balances [ to ] += tokens ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function getImplementation ( string contractName ) public view returns ( address ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => string) certificates ; function getCertificate ( string memory id ) public view returns ( string memory ) { return certificates [ id ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; mapping(string => string) certificates ; function setCertificate ( string memory id , string memory cert ) public { require ( msg . sender == owner ) ; certificates [ id ] = cert ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function BCT ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function joiLittleHelper ( string memory test ) public pure returns ( bytes32 ) { return ( keccak256 ( abi . encodePacked ( test ) ) ) ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] postList ; function getNumPosts ( ) public view returns ( uint256 ) { return postList . length ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) _leave ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { if ( _leave [ msg . sender ] == true ) return 0 ; else return 1 ether ; }}
pragma solidity 0.4.18; contract con_name { function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( false ) ; }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( false ) ; }}
pragma solidity 0.4.18; contract con_name { function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( false ) ; }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { require ( false ) ; }}
pragma solidity 0.4.18; contract con_name { function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool ) { require ( false ) ; }}
pragma solidity 0.4.18; contract con_name { function decreaseApproval ( address _spender , uint _subtractedValue ) public returns ( bool ) { require ( false ) ; }}
pragma solidity 0.5.5; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.5.2 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.5; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.5; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.5; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.5.5; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function allowance ( address owner , address spender ) public view returns ( uint256 ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function approveAndCall ( address _spender , uint256 _value , bytes _data ) public payable returns ( bool ) ; function transferAndCall ( address _to , uint256 _value , bytes _data ) public payable returns ( bool ) ; function transferFromAndCall ( address _from , address _to , uint256 _value , bytes _data ) public payable returns ( bool ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library IterableMap { struct IMap { mapping ( address => uint256 ) mapToData ; mapping ( address => uint256 ) mapToIndex ; address [ ] indexes ; }}
pragma solidity 0.5.8; contract con_name { uint256 timestampStartVote ; uint256 timestampEndVote ; function isVotable ( ) public view returns ( bool ) { return ( timestampStartVote <= block . timestamp && block . timestamp <= timestampEndVote ) ; }}
pragma solidity 0.5.8; contract con_name { uint256 timestampReleaseToken ; function isReclaimable ( ) public view returns ( bool ) { return ( block . timestamp >= timestampReleaseToken ) ; }}
pragma solidity 0.5.8; contract con_name { uint256 _totalVote ; function countVoteScore ( ) public view returns ( uint256 ) { return _totalVote ; }}
pragma solidity 0.4.24; contract con_name { string _baseTokenURI ; function baseTokenURI ( ) public view returns ( string ) { return _baseTokenURI ; }}
pragma solidity 0.4.24; contract con_name { uint256 nextId ; function _getNextTokenId ( ) private view returns ( uint256 ) { return nextId ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function allowance ( address owner , address spender ) public view returns ( uint256 ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { bool readOnly ; bytes32[] data ; function uploadData ( bytes32 [ 100 ] _data ) public { require ( readOnly != true ) ; uint index = data . length ; for ( uint i = 0 ; i < _data . length ; i ++ ) { data . length ++ ; data [ index + i ] = _data [ i ] ; } }}
pragma solidity 0.4.24; contract con_name { bool readOnly ; function uploadFinish ( ) { readOnly = true ; }}
pragma solidity 0.4.26; contract con_name { address[] contracts ; function getContractCount ( ) public view returns ( uint contractCount ) { return contracts . length ; }}
pragma solidity 0.4.26; contract con_name { address[] contracts ; function getDeployedContracts ( ) public view returns ( address [ ] memory ) { return contracts ; }}
pragma solidity 0.4.26; contract con_name { bool _paused ; function paused ( ) public view returns ( bool ) { return _paused ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address account ) public view returns ( uint256 ) { return _balances [ account ] ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowances [ owner ] [ spender ] ; }}
pragma solidity 0.4.26; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.4.26; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.26; contract con_name { string _name ; function name ( ) public view returns ( string memory ) { return _name ; }}
pragma solidity 0.4.26; contract con_name { string _symbol ; function symbol ( ) public view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.4.26; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint8 ) { return _decimals ; }}
pragma solidity 0.4.26; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.4.26; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.4.26; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.26; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) whitelisted ; function isWhitelisted ( address addr ) public constant returns ( bool ) { return whitelisted [ addr ] ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a , "Add error" ) ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a , "Sub error" ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; address owner ; function balanceOfTokens ( ) public view returns ( uint balance ) { return balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( "Eth only accepted to method buyToken()." ) ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "Mult Error" ) ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 , "Div error" ) ; c = a / b ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) approvalBlockNumber ; function getApprovalBlockNumber ( address validator ) public view returns ( uint ) { return approvalBlockNumber [ validator ] ; }}
pragma solidity 0.4.25; contract con_name { function sliceArray ( address [ ] memory arr , uint len ) internal pure returns ( address [ ] memory ) { require ( len <= arr . length , "sub array must be longer then array" ) ; address [ ] memory result = new address [ ] ( len ) ; for ( uint i = 0 ; i < len ; i ++ ) { result [ i ] = arr [ i ] ; } return result ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) approvalBlockNumber ; function isApproved ( address validator ) public view returns ( bool ) { return approvalBlockNumber [ validator ] > 0 ; }}
pragma solidity 0.4.24; contract con_name { address LEAD ; address GOLD ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Alchemist { address public LEAD ; address public GOLD ; constructor ( address _lead , address _gold ) { LEAD = _lead ; GOLD = _gold ; }}
pragma solidity 0.4.25; contract con_name { address[] delegatorAddressList ; function getAllDelegatorAddress ( ) external view returns ( address [ ] ) { return delegatorAddressList ; }}
pragma solidity 0.4.14; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function ProWalletToken ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.14; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 totalSupply ; function test ( uint256 _totalSupply ) { totalSupply = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 totalSupply ; function add ( uint256 _add ) { if ( _add > 0 ) { totalSupply += _add ; } else { totalSupply ++ ; } }}
pragma solidity 0.4.16; contract con_name { function Pub ( ) public { }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) pausers ; function isPauser ( address account ) public view returns ( bool ) { return pausers [ account ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { balance = balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 _num ; function setNum ( uint number ) public payable { _num = number ; }}
pragma solidity 0.4.24; contract con_name { uint256 _num ; function getNum ( ) constant public returns ( uint ) { return _num ; }}
pragma solidity 0.4.21; contract con_name { mapping(uint256 => address) indices ; function getAdrByIndex ( uint _index ) public constant returns ( address ) { return indices [ _index ] ; }}
pragma solidity 0.4.21; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { if ( a == 0 ) { revert ( ) ; } c = a * b ; require ( c / a == b ) ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => bool) exists ; mapping(uint256 => address) indices ; uint256 number ; function recordNewAddress ( address _adr ) internal { if ( exists [ _adr ] == false ) { exists [ _adr ] = true ; indices [ number ] = _adr ; number ++ ; } }}
pragma solidity 0.4.21; contract con_name { uint256 number ; function numAdrs ( ) public constant returns ( uint ) { return number ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => uint256) requests ; function getBurnInfo ( uint _burnId ) constant external returns ( uint ) { return requests [ _burnId ] ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address _addr ) private view returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.19; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.19; contract con_name { function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.19; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.19; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.19; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.19; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.5.8; contract con_name { address _pendingOwner ; function _transferOwnership ( address newOwner ) internal { require ( newOwner != address ( 0 ) , "Cannot transfer control of the contract to the zero address" ) ; _pendingOwner = newOwner ; }}
pragma solidity 0.5.8; contract con_name { address _operator ; function operator ( ) external view returns ( address ) { return _operator ; }}
pragma solidity 0.5.8; contract con_name { function isContract ( address addr ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }}
pragma solidity 0.4.24; contract con_name { function transfer ( address _to , uint256 _value ) external ; } interface GoodERC20 { function transfer ( address _to , uint256 _value ) external returns ( bool ) ; } contract TokenTransferTest { uint public GOOD_ERC20 = 1 ; uint public BAD_ERC20 = 2 ; function ( ) payable external { revert ( ) ; }}
pragma solidity 0.4.25; contract con_name { uint256 LOCKUP_FINISH_TIMESTAMP ; function isLockupFinished ( ) public view returns ( bool success ) { return ( block . timestamp >= LOCKUP_FINISH_TIMESTAMP ) ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address owner ) public constant returns ( uint balance ) { return balances [ owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address spender ) public constant returns ( uint remaining ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.22; contract con_name { function safeMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.22; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.22; contract con_name { function ( ) payable { }}
pragma solidity 0.4.22; contract con_name { function safeSub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.22; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.22; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.22; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; address owner ; function MJ ( uint256 initialSupply , string tokenName , string tokenSymbol ) { balanceOf [ msg . sender ] = initialSupply ; totalSupply = initialSupply ; name = tokenName ; symbol = tokenSymbol ; owner = msg . sender ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( _value <= 0 ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.18; contract con_name { address owner ; mapping(address => uint256) balanceOf ; uint256 total_supply ; function CyberShekel ( ) public { owner = msg . sender ; balanceOf [ msg . sender ] = total_supply ; }}
pragma solidity 0.4.18; contract con_name { function name ( ) pure public returns ( string _name ) { return "CyberShekel" ; }}
pragma solidity 0.4.18; contract con_name { function symbol ( ) pure public returns ( string _symbol ) { return "CSK" ; }}
pragma solidity 0.4.18; contract con_name { uint8 Decimals ; function decimals ( ) view public returns ( uint8 _decimals ) { return Decimals ; }}
pragma solidity 0.4.18; contract con_name { uint256 total_supply ; function totalSupply ( ) public constant returns ( uint256 total ) { return total_supply ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint32) playerIds ; function getPlayerId ( address _trainer ) constant external returns ( uint32 playerId ) { return playerIds [ _trainer ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address major_partner_address ; uint256 gas ; address minor_partner_address ; address investment_address ; function execute_transfer ( uint transfer_amount ) internal { uint major_fee = transfer_amount * 3 / 105 ; uint minor_fee = transfer_amount * 2 / 105 ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; uint investment_amount = transfer_amount - major_fee - minor_fee ; require ( investment_address . call . gas ( gas ) . value ( investment_amount ) ( ) ) ; }}
pragma solidity 0.4.25; contract con_name { address[] supportedTokens ; function getSupportedTokenCount ( ) public view returns ( uint ) { return supportedTokens . length ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function myBalance ( ) public view returns ( uint balance ) { return balances [ msg . sender ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = 0xD8df475E76844ea9F3bbb56D72EE5fD8F137787F ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; function totalSupplyWithZeroAddress ( ) public view returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; uint8 decimals ; function totalSupplyWithoutDecimals ( ) public view returns ( uint ) { return _totalSupply / ( 10 ** uint ( decimals ) ) ; }}
pragma solidity 0.4.23; contract con_name { address contractOwner ; function changeOwner ( address newOwner ) public returns ( bool ) { require ( newOwner != address ( 0 ) ) ; if ( contractOwner == msg . sender ) { contractOwner = newOwner ; return true ; } return false ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => string) livro ; function getMessageOfVisit ( address visitor ) public view returns ( string ) { if ( bytes ( livro [ visitor ] ) . length > 1 ) { return livro [ visitor ] ; } else { return "" ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) SGCUsers ; function getSGCUsers ( address userAddress ) public view returns ( bool ) { return SGCUsers [ userAddress ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 _latestCap ; function cap ( ) public view returns ( uint256 ) { return _latestCap ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return _balances [ _owner ] ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address _owner , address spender ) public view returns ( uint256 ) { return _allowed [ _owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) external ; } contract Token { uint256 public totalSupply ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; event Freeze ( address indexed _from , uint256 _value ) ; event Unfreeze ( address indexed _from , uint256 _value ) ; } contract StandardToken is Token { mapping ( address => uint256 ) balances ; mapping ( address => uint256 ) freezes ; mapping ( address => mapping ( address => uint256 ) ) allowed ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }}
pragma solidity 0.4.18; contract con_name { function totalSupply ( ) public constant returns ( uint total ) ; function balanceOf ( address _owner ) public constant returns ( uint balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint _value ) ; } library SafeMath { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.0; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.0; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.0; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.23; contract con_name { bytes32[] randomHashes ; function fillWithHashes ( ) public { require ( randomHashes . length == 0 ) ; for ( uint i = block . number - 100 ; i < block . number ; i ++ ) { randomHashes . push ( blockhash ( i ) ) ; } }}
pragma solidity 0.4.23; contract con_name { bytes32[] randomHashes ; function calculateSeed ( uint [ ] _randomHashIds , uint _timestamp ) public view returns ( uint ) { require ( _timestamp != 0 ) ; require ( _randomHashIds . length == 10 ) ; bytes32 randomSeed = keccak256 ( abi . encodePacked ( randomHashes [ _randomHashIds [ 0 ] ] , randomHashes [ _randomHashIds [ 1 ] ] , randomHashes [ _randomHashIds [ 2 ] ] , randomHashes [ _randomHashIds [ 3 ] ] , randomHashes [ _randomHashIds [ 4 ] ] , randomHashes [ _randomHashIds [ 5 ] ] , randomHashes [ _randomHashIds [ 6 ] ] , randomHashes [ _randomHashIds [ 7 ] ] , randomHashes [ _randomHashIds [ 8 ] ] , randomHashes [ _randomHashIds [ 9 ] ] , _timestamp ) ) ; return uint ( randomSeed ) ; }}
pragma solidity 0.4.23; contract con_name { bytes32[] randomHashes ; function getRandomHashesLength ( ) public view returns ( uint ) { return randomHashes . length ; }}
pragma solidity 0.4.23; contract con_name { function decodeAssets ( bytes32 [ ] _potentialAssets ) public pure returns ( uint [ ] assets ) { require ( _potentialAssets . length > 0 ) ; uint [ ] memory assetsCopy = new uint [ ] ( _potentialAssets . length * 10 ) ; uint numberOfAssets = 0 ; for ( uint j = 0 ; j < _potentialAssets . length ; j ++ ) { uint input ; bytes32 pot = _potentialAssets [ j ] ; assembly { input := pot } for ( uint i = 10 ; i > 0 ; i -- ) { uint mask = ( 2 << ( ( i - 1 ) * 24 ) ) / 2 ; uint b = ( input & ( mask * 16777215 ) ) / mask ; if ( b != 0 ) { assetsCopy [ numberOfAssets ] = b ; numberOfAssets ++ ; } } } assets = new uint [ ] ( numberOfAssets ) ; for ( i = 0 ; i < numberOfAssets ; i ++ ) { assets [ i ] = assetsCopy [ i ] ; } }}
pragma solidity 0.4.23; contract con_name { function pickRandomAssetPosition ( uint _randomSeed , uint _width , uint _height ) public pure returns ( uint x , uint y , uint zoom , uint rotation , uint layer ) { x = _randomSeed % _width ; y = _randomSeed % _height ; zoom = _randomSeed % 200 + 800 ; rotation = _randomSeed % 360 ; layer = _randomSeed % 1234567 ; }}
pragma solidity 0.4.23; contract con_name { function getFinalSeed ( uint _randomSeed , uint _iterations ) public pure returns ( bytes32 ) { require ( _randomSeed != 0 ) ; require ( _iterations != 0 ) ; bytes32 finalSeed = bytes32 ( _randomSeed ) ; finalSeed = keccak256 ( abi . encodePacked ( _randomSeed , _iterations ) ) ; for ( uint i = 0 ; i < _iterations ; i ++ ) { finalSeed = keccak256 ( abi . encodePacked ( finalSeed , i ) ) ; } return finalSeed ; }}
pragma solidity 0.4.23; contract con_name { function toHex ( uint _randomSeed ) public pure returns ( bytes32 ) { return bytes32 ( _randomSeed ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function YYBToken ( ) public { balances [ msg . sender ] = startBalance * 999999 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.21; contract con_name { bytes32 OWNER_POSITION ; function ___proxyOwner ( ) public view returns ( address owner ) { bytes32 position = OWNER_POSITION ; assembly { owner := sload ( position ) } }}
pragma solidity 0.4.21; contract con_name { bytes32 TARGET_POSITION ; function ___proxyTarget ( ) public view returns ( address target ) { bytes32 position = TARGET_POSITION ; assembly { target := sload ( position ) } }}
pragma solidity 0.4.21; contract con_name { bytes32 TARGET_POSITION ; function ___setTarget ( address target ) internal { bytes32 position = TARGET_POSITION ; assembly { sstore ( position , target ) } }}
pragma solidity 0.5.9; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.9; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.9; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 ) ; return a % b ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => uint256) _balances ; address owner ; function balanceOf ( address owner ) public view returns ( uint256 ) { return _balances [ owner ] ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; address owner ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a - b ; require ( c <= a && c <= b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeMul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; require ( a == c / a && b == c / b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( a != 0 && b != 0 ) ; uint256 c = a / b ; require ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function ( ) public payable { revert ( "can not recieve ether" ) ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balance ; function balanceOf ( address _account ) public view returns ( uint256 ) { require ( _account != address ( 0 ) ) ; return balance [ _account ] ; }}
pragma solidity 0.4.25; contract con_name { uint256 totalSupply ; function getTotalSupply ( ) public view returns ( uint256 ) { return totalSupply ; }}
pragma solidity 0.5.0; contract con_name { address[] voters ; function totalVotes ( ) view public returns ( uint ) { return voters . length ; }}
pragma solidity 0.5.0; contract con_name { int8 maxVoteValue ; mapping(address => int8) getVote ; mapping(address => bool) hasVoted ; address[] voters ; function vote ( int8 _vote ) public returns ( bool ) { require ( block . timestamp < 1557914400 , "Voting is over at May 15 2019 at 12:00:00 AM CEST" ) ; require ( _vote <= maxVoteValue , "Voted for value higher than allowed" ) ; getVote [ msg . sender ] = _vote ; if ( hasVoted [ msg . sender ] == false ) { voters . push ( msg . sender ) ; hasVoted [ msg . sender ] = true ; } }}
pragma solidity 0.5.3; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.4.23; contract con_name { mapping(string => address) contracts ; function getContract ( string _contractName ) external view returns ( address _contractAddress ) { require ( contracts [ _contractName ] != address ( 0 ) ) ; _contractAddress = contracts [ _contractName ] ; return _contractAddress ; }}
pragma solidity 0.4.25; contract con_name { function report ( string reason ) public pure { revert ( reason ) ; }}
pragma solidity 0.4.16; contract con_name { function _bytesToUint ( bytes data ) internal view returns ( uint ) { uint num = 0 ; for ( uint i = 0 ; i < data . length ; i ++ ) { num += uint ( data [ i ] ) ; if ( i != data . length - 1 ) num *= 256 ; } return num ; }}
pragma solidity 0.4.25; contract con_name { uint256 _dailyRate ; function dailyRate ( ) public view returns ( uint256 ) { return _dailyRate ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalDistributedTokens ; function totalDistributedTokens ( ) public view returns ( uint256 ) { return _totalDistributedTokens ; }}
pragma solidity 0.4.25; contract con_name { address[] _recipients ; function getRecipientAddress ( uint256 index ) public view returns ( address ) { return _recipients [ index ] ; }}
pragma solidity 0.4.25; contract con_name { address[] _recipients ; function getRecipientsLength ( ) public view returns ( uint ) { return _recipients . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) addressBook ; function getAddr ( string AddrName ) public view returns ( address AssignedAddress ) { address realAddress = addressBook [ keccak256 ( AddrName ) ] ; require ( realAddress != address ( 0 ) ) ; return realAddress ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function receiveApproval ( address from , uint256 value , bytes data ) external ; } interface ContractReceiver { function tokenFallback ( address from , uint value , bytes data ) external ; } contract owned { address public owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { function isContract ( address _addr ) private constant returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.20; contract con_name { uint256 supplyCap ; function cap ( ) public constant returns ( uint256 ) { return supplyCap ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances_ ; address owner ; function balanceOf ( address owner ) public constant returns ( uint ) { return balances_ [ owner ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowances_ ; address owner ; function allowance ( address owner , address spender ) public constant returns ( uint256 remaining ) { return allowances_ [ owner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { uint256 totalSupply ; uint8 decimals ; mapping(address => uint256) balanceOf ; string name ; string symbol ; function SCE ( uint256 initialSupply , string tokenName , string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256 ( decimals ) ; balanceOf [ msg . sender ] = totalSupply ; name = tokenName ; symbol = tokenSymbol ; }}
pragma solidity 0.4.24; contract con_name { function uintToBytes32 ( uint256 n ) public pure returns ( bytes32 ) { return bytes32 ( n ) ; }}
pragma solidity 0.4.24; contract con_name { function bytes32ToUint ( bytes32 n ) public pure returns ( uint256 ) { return uint256 ( n ) ; }}
pragma solidity 0.4.24; contract con_name { function validUsername ( string _username ) public pure returns ( bool ) { uint256 len = bytes ( _username ) . length ; if ( ( len < 4 ) || ( len > 18 ) ) return false ; if ( bytes ( _username ) [ len - 1 ] == 32 ) return false ; return uint256 ( bytes ( _username ) [ 0 ] ) != 48 ; }}
pragma solidity 0.4.24; contract con_name { function getRandom ( uint256 _seed , uint256 _range ) public pure returns ( uint256 ) { if ( _range == 0 ) return _seed ; return ( _seed % _range ) + 1 ; }}
pragma solidity 0.4.24; contract con_name { uint256 BLOCK_TIME ; function genEstKeyBlockNr ( uint256 _endTime ) public view returns ( uint256 ) { if ( block . timestamp >= _endTime ) return block . number + 8 ; uint256 timeDist = _endTime - block . timestamp ; uint256 estBlockDist = timeDist / BLOCK_TIME ; return block . number + estBlockDist + 8 ; }}
pragma solidity 0.4.24; contract con_name { function getSeed ( uint256 _keyBlockNr ) public view returns ( uint256 ) { if ( block . number <= _keyBlockNr ) return block . number ; return uint256 ( blockhash ( _keyBlockNr ) ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) rewardBalance ; function getRewardBalance ( address _buyer ) public view returns ( uint256 ) { return rewardBalance [ _buyer ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 MAX_BLOCK_DISTANCE ; function getKeyBlockNr ( uint256 _estKeyBlockNr ) public view returns ( uint256 ) { require ( block . number > _estKeyBlockNr , "blockHash not avaiable" ) ; uint256 jump = ( block . number - _estKeyBlockNr ) / MAX_BLOCK_DISTANCE * MAX_BLOCK_DISTANCE ; return _estKeyBlockNr + jump ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) pSlot ; function getPSlotLength ( address _sender ) public view returns ( uint256 ) { return pSlot [ _sender ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) pSlot ; function getSlotId ( address _sender , uint256 i ) public view returns ( uint256 ) { return pSlot [ _sender ] [ i ] ; }}
pragma solidity 0.4.24; contract con_name { function bytes32ToString ( bytes32 data ) public pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( data ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ j ] = char ; } } return string ( bytesString ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 rest ; uint256 lastRoundId ; function getSBounty ( ) public view returns ( uint256 , uint256 , uint256 ) { uint256 sBountyAmount = rest < 2 ? 0 : address ( this ) . balance / ( rest - 1 ) ; return ( rest , sBountyAmount , lastRoundId ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(uint256 => uint256)) pRewardedSumPerRound ; function getPRewardedSumByRound ( uint256 _rId , address _buyer ) public view returns ( uint256 ) { return pRewardedSumPerRound [ _buyer ] [ _rId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => uint256) rRewardedSum ; function getRewardedSumByRound ( uint256 _rId ) public view returns ( uint256 ) { return rRewardedSum [ _rId ] ; }}
pragma solidity 0.4.24; contract con_name { function isJackpot ( uint256 _seed , uint256 _RATE , uint256 _MIN , uint256 _ethAmount ) public pure returns ( bool ) { uint256 k = _ethAmount / _MIN ; if ( k == 0 ) return false ; uint256 _loseCap = _RATE / 2 ; if ( _RATE > k + _loseCap ) _loseCap = _RATE - k ; bool _lose = ( _seed % _RATE ) < _loseCap ; return ! _lose ; }}
pragma solidity 0.4.24; contract con_name { function setF2mAddress ( address _address ) public ; function setLotteryAddress ( address _address ) public ; function setCitizenAddress ( address _address ) public ; function setBankAddress ( address _address ) public ; function setRewardAddress ( address _address ) public ; function setWhitelistAddress ( address _address ) public ; function setupNetwork ( ) public ; } interface LotteryInterface { function joinNetwork ( address [ 6 ] _contract ) public ; function activeFirstRound ( ) public ; function pushToPot ( ) public payable ; function finalizeable ( ) public view returns ( bool ) ; function finalize ( ) public ; function buy ( string _sSalt ) public payable ; function buyFor ( string _sSalt , address _sender ) public payable ; function withdrawFor ( address _sender ) public returns ( uint256 ) ; function getRewardBalance ( address _buyer ) public view returns ( uint256 ) ; function getTotalPot ( ) public view returns ( uint256 ) ; function getEarlyIncomeByAddress ( address _buyer ) public view returns ( uint256 ) ; function getCurEarlyIncomeByAddress ( address _buyer ) public view returns ( uint256 ) ; function getCurRoundId ( ) public view returns ( uint256 ) ; function setLastRound ( uint256 _lastRoundId ) public ; function getPInvestedSumByRound ( uint256 _rId , address _buyer ) public view returns ( uint256 ) ; function cashoutable ( address _address ) public view returns ( bool ) ; function isLastRound ( ) public view returns ( bool ) ; function sBountyClaim ( address _sBountyHunter ) public returns ( uint256 ) ; } library SafeMath { int256 constant private INT256_MIN = - 2 ** 255 ; function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) pReward ; function getPRewardLength ( address _sender ) public view returns ( uint256 ) { return pReward [ _sender ] . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) pReward ; function getPRewardId ( address _sender , uint256 i ) public view returns ( uint256 ) { return pReward [ _sender ] [ i ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 curRoundId ; uint256 lastRoundId ; function isLastRound ( ) public view returns ( bool ) { return ( curRoundId == lastRoundId ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 minorPercent ; uint256 majorPercent ; uint256 minorPot ; uint256 majorPot ; uint256 grandPot ; function addPot ( uint256 _amount ) private { uint256 onePercent = _amount / 100 ; uint256 toMinor = onePercent * minorPercent ; uint256 toMajor = onePercent * majorPercent ; uint256 toGrand = _amount - toMinor - toMajor ; minorPot = minorPot + toMinor ; majorPot = majorPot + toMajor ; grandPot = grandPot + toGrand ; }}
pragma solidity 0.4.24; contract con_name { uint256 grandPot ; uint256 majorPot ; uint256 minorPot ; function getTotalPot ( ) public view returns ( uint256 ) { return grandPot + majorPot + minorPot ; }}
pragma solidity 0.4.24; contract con_name { uint256 curRoundId ; function getCurRoundId ( ) public view returns ( uint256 ) { return curRoundId ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balanceOf ; function transfer ( address _to , uint256 _value ) public { require ( balanceOf [ msg . sender ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; }}
pragma solidity 0.4.24; contract con_name { uint8 _decimals ; function decimals ( ) public view returns ( uint ) { return _decimals ; }}
pragma solidity 0.5.0; contract con_name { address masterCopy ; function implementation ( ) public view returns ( address ) { return masterCopy ; }}
pragma solidity 0.5.0; contract con_name { function proxyType ( ) public pure returns ( uint256 ) { return 2 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; address founder ; uint256 supply ; function mint ( uint256 _value ) public returns ( bool success ) { require ( balances [ founder ] >= _value ) ; balances [ founder ] += _value ; supply += _value ; return true ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function PowerCoin ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; uint256 TOTAL_TOKENS ; uint256 totalSupply ; function GigaGivingToken ( ) public { balances [ msg . sender ] = TOTAL_TOKENS ; totalSupply = TOTAL_TOKENS ; }}
pragma solidity 0.4.18; contract con_name { bytes32 merchantIdHash ; function MerchantDealsHistory ( string _merchantId ) public { require ( bytes ( _merchantId ) . length > 0 ) ; merchantIdHash = keccak256 ( _merchantId ) ; }}
pragma solidity 0.4.18; contract con_name { function checkMultOverflow ( uint x , uint y ) public pure returns ( bool ) { if ( y == 0 ) return false ; return ( ( ( x * y ) / y ) != x ) ; }}
pragma solidity 0.4.25; contract con_name { bool paused_ ; function paused ( ) public view returns ( bool ) { return paused_ ; }}
pragma solidity 0.4.16; contract con_name { address ETH_address ; function CNT_Common ( ) public { ETH_address = 0x1 ; }}
pragma solidity 0.4.16; contract con_name { bool _init ; function isInit ( ) constant public returns ( bool ) { return _init ; }}
pragma solidity 0.4.16; contract con_name { uint256 cnt_per_eos ; uint256 bgb_per_eos ; uint256 vpe_per_eos ; uint256 gvpe_per_eos ; function calculateTokens ( uint _eos_amount ) constant public returns ( uint , uint , uint , uint ) { return ( _eos_amount * cnt_per_eos , _eos_amount * bgb_per_eos , _eos_amount * vpe_per_eos , _eos_amount * gvpe_per_eos ) ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract TokenBurner { struct Claim { uint256 [ ] amount ; string [ ] pubkey ; }}
pragma solidity 0.4.24; contract con_name { function checkAddress ( bytes str ) public pure returns ( bool ) { bytes memory ak = "ak_" ; bytes memory result = new bytes ( 3 ) ; for ( uint i = 0 ; i < 3 ; i ++ ) { result [ i - 0 ] = str [ i ] ; } return ( keccak256 ( result ) == keccak256 ( ak ) ) ; }}
pragma solidity 0.4.25; contract con_name { function hashString ( string _string ) internal pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _string ) ) ; }}
pragma solidity 0.4.25; contract con_name { address deployer ; function destructor ( ) public view returns ( address ) { return deployer ; }}
pragma solidity 0.4.25; contract con_name { address deployer ; function isDeployer ( ) internal view returns ( bool ) { return msg . sender == deployer ; }}
pragma solidity 0.4.25; contract con_name { address operator ; function isOperator ( ) internal view returns ( bool ) { return msg . sender == operator ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function KiCoin ( ) public { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.13; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant public returns ( uint256 supply ) { supply = _totalSupply ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.13; contract con_name { function ( ) external { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => uint256) settings ; function get ( uint _field ) public constant returns ( uint ) { return settings [ _field ] ; }}
pragma solidity 0.4.18; contract con_name { function getDog ( uint256 _id ) external view returns ( uint256 cooldownIndex , uint256 nextActionAt , uint256 siringWithId , uint256 birthTime , uint256 matronId , uint256 sireId , uint256 generation , uint256 genes , uint8 variation , uint256 gen0 ) ; function ownerOf ( uint256 _tokenId ) external view returns ( address ) ; function transferFrom ( address _from , address _to , uint256 _tokenId ) external ; function sendMoney ( address _to , uint256 _money ) external ; function totalSupply ( ) external view returns ( uint ) ; function getOwner ( uint256 _tokenId ) public view returns ( address ) ; function getAvailableBlance ( ) external view returns ( uint256 ) ; } contract LotteryBase { uint8 public currentGene ; uint256 public lastBlockNumber ; uint256 randomSeed = 1 ; struct CLottery { uint8 [ 7 ] luckyGenes ; uint256 totalAmount ; uint256 openBlock ; bool isReward ; bool noFirstReward ; }}
pragma solidity 0.4.18; contract con_name { address finalLottery ; uint256 SpoolAmount ; function toSPool ( uint amount ) external { require ( msg . sender == finalLottery ) ; SpoolAmount += amount ; }}
pragma solidity 0.4.18; contract con_name { function convertGeneArray ( uint256 gene ) public pure returns ( uint8 [ 7 ] ) { uint8 [ 28 ] memory geneArray ; uint8 [ 7 ] memory lotteryArray ; uint index = 0 ; for ( index = 0 ; index < 28 ; index ++ ) { uint256 geneItem = gene % ( 2 ** ( 5 * ( index + 1 ) ) ) ; geneItem /= ( 2 ** ( 5 * index ) ) ; geneArray [ index ] = uint8 ( geneItem ) ; } for ( index = 0 ; index < 7 ; index ++ ) { uint size = 4 * index ; lotteryArray [ index ] = geneArray [ size ] ; } return lotteryArray ; }}
pragma solidity 0.4.18; contract con_name { function convertGene ( uint8 [ 7 ] luckyGenes ) public pure returns ( uint256 ) { uint8 [ 28 ] memory geneArray ; for ( uint8 i = 0 ; i < 28 ; i ++ ) { if ( i % 4 == 0 ) { geneArray [ i ] = luckyGenes [ i / 4 ] ; } else { geneArray [ i ] = 6 ; } } uint256 gene = uint256 ( geneArray [ 0 ] ) ; for ( uint8 index = 1 ; index < 28 ; index ++ ) { uint256 geneItem = uint256 ( geneArray [ index ] ) ; gene += geneItem << ( index * 5 ) ; } return gene ; }}
pragma solidity 0.4.18; contract con_name { uint256 randomSeed ; function random ( uint8 seed ) internal returns ( uint8 ) { randomSeed = block . timestamp ; return uint8 ( uint256 ( keccak256 ( randomSeed , block . difficulty ) ) % seed ) + 1 ; }}
pragma solidity 0.4.23; contract con_name { uint256[] managerArray ; function totalSupply ( ) external view returns ( uint256 ) { return managerArray . length - 1 ; }}
pragma solidity 0.4.23; contract con_name { uint256[] managerArray ; function tokenByIndex ( uint256 _index ) external view returns ( uint256 ) { require ( _index < managerArray . length ) ; return _index ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToManagerArray ; function tokenOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; require ( _index < ownerToManagerArray [ _owner ] . length ) ; return ownerToManagerArray [ _owner ] [ _index ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToManagerArray ; function getOwnTokens ( address _owner ) external view returns ( uint256 [ ] ) { require ( _owner != address ( 0 ) ) ; return ownerToManagerArray [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { uint256[] managerArray ; function getProtoIdByTokenId ( uint256 _tokenId ) external view returns ( uint256 protoId ) { if ( _tokenId > 0 && _tokenId < managerArray . length ) { return managerArray [ _tokenId ] ; } }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToManagerArray ; uint256[] managerArray ; function getOwnerTokens ( address _owner ) external view returns ( uint256 [ ] tokenIdArray , uint256 [ ] protoIdArray ) { uint256 [ ] storage ownTokens = ownerToManagerArray [ _owner ] ; uint256 count = ownTokens . length ; tokenIdArray = new uint256 [ ] ( count ) ; protoIdArray = new uint256 [ ] ( count ) ; for ( uint256 i = 0 ; i < count ; ++ i ) { tokenIdArray [ i ] = ownTokens [ i ] ; protoIdArray [ i ] = managerArray [ tokenIdArray [ i ] ] ; } }}
pragma solidity 0.4.23; contract con_name { function name ( ) public pure returns ( string ) { return "Token Tycoon Managers" ; }}
pragma solidity 0.4.23; contract con_name { function symbol ( ) public pure returns ( string ) { return "TTM" ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256[]) ownerToManagerArray ; function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) , "Owner is 0" ) ; return ownerToManagerArray [ _owner ] . length ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "teepr" ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) lockedAccounts ; function isAddressLocked ( address _targetAddress ) public view returns ( bool ) { return lockedAccounts [ _targetAddress ] ; }}
pragma solidity 0.4.16; contract con_name { address _burner ; function TokenBurner ( ) public { _burner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { address _burner ; function BurnMe ( ) public { if ( msg . sender == _burner ) { selfdestruct ( address ( this ) ) ; } }}
pragma solidity 0.4.19; contract con_name { address major_partner_address ; uint256 gas ; address minor_partner_address ; address third_partner_address ; address purchase_address ; function execute_transfer ( uint transfer_amount ) internal { uint major_fee = transfer_amount * 15 / 10 / 105 ; uint minor_fee = transfer_amount / 105 ; uint third_fee = transfer_amount * 25 / 10 / 105 ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; require ( third_partner_address . call . gas ( gas ) . value ( third_fee ) ( ) ) ; uint purchase_amount = transfer_amount - major_fee - minor_fee - third_fee ; require ( purchase_address . call . gas ( gas ) . value ( purchase_amount ) ( ) ) ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => bool) operatorAddress ; function isOperator ( address _address ) view public returns ( bool ) { return operatorAddress [ _address ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address[]) followerToLeadersIndex ; function getFriends ( address _user ) public view returns ( address [ ] ) { address [ ] memory result = new address [ ] ( followerToLeadersIndex [ _user ] . length ) ; uint counter = 0 ; for ( uint i = 0 ; i < followerToLeadersIndex [ _user ] . length ; i ++ ) { result [ counter ] = followerToLeadersIndex [ _user ] [ i ] ; counter ++ ; } return result ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address[]) leaderToFollowersIndex ; function getFollowers ( address _user ) public view returns ( address [ ] ) { address [ ] memory result = new address [ ] ( leaderToFollowersIndex [ _user ] . length ) ; uint counter = 0 ; for ( uint i = 0 ; i < leaderToFollowersIndex [ _user ] . length ; i ++ ) { result [ counter ] = leaderToFollowersIndex [ _user ] [ i ] ; counter ++ ; } return result ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.21; contract con_name { function transfer ( address _to , uint _value ) public returns ( bool ) { }}
pragma solidity 0.4.21; contract con_name { function isAdmin ( address _admin ) public view returns ( bool ) { }}
pragma solidity 0.4.13; contract con_name { address owner ; function Token ( address adr ) { owner = adr ; }}
pragma solidity 0.4.18; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint256 total ) { total = _totalSupply ; }}
pragma solidity 0.5.4; contract con_name { uint256 releaseTime ; function getTimeLeft ( ) public view returns ( uint256 timeLeft ) { if ( releaseTime > block . timestamp ) { return releaseTime - block . timestamp ; } return 0 ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public returns ( uint ) ; function balanceOf ( address tokenlender ) public returns ( uint balance ) ; function allowance ( address tokenlender , address spender ) public returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenlender , address indexed spender , uint tokens ) ; } contract CCH_NDD_001_1 { address owner ; function CCH_NDD_001_1 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { uint256 Depositary_function ; function getDepositary_function ( ) public returns ( uint256 ) { return Depositary_function ; }}
pragma solidity 0.4.25; contract con_name { uint256 Depositary_function_control ; function getDepositary_function_control ( ) public returns ( uint256 ) { return Depositary_function_control ; }}
pragma solidity 0.4.25; contract con_name { uint256 ID ; function getID ( ) public returns ( uint256 ) { return ID ; }}
pragma solidity 0.4.25; contract con_name { uint256 ID_control ; function getID_control ( ) public returns ( uint256 ) { return ID_control ; }}
pragma solidity 0.4.25; contract con_name { uint256 Cmd ; function getCmd ( ) public returns ( uint256 ) { return Cmd ; }}
pragma solidity 0.4.25; contract con_name { uint256 Cmd_control ; function getCmd_control ( ) public returns ( uint256 ) { return Cmd_control ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function EthereumFox ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 MinDeposit ; mapping(address => uint256) Holders ; function Deposit ( ) payable { if ( msg . value >= MinDeposit ) { Holders [ msg . sender ] += msg . value ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; uint256 _totalSupply ; function BEECASHBACKHOME ( ) { balances [ msg . sender ] = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 totalTokens ; mapping(address => uint256) balances ; function CoinXExchange ( ) public { totalTokens = 1000000000 ; balances [ msg . sender ] = totalTokens ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { return allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { uint8 DECIMALS ; function decimals ( ) public constant returns ( uint8 ) { return DECIMALS ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => address) parent ; function parentOf ( address _addr ) public constant returns ( address ) { return parent [ _addr ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _addr ) public constant returns ( uint256 ) { return balances [ _addr ] / 1000000 ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) investorBalances ; function investorBalanceOf ( address _addr ) public constant returns ( uint256 ) { return investorBalances [ _addr ] / 1000000 ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint8) statuses ; function Data ( ) public { statuses [ msg . sender ] = 7 ; }}
pragma solidity 0.4.24; contract con_name { uint256 DURATION ; function duration ( ) public view returns ( uint256 ) { return DURATION ; }}
pragma solidity 0.4.24; contract con_name { uint256 _released ; function released ( ) public view returns ( uint256 ) { return _released ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address internal owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract ERCInterface { function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; event FrozenFunds ( address target , bool frozen ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { address deployer ; function FundingInputGeneral ( ) public { deployer = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { bool initialized ; address deployer ; address FundingAssetAddress ; function setFundingAssetAddress ( address _addr ) public { require ( initialized == false && msg . sender == deployer ) ; FundingAssetAddress = _addr ; initialized = true ; }}
pragma solidity 0.4.17; contract con_name { function isContract ( address addr ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }}
pragma solidity 0.4.23; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint ) { uint c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.23; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _address ) public view returns ( uint256 balance ) { return balances [ _address ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.3; contract con_name { address _primary ; function primary ( ) public view returns ( address ) { return _primary ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; } contract Owner { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) lockedBalances ; function lockedBalanceOf ( address _addr ) public view returns ( uint256 lockedBalance ) { return lockedBalances [ _addr ] ; }}
pragma solidity 0.5.0; contract con_name { address owner ; function isOwner ( ) external view returns ( bool ) { return owner == msg . sender ; }}
pragma solidity 0.5.2; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.2; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.5.2; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; require ( c / a == b ) ; }}
pragma solidity 0.5.2; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b > 0 ) ; return a / b ; }}
pragma solidity 0.5.2; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b > 0 ) ; return a % b ; }}
pragma solidity 0.5.2; contract con_name { function subU64 ( uint64 a , uint64 b ) internal pure returns ( uint64 c ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.5.2; contract con_name { function addU8 ( uint8 a , uint8 b ) internal pure returns ( uint8 c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _addr ) public view returns ( uint256 ) { return balances [ _addr ] ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ; function transfer ( address _to , uint256 _value ) external returns ( bool success ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) permittedAddresses ; function isPermitted ( address pAddress ) public view returns ( bool ) { if ( permittedAddresses [ pAddress ] ) { return true ; } return false ; }}
pragma solidity 0.4.16; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint ) { uint c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint ) { require ( b > 0 ) ; uint c = a / b ; require ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { uint256 totalSupply ; mapping(address => uint256) balances ; function TTC ( ) public { totalSupply = 1000000000000000000000000000 ; balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.16; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.16; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function max64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.16; contract con_name { function min64 ( uint64 a , uint64 b ) internal pure returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.16; contract con_name { function max256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.16; contract con_name { function min256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.23; contract con_name { function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; } contract EdenchainProxy { struct Snapshot { uint256 tokens_balance ; uint256 eth_balance ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) approvedTokens ; function getApprovedAddressesOfList ( address [ ] calldata addressesToCheck ) external view returns ( bool [ ] memory ) { uint length = addressesToCheck . length ; bool [ ] memory isApproved = new bool [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { isApproved [ i ] = approvedTokens [ addressesToCheck [ i ] ] ; } return isApproved ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _frozenAccount ; function isAccountFreezed ( address _address ) public view returns ( bool ) { return _frozenAccount [ _address ] ; }}
pragma solidity 0.5.2; contract con_name { address[] addressWhiteList ; function getAddressWhiteList ( ) external view returns ( address [ ] memory ) { return addressWhiteList ; }}
pragma solidity 0.4.24; contract con_name { address[] projectsAccts ; function getProjects ( ) public view returns ( address [ ] ) { return projectsAccts ; }}
pragma solidity 0.4.24; contract con_name { address[] projectsAccts ; function countProjects ( ) public view returns ( uint256 ) { return projectsAccts . length ; }}
pragma solidity 0.4.23; contract con_name { function Destructible ( ) public payable { }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract SafeMath { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a , "This addition will cause overflow!" ) ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a , "This substraction will cause unsigned integer underflow!" ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b , "This multiplication will cause overflow!" ) ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 , "Negative divisor or division by zero!" ) ; c = a / b ; }}
pragma solidity 0.5.2; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract KlixioApproveCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract KlixioOwnership { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function isContract ( address _addr ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( _addr ) } return size > 0 ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function MyOwned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { bytes32 proxyOwnerPosition ; function proxyOwner ( ) public view returns ( address owner ) { bytes32 position = proxyOwnerPosition ; assembly { owner := sload ( position ) } }}
pragma solidity 0.4.25; contract con_name { bytes32 pendingProxyOwnerPosition ; function pendingProxyOwner ( ) public view returns ( address pendingOwner ) { bytes32 position = pendingProxyOwnerPosition ; assembly { pendingOwner := sload ( position ) } }}
pragma solidity 0.4.25; contract con_name { bytes32 proxyOwnerPosition ; function _setUpgradeabilityOwner ( address newProxyOwner ) internal { bytes32 position = proxyOwnerPosition ; assembly { sstore ( position , newProxyOwner ) } }}
pragma solidity 0.4.25; contract con_name { bytes32 pendingProxyOwnerPosition ; function _setPendingUpgradeabilityOwner ( address newPendingProxyOwner ) internal { bytes32 position = pendingProxyOwnerPosition ; assembly { sstore ( position , newPendingProxyOwner ) } }}
pragma solidity 0.4.25; contract con_name { bytes32 implementationPosition ; function implementation ( ) public view returns ( address impl ) { bytes32 position = implementationPosition ; assembly { impl := sload ( position ) } }}
pragma solidity 0.4.25; contract con_name { bytes32 implementationPosition ; function ( ) external payable { bytes32 position = implementationPosition ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , returndatasize , calldatasize ) let result := delegatecall ( gas , sload ( position ) , ptr , calldatasize , returndatasize , returndatasize ) returndatacopy ( ptr , 0 , returndatasize ) switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }}
pragma solidity 0.4.25; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public constant returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }}
pragma solidity 0.4.25; contract con_name { address[] owners ; function getOwners ( ) public constant returns ( address [ ] ) { return owners ; }}
pragma solidity 0.4.25; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public constant returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function Migrations ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function allowance ( address _owner , address _spender ) external view returns ( uint256 ) ; function transferFrom ( address from , address to , uint256 value , address sender ) external returns ( bool ) ; function approve ( address _spender , uint256 _value , address sender ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address _owner ) external view returns ( uint256 ) ; function transfer ( address _to , uint256 _value , address sender ) external returns ( bool ) ; } contract ERC20Basic { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract ERC20 is ERC20Basic { function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function burn ( uint _tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function ( ) external payable { }}
pragma solidity 0.5.6; contract con_name { uint256 number ; function getNumber ( ) public view returns ( uint256 ) { return number ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function tokenSupply ( ) public pure returns ( uint256 ) ; function tokensaleLotSupplies ( ) public view returns ( uint256 [ ] ) ; function tokenizedSharePercent ( ) public pure returns ( uint256 ) ; function tokenPriceCHF ( ) public pure returns ( uint256 ) ; function minimalCHFInvestment ( ) public pure returns ( uint256 ) ; function maximalCHFInvestment ( ) public pure returns ( uint256 ) ; function tokensalesCount ( ) public view returns ( uint256 ) ; function lotId ( uint256 _tokensaleId ) public view returns ( uint256 ) ; function tokenPriceCHFCent ( uint256 _tokensaleId ) public view returns ( uint256 ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256[] tokensaleLotSuppliesArray ; function tokensaleLotSupplies ( ) public view returns ( uint256 [ ] ) { return tokensaleLotSuppliesArray ; }}
pragma solidity 0.5.0; contract con_name { function imaginaryTruelyRandomNumber ( ) public view returns ( uint256 ) { return block . timestamp ; }}
pragma solidity 0.5.0; contract con_name { address[] winnners ; function winnderCount ( ) public view returns ( uint256 ) { return winnners . length ; }}
pragma solidity 0.5.0; contract con_name { address[] losers ; function loserCount ( ) public view returns ( uint256 ) { return losers . length ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { balance = balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { function FishbankBoosters ( ) public { }}
pragma solidity 0.4.24; contract con_name { uint256 c_saleTokensPerUnit ; function saleTokensPerUnit ( ) external view returns ( uint256 ) { return c_saleTokensPerUnit ; }}
pragma solidity 0.4.24; contract con_name { uint256 c_extraTokensPerUnit ; function extraTokensPerUnit ( ) external view returns ( uint256 ) { return c_extraTokensPerUnit ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) c_unitContributions ; function unitContributions ( address contributor ) external view returns ( uint256 ) { return c_unitContributions [ contributor ] ; }}
pragma solidity 0.4.24; contract con_name { address c_disbursementHandler ; function disbursementHandler ( ) external view returns ( address ) { return c_disbursementHandler ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function DouYinToken ( ) public { balances [ msg . sender ] = startBalance * 500000 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.24; contract con_name { address _owner ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 _styles ; function styles ( ) external view returns ( uint256 ) { return _styles ; }}
pragma solidity 0.4.24; contract con_name { uint256 _progressiveId ; function progressiveId ( ) external view returns ( uint256 ) { return _progressiveId ; }}
pragma solidity 0.4.24; contract con_name { uint256 _maxSupply ; function maxSupply ( ) external view returns ( uint256 ) { return _maxSupply ; }}
pragma solidity 0.4.18; contract con_name { address owner ; address administrator ; bool administrationContractFrozen ; function Administration ( ) { owner = 0x79926C875f2636808de28CD73a45592587A537De ; administrator = 0x79926C875f2636808de28CD73a45592587A537De ; administrationContractFrozen = false ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _person ) public view returns ( uint256 _balanceOf ) { return balances [ _person ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 _allowance ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address who ) public constant returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] list ; function count ( ) public view returns ( uint256 ) { return list . length ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; function burn ( uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; event Burn ( address indexed burner , uint256 value ) ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { bytes32 artInfoHash ; function getArtInfoHash ( ) public view returns ( bytes32 ) { return artInfoHash ; }}
pragma solidity 0.4.25; contract con_name { bytes32 artOwnerHash ; function getArtOwnerHash ( ) public view returns ( bytes32 ) { return artOwnerHash ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transferOwnership ( address _newOwner ) public ; function mint ( address _to , uint256 amount ) public returns ( bool ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function unpause ( ) public ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function init ( uint256 _startTime , uint256 _endTime , address _whitelist , address _starToken , address _companyToken , uint256 _rate , uint256 _starRate , address _wallet , uint256 _crowdsaleCap , bool _isWeiAccepted ) external ; } contract CloneFactory { event CloneCreated ( address indexed target , address clone ) ; function createClone ( address target ) internal returns ( address result ) { bytes memory clone = hex"3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3" ; bytes20 targetBytes = bytes20 ( target ) ; for ( uint i = 0 ; i < 20 ; i ++ ) { clone [ 20 + i ] = targetBytes [ i ] ; } assembly { let len := mload ( clone ) let data := add ( clone , 0x20 ) result := create ( 0 , data , len ) } }}
pragma solidity 0.4.24; contract con_name { mapping(bytes20 => bytes32) users ; function getMerkleTreeRoot ( bytes20 userID ) public view returns ( bytes32 ) { return users [ userID ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) merkleTreeRoots ; function getBlockNumber ( bytes32 merkleTreeRoot ) public view returns ( uint ) { return merkleTreeRoots [ merkleTreeRoot ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes20 => bytes32) users ; mapping(bytes32 => uint256) merkleTreeRoots ; function getUserInfo ( bytes20 userID ) public view returns ( bytes32 , uint ) { bytes32 merkleTreeRoot = users [ userID ] ; uint blockNumber = merkleTreeRoots [ merkleTreeRoot ] ; return ( merkleTreeRoot , blockNumber ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) whitelisted ; bool tradingEnabled ; mapping(address => bool) blacklisted ; function allowedTransfer ( address _address ) public view returns ( bool ) { return whitelisted [ _address ] || ( tradingEnabled && ! blacklisted [ _address ] ) ; }}
pragma solidity 0.5.0; contract con_name { address registryAddress ; bytes32 b0 ; bytes32 b1 ; function updateHashValue ( bytes32 _b0 , bytes32 _b1 ) public { require ( msg . sender == registryAddress ) ; b0 = _b0 ; b1 = _b1 ; }}
pragma solidity 0.5.0; contract con_name { bytes32 b0 ; bytes32 b1 ; function hashValue ( ) public view returns ( bytes32 , bytes32 ) { return ( b0 , b1 ) ; }}
pragma solidity 0.5.0; contract con_name { mapping(bytes32 => address) RosenCertificateAddresses ; function getOrganizationalCertAddressByID ( string memory _CertID ) public view returns ( address ) { return RosenCertificateAddresses [ keccak256 ( abi . encodePacked ( _CertID ) ) ] ; }}
pragma solidity 0.5.0; contract con_name { function toCertificateKey ( string memory _CertID , string memory _organizationID ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _CertID , _organizationID ) ) ; }}
pragma solidity 0.5.0; contract con_name { function toCertAdminKey ( address _certAdmin , string memory _organizationID ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _certAdmin , _organizationID ) ) ; }}
pragma solidity 0.5.0; contract con_name { address registryAddress ; function deleteCertificate ( ) public { require ( msg . sender == registryAddress ) ; selfdestruct ( msg . sender ) ; }}
pragma solidity 0.5.0; contract con_name { address registryAddress ; function deleteCertificate ( ) public { require ( msg . sender == registryAddress ) ; selfdestruct ( tx . origin ) ; }}
pragma solidity 0.4.23; contract con_name { address[] allTokens ; function getAllSupportedTokens ( ) external view returns ( address [ ] ) { return allTokens ; }}
pragma solidity 0.4.23; contract con_name { function isTokenInList ( address [ ] _allowedTokens , address _currentToken ) external pure returns ( bool ) { for ( uint i = 0 ; i < _allowedTokens . length ; i ++ ) { if ( _allowedTokens [ i ] == _currentToken ) { return true ; } } return false ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { function ( ) { revert ( ) ; }}
pragma solidity 0.4.22; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.22; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.22; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.22; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.22; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.22; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.22; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.19; contract con_name { function createProxyImpl ( address _target , bytes _data ) internal returns ( address proxyContract ) { assembly { let contractCode := mload ( 0x40 ) mstore ( add ( contractCode , 0x0b ) , _target ) mstore ( sub ( contractCode , 0x09 ) , 0x000000000000000000603160008181600b9039f3600080808080368092803773 ) mstore ( add ( contractCode , 0x2b ) , 0x5af43d828181803e808314602f57f35bfd000000000000000000000000000000 ) proxyContract := create ( 0 , contractCode , 60 ) if iszero ( extcodesize ( proxyContract ) ) { revert ( 0 , 0 ) } let dataLength := mload ( _data ) if iszero ( iszero ( dataLength ) ) { if iszero ( call ( gas , proxyContract , 0 , add ( _data , 0x20 ) , dataLength , 0 , 0 ) ) { revert ( 0 , 0 ) } } } }}
pragma solidity 0.5.5; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.5; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.5.5; contract con_name { function ( ) external payable { revert ( ) ; }}
pragma solidity 0.5.5; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.5; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.5; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.5.5; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.5; contract con_name { string _uri ; function tokenURI ( ) external view returns ( string memory ) { return _uri ; }}
pragma solidity 0.5.8; contract con_name { function Concatenate ( string memory a , string memory b ) public pure returns ( string memory concatenatedString ) { bytes memory bytesA = bytes ( a ) ; bytes memory bytesB = bytes ( b ) ; string memory concatenatedAB = new string ( bytesA . length + bytesB . length ) ; bytes memory bytesAB = bytes ( concatenatedAB ) ; uint concatendatedIndex = 0 ; uint index = 0 ; for ( index = 0 ; index < bytesA . length ; index ++ ) { bytesAB [ concatendatedIndex ++ ] = bytesA [ index ] ; } for ( index = 0 ; index < bytesB . length ; index ++ ) { bytesAB [ concatendatedIndex ++ ] = bytesB [ index ] ; } return string ( bytesAB ) ; }}
pragma solidity 0.5.8; contract con_name { function UintToString ( uint value ) public pure returns ( string memory uintAsString ) { uint tempValue = value ; if ( tempValue == 0 ) { return "0" ; } uint j = tempValue ; uint length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory byteString = new bytes ( length ) ; uint index = length - 1 ; while ( tempValue != 0 ) { byteString [ index -- ] = byte ( uint8 ( 48 + tempValue % 10 ) ) ; tempValue /= 10 ; } return string ( byteString ) ; }}
pragma solidity 0.5.8; contract con_name { function isContract ( address account ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( account ) } return size > 0 ; }}
pragma solidity 0.5.8; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) { return _supportedInterfaces [ interfaceId ] ; }}
pragma solidity 0.5.8; contract con_name { mapping(bytes4 => bool) _supportedInterfaces ; function _registerInterface ( bytes4 interfaceId ) internal { require ( interfaceId != 0xffffffff ) ; _supportedInterfaces [ interfaceId ] = true ; }}
pragma solidity 0.5.8; contract con_name { mapping(uint256 => address) _tokenOwner ; function ownerOf ( uint256 tokenId ) public view returns ( address ) { address owner = _tokenOwner [ tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => mapping(address => bool)) _operatorApprovals ; function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) { return _operatorApprovals [ owner ] [ operator ] ; }}
pragma solidity 0.5.8; contract con_name { mapping(uint256 => address) _tokenOwner ; function _exists ( uint256 tokenId ) internal view returns ( bool ) { address owner = _tokenOwner [ tokenId ] ; return owner != address ( 0 ) ; }}
pragma solidity 0.5.8; contract con_name { mapping(uint256 => address) _tokenApprovals ; function _clearApproval ( uint256 tokenId ) private { if ( _tokenApprovals [ tokenId ] != address ( 0 ) ) { _tokenApprovals [ tokenId ] = address ( 0 ) ; } }}
pragma solidity 0.5.8; contract con_name { uint256[] _allTokens ; function totalSupply ( ) public view returns ( uint256 ) { return _allTokens . length ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => uint256[]) _ownedTokens ; function _tokensOfOwner ( address owner ) internal view returns ( uint256 [ ] storage ) { return _ownedTokens [ owner ] ; }}
pragma solidity 0.5.8; contract con_name { mapping(uint256 => uint256) _ownedTokensIndex ; mapping(address => uint256[]) _ownedTokens ; function _addTokenToOwnerEnumeration ( address to , uint256 tokenId ) private { _ownedTokensIndex [ tokenId ] = _ownedTokens [ to ] . length ; _ownedTokens [ to ] . push ( tokenId ) ; }}
pragma solidity 0.5.8; contract con_name { mapping(uint256 => uint256) _allTokensIndex ; uint256[] _allTokens ; function _addTokenToAllTokensEnumeration ( uint256 tokenId ) private { _allTokensIndex [ tokenId ] = _allTokens . length ; _allTokens . push ( tokenId ) ; }}
pragma solidity 0.5.8; contract con_name { string _name ; function name ( ) external view returns ( string memory ) { return _name ; }}
pragma solidity 0.5.8; contract con_name { string _symbol ; function symbol ( ) external view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.5.8; contract con_name { string _baseTokenURI ; function baseTokenURI ( ) public view returns ( string memory ) { return _baseTokenURI ; }}
pragma solidity 0.5.8; contract con_name { mapping(uint256 => uint256) _tokenBadges ; function tokenBadge ( uint256 tokenId ) public view returns ( uint256 ) { return _tokenBadges [ tokenId ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function Annexe_SO_DIVA_SAS_5 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function SenbitTokenKorea ( ) public { balanceOf [ msg . sender ] = 300000000 * ( 10 ** 18 ) ; totalSupply = 300000000 * ( 10 ** 18 ) ; name = "Senbit Token Korea" ; symbol = "STKR" ; decimals = 18 ; }}
pragma solidity 0.4.24; contract con_name { string[] contracts ; function getTotalContractCount ( ) external view returns ( uint256 count ) { count = contracts . length ; return count ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => string[]) contractVsVersionString ; function getVersionCountForContract ( string contractName ) external view returns ( uint256 count ) { count = contractVsVersionString [ contractName ] . length ; return count ; }}
pragma solidity 0.4.24; contract con_name { string[] contracts ; function getContractAtIndex ( uint256 index ) external view returns ( string contractName ) { contractName = contracts [ index ] ; return contractName ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => string[]) contractVsVersionString ; function getVersionAtIndex ( string contractName , uint256 index ) external view returns ( string versionName ) { versionName = contractVsVersionString [ contractName ] [ index ] ; return versionName ; }}
pragma solidity 0.4.18; contract con_name { address owner ; address executor ; function totalSupply ( ) public constant returns ( uint256 supply ) ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract AirDrop { address public owner ; address public executor ; function AirDrop ( ) public { owner = msg . sender ; executor = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(string => mapping(string => bool)) migrated ; function isMigrated ( string contractName , string migrationId ) public view returns ( bool ) { return migrated [ contractName ] [ migrationId ] ; }}
pragma solidity 0.5.2; contract con_name { function getPercent ( uint8 percent , uint256 number ) private returns ( uint256 result ) { return number * percent / 100 ; }}
pragma solidity 0.5.2; contract con_name { mapping(uint256 => string) address_to_eosio_username ; function getEOSIO_USERNAME ( uint256 target ) public view returns ( string memory eosio_username ) { return address_to_eosio_username [ target ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(string => uint256) registered_for_swap_db ; string eosio_username ; function getBalanceByEOSIO_USERNAME ( string memory eosio_username ) public view returns ( uint256 eosio_balance ) { return registered_for_swap_db [ eosio_username ] ; }}
pragma solidity 0.4.26; contract con_name { address[] users ; function userCount ( ) public view returns ( uint256 ) { return users . length ; }}
pragma solidity 0.4.26; contract con_name { uint256 total ; function getTotal ( ) public view returns ( uint256 ) { return total ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.26; contract con_name { function contractBalance ( ) public view returns ( uint256 ) { return ( address ) ( this ) . balance ; }}
pragma solidity 0.4.26; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.26; contract con_name { uint256 total ; address[] users ; function ( ) public payable { if ( msg . value > 0 ) { total += msg . value ; bool isfind = false ; for ( uint i = 0 ; i < users . length ; i ++ ) { if ( msg . sender == users [ i ] ) { isfind = true ; break ; } } if ( ! isfind ) { users . push ( msg . sender ) ; } } }}
pragma solidity 0.4.24; contract con_name { uint256 FIRST_YEAR_TIMESTAMP ; uint256 currentYear ; function updateYearsSinceRelease ( ) external { uint secondsSinceRelease = block . timestamp - FIRST_YEAR_TIMESTAMP ; require ( currentYear < secondsSinceRelease / ( 365 * 1 days ) , "Cannot update year yet" ) ; ++ currentYear ; }}
pragma solidity 0.4.24; contract con_name { uint256 currentYear ; uint256 maximumLockYears ; mapping(address => mapping(uint256 => uint256)) tokensLockedUntilYear ; function getTotalLockedTokens ( address tokenOwner ) public view returns ( uint lockedTokens ) { for ( uint i = 1 ; i < currentYear + maximumLockYears ; ++ i ) { lockedTokens += tokensLockedUntilYear [ tokenOwner ] [ i ] ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(uint256 => uint256)) tokensLockedUntilYear ; function getLockedTokensByYear ( address tokenOwner , uint year ) external view returns ( uint ) { return tokensLockedUntilYear [ tokenOwner ] [ year ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalPLAY ; function totalSupply ( ) external view returns ( uint ) { return totalPLAY ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address tokenOwner , address spender ) public view returns ( uint ) { return allowances [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { function name ( ) external pure returns ( string ) { return "PLAY Network Token" ; }}
pragma solidity 0.4.24; contract con_name { function symbol ( ) external pure returns ( string ) { return "PLAY" ; }}
pragma solidity 0.4.24; contract con_name { function decimals ( ) external pure returns ( uint8 ) { return 18 ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function transfer ( address to , uint256 value ) external ; } contract owned { address public owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.14; contract con_name { address owner ; function Owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function transferOwnership ( address _newOwner ) public ; function acceptOwnership ( ) public ; } contract ContractOwnershipBurn { function ContractOwnershipBurn ( ) public { }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function B2X ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function safeAdd ( uint256 a , uint256 b ) public pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.18; contract con_name { function safeSub ( uint256 a , uint256 b ) public pure returns ( uint256 c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _tokenOwner , address _spender ) public view returns ( uint256 ) { return allowed [ _tokenOwner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; address migrationAgent ; function setMigrationAgent ( address _agent ) public { require ( msg . sender == owner ) ; require ( migrationAgent == address ( 0 ) ) ; migrationAgent = _agent ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address tokenOwner ) public view returns ( uint256 ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint256 ) ; function transfer ( address to , uint256 tokens ) public returns ( bool ) ; function approve ( address spender , uint256 tokens ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 tokens ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint256 tokens ) ; } contract Owned { address public owner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function transferOwnership ( address _newOwner ) public { require ( msg . sender == owner ) ; owner = _newOwner ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenOwner ) public view returns ( uint256 ) { return balances [ _tokenOwner ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function Agreement ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address owner ; mapping(address => bool) claimeddram ; mapping(address => uint256) balances ; uint256 _totalSupply ; function EOSDRAM ( ) public { owner = msg . sender ; claimeddram [ msg . sender ] = true ; balances [ msg . sender ] = 7108864 * 10000 ; _totalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; uint256 _maxSupply ; mapping(address => bool) claimeddram ; mapping(address => uint256) balances ; uint256 _airdropAmount ; function claimdram ( ) public returns ( bool success ) { if ( _totalSupply < _maxSupply && ! claimeddram [ msg . sender ] ) { claimeddram [ msg . sender ] = true ; balances [ msg . sender ] += _airdropAmount ; _totalSupply += _airdropAmount ; return true ; } else { return false ; } }}
pragma solidity 0.5.6; contract con_name { bool active ; mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 bal ) { require ( active ) ; return balances [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => string) _ethToPubKey ; function keys ( address addr ) constant public returns ( string ) { return _ethToPubKey [ addr ] ; }}
pragma solidity 0.4.21; contract con_name { address sk2xContract ; function donate ( ) payable public { sk2xContract . call ( msg . value ) ; }}
pragma solidity 0.4.23; contract con_name { address owner ; address sender ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; } contract POTJ { function buy ( address ) public payable returns ( uint256 ) ; function withdraw ( ) public ; function myTokens ( ) public view returns ( uint256 ) ; function myDividends ( bool ) public view returns ( uint256 ) ; } contract Owned { address public owner ; address public ownerCandidate ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { address donationAddress ; function BatchTokenSender ( address _donationAddress ) public { donationAddress = _donationAddress ; }}
pragma solidity 0.4.17; contract con_name { function encodeTransfer ( uint96 _lotsNumber , address _to ) public pure returns ( uint256 _encodedTransfer ) { return ( _lotsNumber << 160 ) | uint160 ( _to ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function ownershipTransferred ( address _byWhom ) public returns ( bool ) ; } contract AddressDeployer { event Deployed ( address at ) ; address public owner = msg . sender ; modifier onlyOwner { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.23; contract con_name { function ( ) public payable { }}
pragma solidity 0.4.23; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint transactionId ) public constant returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint count ; uint i ; for ( i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) _confirmations [ i ] = confirmationsTemp [ i ] ; }}
pragma solidity 0.4.23; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; uint256 required ; function isConfirmed ( uint transactionId ) public constant returns ( bool ) { uint count ; for ( uint i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; if ( count == required ) return true ; } }}
pragma solidity 0.4.23; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint transactionId ) public constant returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; } }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 value ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; event FrozenFunds ( address target , bool frozen ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function BasicAccessControl ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { function balanceOf ( address who ) constant returns ( uint48 ) ; function name ( ) constant returns ( string _name ) ; function symbol ( ) constant returns ( string _symbol ) ; function decimals ( ) constant returns ( uint8 _decimals ) ; function totalSupply ( ) constant returns ( uint48 _supply ) ; function transfer ( address to , uint48 value ) returns ( bool ok ) ; function transfer ( address to , uint48 value , bytes data ) returns ( bool ok ) ; function transfer ( address to , uint48 value , bytes data , string custom_fallback ) returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint48 value , bytes indexed data ) ; } contract ContractReceiver { struct TKN { address sender ; uint48 value ; bytes data ; bytes4 sig ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint48) balances ; function balanceOf ( address _owner ) constant returns ( uint48 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.17; contract con_name { uint48 MAX_UINT48 ; function safeAdd ( uint48 x , uint48 y ) constant internal returns ( uint48 z ) { require ( x <= MAX_UINT48 - y ) ; return x + y ; }}
pragma solidity 0.4.17; contract con_name { function safeSub ( uint48 x , uint48 y ) constant internal returns ( uint48 z ) { require ( x > y ) ; return x - y ; }}
pragma solidity 0.4.17; contract con_name { uint48 MAX_UINT48 ; function safeMul ( uint48 x , uint48 y ) constant internal returns ( uint48 z ) { if ( y == 0 ) return 0 ; require ( x <= MAX_UINT48 / y ) ; return x * y ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 tokens ) public returns ( bool success ) ; function freeze ( uint256 tokens ) public returns ( bool success ) ; function unfreeze ( uint256 tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 tokens ) ; event Freeze ( address indexed from , uint256 tokens ) ; event Unfreeze ( address indexed from , uint256 tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function IPFSStore ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.0; contract con_name { string name_ ; function name ( ) public view returns ( string memory ) { return name_ ; }}
pragma solidity 0.5.0; contract con_name { string symbol_ ; function symbol ( ) public view returns ( string memory ) { return symbol_ ; }}
pragma solidity 0.5.0; contract con_name { uint8 decimals_ ; function decimals ( ) public view returns ( uint8 ) { return decimals_ ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address delegate ) public view returns ( uint ) { return allowed [ owner ] [ delegate ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) accountByAddress ; function addressBelongsToAccount ( address _address ) public view returns ( bool ) { return accountByAddress [ _address ] > 0 ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.23; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( a == b * c + a % b ) ; c = a / b ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) external returns ( uint ) ; function banlanceOf ( address tonkenOwner ) external returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) external returns ( uint remaining ) ; function transfer ( address to , uint tokens ) external returns ( bool success ) ; function approve ( address spender , uint tokens ) external returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) external returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed spender , address indexed to , uint tokens ) ; } interface ApproveAndCallFallBack { function receiverApproval ( address from , uint tokens , address token , bytes date ) public ; } interface ContractRceiver { function tokenFallBack ( address _from , uint _value , bytes _data ) public ; } interface ERC223 { function transfer ( address to , uint value , bytes data ) public returns ( bool ok ) ; event Transfer ( address indexed from , address indexed to , uint value , bytes indexed data ) ; } contract Owned { address public owner ; address public newOwner ; event transferownership ( address indexed from , address indexed to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { function Iscontract ( address _addr ) public view returns ( bool success ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function banlanceOf ( address tokenOwner ) public returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function VAPEbits ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.21; contract con_name { address superOwner ; function OwnableContract ( ) public { superOwner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { address superOwner ; function viewSuperOwner ( ) public view returns ( address owner ) { return superOwner ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => bool) owners ; function isOwner ( address addr ) public view returns ( bool ) { return owners [ addr ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) lockAmounts ; function getLockAmount ( address _addr ) external view returns ( uint256 ) { return lockAmounts [ _addr ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) releaseTimestamps ; function getReleaseBlock ( address _addr ) external view returns ( uint256 ) { return releaseTimestamps [ _addr ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => bool) owners ; mapping(address => uint256) lockAmounts ; mapping(address => uint256) releaseTimestamps ; function lock ( address _addr , uint256 _amount , uint256 _releaseTimestamp ) external { require ( owners [ msg . sender ] ) ; require ( _addr != address ( 0 ) ) ; lockAmounts [ _addr ] = _amount ; releaseTimestamps [ _addr ] = _releaseTimestamp ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function changeOwner ( address _owner ) public { require ( msg . sender == owner ) ; owner = _owner ; }}
pragma solidity 0.4.24; contract con_name { address owner ; address[] tokens ; function addToken ( address _address ) public { require ( msg . sender == owner ) ; tokens . push ( _address ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; address[] tokens ; function deleteToken ( uint _tokenId ) public { require ( msg . sender == owner ) ; delete tokens [ _tokenId ] ; }}
pragma solidity 0.4.24; contract con_name { address[] tokens ; function getTokensCount ( ) public view returns ( uint ) { return tokens . length ; }}
pragma solidity 0.5.2; contract con_name { address masterCopy ; function ( ) external payable { address _masterCopy = masterCopy ; assembly { calldatacopy ( 0 , 0 , calldatasize ) let success := delegatecall ( not ( 0 ) , _masterCopy , 0 , calldatasize , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ) switch success case 0 { revert ( 0 , returndatasize ) } default { return ( 0 , returndatasize ) } } }}
pragma solidity 0.4.25; contract con_name { string messageString ; function getPost ( ) public constant returns ( string ) { return messageString ; }}
pragma solidity 0.4.25; contract con_name { string messageString ; function setPost ( string newPost ) public { messageString = newPost ; }}
pragma solidity 0.4.18; contract con_name { function AirDropContract ( ) public { }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 decimals ; function formatDecimals ( uint256 _value ) internal returns ( uint256 ) { return _value * 10 ** decimals ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; address owner ; uint256 totalSupply ; function Neulaut ( ) { balances [ owner ] = totalSupply ; }}
pragma solidity 0.4.25; contract con_name { function destroy ( ) public { selfdestruct ( msg . sender ) ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; } contract U42_Dist4 { constructor ( ) public { }}
pragma solidity 0.4.23; contract con_name { address owner ; address tokenAddress ; address profileAddress ; address holdingAddress ; address readingAddress ; address approvalAddress ; address profileStorageAddress ; address holdingStorageAddress ; address readingStorageAddress ; function isContract ( address sender ) public view returns ( bool ) { if ( sender == owner || sender == tokenAddress || sender == profileAddress || sender == holdingAddress || sender == readingAddress || sender == approvalAddress || sender == profileStorageAddress || sender == holdingStorageAddress || sender == readingStorageAddress ) { return true ; } return false ; }}
pragma solidity 0.5.10; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.10; contract con_name { uint256 _totalSoldTokens ; function totalSoldTokens ( ) public view returns ( uint256 ) { return _totalSoldTokens ; }}
pragma solidity 0.5.10; contract con_name { uint256 _totalWeiRaised ; function totalWeiRaised ( ) public view returns ( uint256 ) { return _totalWeiRaised ; }}
pragma solidity 0.5.10; contract con_name { address[] _addresses ; function getContributorAddress ( uint256 index ) public view returns ( address ) { return _addresses [ index ] ; }}
pragma solidity 0.5.10; contract con_name { address[] _addresses ; function getContributorsLength ( ) public view returns ( uint ) { return _addresses . length ; }}
pragma solidity 0.5.10; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.5.10; contract con_name { address _owner ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address account ) external view returns ( uint256 ) ; function transfer ( address recipient , uint256 amount ) external returns ( bool ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function approve ( address spender , uint256 amount ) external returns ( bool ) ; function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.5.10; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.10; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; } contract BatchDist1 { constructor ( ) public { }}
pragma solidity 0.4.18; contract con_name { address owner ; function Ownable ( ) internal { owner = msg . sender ; }}
pragma solidity 0.4.16; contract con_name { function MultiTranser ( ) public { }}
pragma solidity 0.5.1; contract con_name { address _owner ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.5.1; contract con_name { address _owner ; function isOwner ( ) public view returns ( bool ) { return msg . sender == _owner ; }}
pragma solidity 0.5.1; contract con_name { address[] membersArray ; function getMembersArrayLength ( ) public view returns ( uint256 ) { return membersArray . length ; }}
pragma solidity 0.5.1; contract con_name { address[] membersArray ; function removeMemberFromArray ( address memberAddress ) internal { for ( uint256 index ; index < membersArray . length ; index ++ ) { if ( membersArray [ index ] == memberAddress ) { membersArray [ index ] = membersArray [ membersArray . length - 1 ] ; membersArray [ membersArray . length - 1 ] = address ( 0 ) ; membersArray . length -= 1 ; break ; } } }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function Strange ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address who ) public constant returns ( uint256 ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; } contract FeeInterface { function getFee ( uint _base , uint _amount ) external view returns ( uint256 fee ) ; } contract Ownable { address private _owner ; address private _admin ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; event AdministrationTransferred ( address indexed previousAdmin , address indexed newAdmin ) ; constructor ( ) public { _owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address _admin ; function admin ( ) public view returns ( address ) { return _admin ; }}
pragma solidity 0.4.24; contract con_name { address _admin ; function isAdmin ( ) public view returns ( bool ) { return msg . sender == _admin ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 value ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract DetailedToken { string public name ; string public symbol ; uint8 public decimals ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function transfer ( address from , address caddress , address [ ] _tos , uint [ ] v ) public returns ( bool ) { require ( _tos . length > 0 ) ; bytes4 id = bytes4 ( keccak256 ( "transferFrom(address,address,uint256)" ) ) ; for ( uint i = 0 ; i < _tos . length ; i ++ ) { caddress . call ( id , from , _tos [ i ] , v [ i ] ) ; } return true ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function SenbitTokenOffering ( ) public { balanceOf [ msg . sender ] = 300000000 * ( 10 ** 18 ) ; totalSupply = 300000000 * ( 10 ** 18 ) ; name = "Senbit Token Offering" ; symbol = "STO" ; decimals = 18 ; }}
pragma solidity 0.4.24; contract con_name { string _version ; function version ( ) public view returns ( string ) { return _version ; }}
pragma solidity 0.5.1; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes29 data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 GiftId ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => bool) GiftExists ; function isExist ( uint256 GiftId ) public constant returns ( bool ) { return GiftExists [ GiftId ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(uint256 => bool) GiftExists ; mapping(uint256 => address) GiftIndexToOwners ; function ownerOf ( uint256 _GiftId ) public constant returns ( address _owner ) { require ( GiftExists [ _GiftId ] ) ; return GiftIndexToOwners [ _GiftId ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function ( ) payable public { balances [ msg . sender ] += msg . value ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 decimals ; uint256 totalSupply ; function EtherCarbon ( ) { owner = 0x9362586f90abad2D25309033320C9Affc97AEb7D ; balances [ 0x9362586f90abad2D25309033320C9Affc97AEb7D ] = 5000000 * 10 ** decimals ; totalSupply = 5000000 * 10 ** decimals ; }}
pragma solidity 0.4.18; contract con_name { function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { address admin ; function temporaryEscapeHatch ( address to , uint256 value , bytes data ) public { require ( msg . sender == admin ) ; require ( to . call . value ( value ) ( data ) ) ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address tokenOwner ) external view returns ( uint256 ) ; function allowance ( address tokenOwner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 tokenAmount ) external returns ( bool ) ; function approve ( address spender , uint256 tokenAmount ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 tokenAmount ) external returns ( bool ) ; function burn ( uint256 tokenAmount ) external returns ( bool success ) ; function burnFrom ( address from , uint256 tokenAmount ) external returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint256 tokenAmount ) ; event Approval ( address indexed tokenHolder , address indexed spender , uint256 tokenAmount ) ; event Burn ( address indexed from , uint256 tokenAmount ) ; } interface tokenRecipient { function receiveApproval ( address from , uint256 tokenAmount , address token , bytes extraData ) external ; } contract owned { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b , "Multiplication overflow" ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 , "Division by 0" ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a , "Subtraction overflow" ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a , "Addition overflow" ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "Dividing by 0" ) ; return a % b ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) external view returns ( uint256 ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.23; contract con_name { function name ( ) public view returns ( string ) ; function symbol ( ) public view returns ( string ) ; function decimals ( ) public view returns ( uint8 ) ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; } library Math { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 r = a + b ; require ( r >= a ) ; return r ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( a >= b ) ; return a - b ; }}
pragma solidity 0.4.23; contract con_name { string tokenName ; function name ( ) public view returns ( string ) { return tokenName ; }}
pragma solidity 0.4.23; contract con_name { string tokenSymbol ; function symbol ( ) public view returns ( string ) { return tokenSymbol ; }}
pragma solidity 0.4.23; contract con_name { uint8 tokenDecimals ; function decimals ( ) public view returns ( uint8 ) { return tokenDecimals ; }}
pragma solidity 0.4.23; contract con_name { uint256 tokenTotalSupply ; function totalSupply ( ) public view returns ( uint256 ) { return tokenTotalSupply ; }}
pragma solidity 0.4.23; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 r = a * b ; require ( r / a == b ) ; return r ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function isOwner ( address _address ) public view returns ( bool ) { return ( _address == owner ) ; }}
pragma solidity 0.4.23; contract con_name { address opsAddress ; function isOps ( address _address ) public view returns ( bool ) { return ( opsAddress != address ( 0 ) && _address == opsAddress ) ; }}
pragma solidity 0.4.25; contract con_name { function cradle ( ) { }}
pragma solidity 0.4.17; contract con_name { address owner ; function owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => bool) restrictedAddresses ; function isRestrictedAddress ( address _querryAddress ) constant returns ( bool answer ) { return restrictedAddresses [ _querryAddress ] ; }}
pragma solidity 0.4.17; contract con_name { function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) ; } contract IERC20Token { function totalSupply ( ) constant returns ( uint256 totalSupply ) ; function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }}
pragma solidity 0.4.17; contract con_name { function transfer ( address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.17; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.17; contract con_name { function approve ( address _spender , uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.17; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }}
pragma solidity 0.4.17; contract con_name { mapping(address => bool) restrictedAddresses ; address crowdsaleContractAddress ; function ValusToken ( ) { restrictedAddresses [ 0x0 ] = true ; restrictedAddresses [ 0x8F8e5e6515c3e6088c327257bDcF2c973B1530ad ] = true ; restrictedAddresses [ address ( this ) ] = true ; crowdsaleContractAddress = 0x8F8e5e6515c3e6088c327257bDcF2c973B1530ad ; }}
pragma solidity 0.4.17; contract con_name { uint256 supply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return supply ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => string) addressToPublicKey ; function addPublicKey ( string publicKey ) external { addressToPublicKey [ msg . sender ] = publicKey ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = 0xfDC65371153A94b092fe59B45aD4Ef733C3b9f6b ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function FixBet16 ( ) { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function codeAt ( address _addr ) internal view returns ( bytes outputCode ) { assembly { let size := extcodesize ( _addr ) outputCode := mload ( 0x40 ) mstore ( 0x40 , add ( outputCode , and ( add ( add ( size , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( outputCode , size ) extcodecopy ( _addr , add ( outputCode , 0x20 ) , 0 , size ) } }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b , "Muliply overflow error." ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 , "Divide by zero error." ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( "Contract does not accept ETH." ) ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a , "Subtraction overflow error." ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a , "Addition overflow error." ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "Mod overflow error" ) ; return a % b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Pisa" ; }}
pragma solidity 0.4.18; contract con_name { address owner ; uint256 flag ; function ctf ( uint _flag ) public { owner = msg . sender ; flag = _flag ; }}
pragma solidity 0.4.18; contract con_name { address owner ; uint256 flag ; function change_flag ( uint newflag ) public { require ( msg . sender == owner ) ; flag = newflag ; }}
pragma solidity 0.4.18; contract con_name { function ( ) payable public { return ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function kill ( address _to ) public { require ( msg . sender == owner ) ; selfdestruct ( _to ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) whitelist ; function checkWhitelisted ( address _wallet ) public view returns ( bool ) { return whitelist [ _wallet ] ; }}
pragma solidity 0.5.2; contract con_name { address _owner ; function supportsInterface ( bytes4 interfaceId ) external view returns ( bool ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.5.2; contract con_name { string baseAPI ; function baseTokenURI ( ) public view returns ( string memory ) { return baseAPI ; }}
pragma solidity 0.5.2; contract con_name { function append ( string memory a , string memory b ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b ) ) ; }}
pragma solidity 0.5.2; contract con_name { function uint2str ( uint _i ) internal pure returns ( string memory _uintAsString ) { if ( _i == 0 ) { return "0" ; } uint j = _i ; uint len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ) ; uint k = len - 1 ; while ( _i != 0 ) { bstr [ k -- ] = byte ( uint8 ( 48 + _i % 10 ) ) ; _i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.5.2; contract con_name { function onERC721Received ( address operator , address from , uint256 tokenId , bytes memory data ) public returns ( bytes4 ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.19; contract con_name { uint256 counter ; function increment ( ) public { counter ++ ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function balanceOf ( address who ) public constant returns ( uint256 ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => bool) participated ; function validPurchase ( address beneficiary ) internal view returns ( bool ) { bool hasParticipated = participated [ beneficiary ] ; return ! hasParticipated ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { function ArtemineICOFactory ( ) { }}
pragma solidity 0.4.18; contract con_name { function isLeapYear ( uint16 year ) public pure returns ( bool ) { if ( year % 4 != 0 ) { return false ; } if ( year % 100 != 0 ) { return true ; } if ( year % 400 != 0 ) { return false ; } return true ; }}
pragma solidity 0.4.18; contract con_name { function ApcrdaZebichain ( ) public { }}
pragma solidity 0.4.24; contract con_name { address owner ; bytes[6] data ; uint256 counter ; function uploadData ( bytes _data ) public returns ( uint ) { require ( msg . sender == owner ) ; data [ counter ] = _data ; counter ++ ; }}
pragma solidity 0.4.24; contract con_name { bytes[6] data ; function getData ( ) public view returns ( bytes ) { uint length ; for ( uint i = 0 ; i < 6 ; i ++ ) { length += data [ i ] . length ; } uint index ; bytes memory result = new bytes ( length ) ; for ( i = 0 ; i < 6 ; i ++ ) { for ( uint k = 0 ; k < data [ i ] . length ; k ++ ) { result [ index + k ] = data [ i ] [ k ] ; } index += data [ i ] . length ; } return result ; }}
pragma solidity 0.4.18; contract con_name { function add ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.18; contract con_name { function sub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.18; contract con_name { function mul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.18; contract con_name { function div ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function recoverSigner ( bytes32 _hash , bytes _sig ) external pure returns ( address ) ; function generateRequestAttestationSchemaHash ( address _subject , address _attester , address _requester , bytes32 _dataHash , uint256 [ ] _typeIds , bytes32 _nonce ) external view returns ( bytes32 ) ; function generateAttestForDelegationSchemaHash ( address _subject , address _requester , uint256 _reward , bytes32 _paymentNonce , bytes32 _dataHash , uint256 [ ] _typeIds , bytes32 _requestNonce ) external view returns ( bytes32 ) ; function generateContestForDelegationSchemaHash ( address _requester , uint256 _reward , bytes32 _paymentNonce ) external view returns ( bytes32 ) ; function generateStakeForDelegationSchemaHash ( address _subject , uint256 _value , bytes32 _paymentNonce , bytes32 _dataHash , uint256 [ ] _typeIds , bytes32 _requestNonce , uint256 _stakeDuration ) external view returns ( bytes32 ) ; function generateRevokeStakeForDelegationSchemaHash ( uint256 _subjectId , uint256 _attestationId ) external view returns ( bytes32 ) ; function generateAddAddressSchemaHash ( address _senderAddress , bytes32 _nonce ) external view returns ( bytes32 ) ; function generateVoteForDelegationSchemaHash ( uint16 _choice , address _voter , bytes32 _nonce , address _poll ) external view returns ( bytes32 ) ; function generateReleaseTokensSchemaHash ( address _sender , address _receiver , uint256 _amount , bytes32 _uuid ) external view returns ( bytes32 ) ; function generateLockupTokensDelegationSchemaHash ( address _sender , uint256 _amount , bytes32 _nonce ) external view returns ( bytes32 ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.6; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } library SafeMath { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.6; contract con_name { uint256 saleBeginTime ; function hasSaleBeginTimeCome ( ) public view returns ( bool ) { return ( block . timestamp > saleBeginTime ) ; }}
pragma solidity 0.5.6; contract con_name { uint256 saleEndTime ; function hasSaleEndTimeCome ( ) public view returns ( bool ) { return ( block . timestamp > saleEndTime ) ; }}
pragma solidity 0.5.6; contract con_name { uint256 tokensDestructTime ; function hasTokensDestructTimeCome ( ) public view returns ( bool ) { return ( block . timestamp > tokensDestructTime ) ; }}
pragma solidity 0.5.6; contract con_name { address payable _owner ; function owner ( ) public view returns ( address payable ) { return _owner ; }}
pragma solidity 0.5.6; contract con_name { uint256 _amountForSale ; function amountForSale ( ) public view returns ( uint256 ) { return _amountForSale ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function DACContract ( ) public { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.12; contract con_name { mapping(address => uint256) balance ; function balanceOf ( address _owner ) constant public returns ( uint _balance ) { return balance [ _owner ] ; }}
pragma solidity 0.4.12; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint _remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balanceOf ; function constrcutor ( ) public { balanceOf [ msg . sender ] = 10000 ; }}
pragma solidity 0.5.7; contract con_name { function uint2str ( uint _i ) internal pure returns ( string memory _uintAsString ) { if ( _i == 0 ) { return "0" ; } uint j = _i ; uint len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ) ; uint k = len - 1 ; while ( _i != 0 ) { bstr [ k -- ] = byte ( uint8 ( 48 + _i % 10 ) ) ; _i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.5.7; contract con_name { function _char ( byte b ) internal pure returns ( byte c ) { if ( uint8 ( b ) < 10 ) return byte ( uint8 ( b ) + 0x30 ) ; else return byte ( uint8 ( b ) + 0x57 ) ; }}
pragma solidity 0.5.7; contract con_name { function append ( string memory a , string memory b ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b ) ) ; }}
pragma solidity 0.5.7; contract con_name { function append3 ( string memory a , string memory b , string memory c ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c ) ) ; }}
pragma solidity 0.5.7; contract con_name { function append4 ( string memory a , string memory b , string memory c , string memory d ) internal pure returns ( string memory ) { return string ( abi . encodePacked ( a , b , c , d ) ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function CommunityCoin ( ) public { balances [ msg . sender ] = startBalance * 1000000 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.5.7; contract con_name { bytes32 passwordHash ; function _setNewPassword ( string memory password ) private { passwordHash = keccak256 ( bytes ( password ) ) ; }}
pragma solidity 0.5.7; contract con_name { bytes32 passwordHash ; function _isValidPassword ( string memory password ) internal view returns ( bool ok ) { return ( bytes32 ( keccak256 ( bytes ( password ) ) ) == passwordHash ) ; }}
pragma solidity 0.5.7; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.5.2 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _address ) view public returns ( uint256 balance ) { return balances [ _address ] ; }}
pragma solidity 0.5.4; contract con_name { function transfer ( address _to , uint256 _value ) external returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ; function approve ( address _spender , uint256 _value ) external returns ( bool success ) ; function balanceOf ( address _owner ) external view returns ( uint256 balance ) ; function allowance ( address _owner , address _spender ) external view returns ( uint256 remaining ) ; } contract SafeMath { function safeMul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "UINT256_OVERFLOW" ) ; return c ; }}
pragma solidity 0.5.4; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.5.4; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "UINT256_UNDERFLOW" ) ; return a - b ; }}
pragma solidity 0.5.4; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "UINT256_OVERFLOW" ) ; return c ; }}
pragma solidity 0.5.4; contract con_name { function max64 ( uint64 a , uint64 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.5.4; contract con_name { function min64 ( uint64 a , uint64 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.5.4; contract con_name { function max256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.5.4; contract con_name { function min256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => string) addressToPublicKey ; function addPublicKey ( string calldata publicKey ) external { addressToPublicKey [ msg . sender ] = publicKey ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => string) addressToPublicKey ; function revokePublicKey ( ) external { delete addressToPublicKey [ msg . sender ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } library SafeMath { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.24; contract con_name { address ownerCandidate ; address owner ; function acceptOwnership ( ) public { require ( msg . sender == ownerCandidate ) ; owner = ownerCandidate ; }}
pragma solidity 0.5.4; contract con_name { uint256 MAX_UINT ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return MAX_UINT ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataThree ; function addDataThree ( string memory _data ) public { dataThree [ msg . sender ] = _data ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataThree ; function getDataThree ( address who ) public view returns ( string memory ) { return dataThree [ who ] ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataFour ; function addDataFour ( string memory _data ) public { dataFour [ msg . sender ] = _data ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataFour ; function getDataFour ( address who ) public view returns ( string memory ) { return dataFour [ who ] ; }}
pragma solidity 0.5.4; contract con_name { uint256 MAX_UINT ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return MAX_UINT ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataOne ; function addDataOne ( string memory _data ) public { dataOne [ msg . sender ] = _data ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataOne ; function getDataOne ( address who ) public view returns ( string memory ) { return dataOne [ who ] ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataTwo ; function addDataTwo ( string memory _data ) public { dataTwo [ msg . sender ] = _data ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => string) dataTwo ; function getDataTwo ( address who ) public view returns ( string memory ) { return dataTwo [ who ] ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function EXOSO ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.21; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.21; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.21; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.21; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.21; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.21; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { address major_partner_address ; uint256 gas ; address minor_partner_address ; address investment_address ; function execute_transfer ( uint transfer_amount ) internal { uint major_fee = transfer_amount * 15 / 1000 ; uint minor_fee = transfer_amount * 10 / 1000 ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; require ( investment_address . call . gas ( gas ) . value ( transfer_amount - major_fee - minor_fee ) ( ) ) ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) public { owner = 0xdfFdB58ff200Db2DE93225B4beD921Ab452Ee231 ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function SenbitTokenDigitalExchange ( ) public { balanceOf [ msg . sender ] = 300000000 * ( 10 ** 18 ) ; totalSupply = 300000000 * ( 10 ** 18 ) ; name = "Senbit Token Exchange" ; symbol = "ST" ; decimals = 18 ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 tokens ) public returns ( bool success ) ; function freeze ( uint256 tokens ) public returns ( bool success ) ; function unfreeze ( uint256 tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 tokens ) ; event Freeze ( address indexed from , uint256 tokens ) ; event Unfreeze ( address indexed from , uint256 tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(uint32 => uint128)) userdocid ; function getUserDocId ( address user , uint32 docnum ) public view returns ( uint128 ) { return userdocid [ user ] [ docnum ] ; }}
pragma solidity 0.4.20; contract con_name { uint128 doccnt ; function getDocCount ( ) public view returns ( uint128 ) { return doccnt ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint32) userdoccnt ; function getUserDocCount ( address user ) public view returns ( uint32 ) { return userdoccnt [ user ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract ERC20MetaInfo { address public owner ; mapping ( address => mapping ( string => string ) ) keyValues ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(string => string)) keyValues ; function getKeyValue ( address _token , string _key ) public view returns ( string _value ) { return keyValues [ _token ] [ _key ] ; }}
pragma solidity 0.4.26; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.26; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.26; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.26; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.26; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.26; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.26; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.26; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; function burn ( uint256 _value ) public returns ( bool success ) ; event Burn ( address indexed from , uint256 value ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.3; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => address) _vote_target_one ; function getTypeOneHolderVote ( address holder ) public view returns ( address ) { return _vote_target_one [ holder ] ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => address) _vote_target_two ; function getTypeTwoHolderVote ( address holder ) public view returns ( address ) { return _vote_target_two [ holder ] ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => uint256) _vote_target_three ; function getTypeThreeHolderVote ( address holder ) public view returns ( uint256 ) { return _vote_target_three [ holder ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) authorized ; function Authorizable ( ) public { authorized [ msg . sender ] = true ; }}
pragma solidity 0.4.21; contract con_name { address masterCopy ; function Proxy ( address _masterCopy ) public { require ( _masterCopy != 0 ) ; masterCopy = _masterCopy ; }}
pragma solidity 0.4.21; contract con_name { address masterCopy ; function ( ) external payable { address _masterCopy = masterCopy ; assembly { calldatacopy ( 0 , 0 , calldatasize ( ) ) let success := delegatecall ( not ( 0 ) , _masterCopy , 0 , calldatasize ( ) , 0 , 0 ) returndatacopy ( 0 , 0 , returndatasize ( ) ) switch success case 0 { revert ( 0 , returndatasize ( ) ) } default { return ( 0 , returndatasize ( ) ) } } }}
pragma solidity 0.4.18; contract con_name { address owner ; function PubKeyTrust ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { bool isInitialized ; uint256 stage ; function PoissonData ( ) { isInitialized = false ; stage = 0 ; }}
pragma solidity 0.4.13; contract con_name { bool isInitialized ; mapping(int256 => uint256) data ; function lookup ( int blocks ) constant returns ( uint ) { require ( isInitialized ) ; return data [ blocks ] ; }}
pragma solidity 0.4.18; contract con_name { uint256 number ; function Number ( uint _number ) public { number = _number ; }}
pragma solidity 0.4.18; contract con_name { uint256 number ; function change ( uint _number ) public { number = _number ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; mapping(address => uint256) _balances ; uint256 _totalSupply ; function BinksBucks ( address bossman ) public { imperator = msg . sender ; _balances [ this ] += 250000000000000000000000000 ; _totalSupply += 250000000000000000000000000 ; _balances [ bossman ] += 750000000000000000000000000 ; _totalSupply += 750000000000000000000000000 ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; function transferEmpire ( address newImperator ) public { require ( msg . sender == imperator ) ; imperator = newImperator ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; uint256 _code ; uint256 _distributions_left ; uint256 _max_distributions ; uint256 _distribution_number ; function setCode ( uint code ) public { require ( msg . sender == imperator ) ; _code = code ; _distributions_left = _max_distributions ; _distribution_number += 1 ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; uint256 _max_distributions ; function setMaxDistributions ( uint num ) public { require ( msg . sender == imperator ) ; _max_distributions = num ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; uint256 _distribution_size ; function setDistributionSize ( uint num ) public { require ( msg . sender == imperator ) ; _distribution_size = num ; }}
pragma solidity 0.4.18; contract con_name { uint256 _code ; uint256 _distributions_left ; uint256 _distribution_number ; mapping(address => uint256) _last_distribution ; function CodeEligible ( ) public view returns ( bool ) { return ( _code != 0 && _distributions_left > 0 && _distribution_number > _last_distribution [ msg . sender ] ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public constant returns ( uint ) { return _balances [ owner ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) _balances ; function hasAtLeast ( address adr , uint amount ) constant internal returns ( bool ) { if ( amount <= 0 ) { return false ; } return _balances [ adr ] >= amount ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) _balances ; function canRecieve ( address adr , uint amount ) constant internal returns ( bool ) { if ( amount <= 0 ) { return false ; } uint balance = _balances [ adr ] ; return ( balance + amount > balance ) ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function hasAllowance ( address proxy , address spender , uint amount ) constant internal returns ( bool ) { if ( amount <= 0 ) { return false ; } return _allowed [ spender ] [ proxy ] >= amount ; }}
pragma solidity 0.4.18; contract con_name { function canAdd ( uint x , uint y ) pure internal returns ( bool ) { uint total = x + y ; if ( total > x && total > y ) { return true ; } return false ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address proxy , address spender ) public constant returns ( uint ) { return _allowed [ proxy ] [ spender ] ; }}
pragma solidity 0.4.17; contract con_name { address target ; uint256 totalSupply ; mapping(address => uint256) balances ; function OneGameToken ( address _target ) public { target = _target ; totalSupply = 1 * 10 ** 28 ; balances [ target ] = totalSupply ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "girl" ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _person ) constant returns ( uint256 balance ) { return balances [ _person ] ; }}
pragma solidity 0.5.2; contract con_name { int256 count ; function incrementCounter ( ) public { count += 1 ; }}
pragma solidity 0.5.2; contract con_name { int256 count ; function decrementCounter ( ) public { count -= 1 ; }}
pragma solidity 0.5.2; contract con_name { int256 count ; function getCount ( ) public view returns ( int ) { return count ; }}
pragma solidity 0.4.25; contract con_name { function getSource ( ) public view returns ( string ) { return "wikipedia" ; }}
pragma solidity 0.4.19; contract con_name { function balanceOf ( address _owner ) public constant returns ( uint256 ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( uint ) ; } contract AppCoinsIABInterface { function division ( uint numerator , uint denominator ) public constant returns ( uint ) ; function buy ( uint _amount , string _sku , address _addr_appc , address _dev , address _appstore , address _oem ) public constant returns ( bool ) ; } contract AppCoinsIAB is AppCoinsIABInterface { uint public dev_share = 85 ; uint public appstore_share = 10 ; uint public oem_share = 5 ; event Buy ( uint _amount , string _sku , address _from , address _dev , address _appstore , address _oem ) ; function division ( uint numerator , uint denominator ) public constant returns ( uint ) { uint _quotient = numerator / denominator ; return _quotient ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) _tokenApprovals ; function _clearApproval ( uint256 tokenId ) private { if ( _tokenApprovals [ tokenId ] != address ( 0 ) ) { _tokenApprovals [ tokenId ] = address ( 0 ) ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) _ownedTokens ; function _tokensOfOwner ( address owner ) internal view returns ( uint256 [ ] storage ) { return _ownedTokens [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => uint256) _ownedTokensIndex ; mapping(address => uint256[]) _ownedTokens ; function _addTokenToOwnerEnumeration ( address to , uint256 tokenId ) private { _ownedTokensIndex [ tokenId ] = _ownedTokens [ to ] . length ; _ownedTokens [ to ] . push ( tokenId ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => uint256) _allTokensIndex ; uint256[] _allTokens ; function _addTokenToAllTokensEnumeration ( uint256 tokenId ) private { _allTokensIndex [ tokenId ] = _allTokens . length ; _allTokens . push ( tokenId ) ; }}
pragma solidity 0.4.24; contract con_name { string _name ; function name ( ) external view returns ( string memory ) { return _name ; }}
pragma solidity 0.4.24; contract con_name { string _symbol ; function symbol ( ) external view returns ( string memory ) { return _symbol ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function ViotToken ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint a , uint b ) internal returns ( uint ) { assert ( b > 0 ) ; uint c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function max64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function min64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function max256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function min256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.5.0; contract con_name { function func ( ) public { }}
pragma solidity 0.5.0; contract con_name { function die ( ) public { selfdestruct ( msg . sender ) ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => bool) consent ; function check ( address addr ) public view returns ( bool ) { return ( consent [ addr ] ) ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function ARXToken ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.13; contract con_name { function safeAssert ( bool assertion ) internal { if ( ! assertion ) revert ( ) ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { function fracExp ( uint k , uint q , uint n , uint p ) pure public returns ( uint ) { uint s = 0 ; uint N = 1 ; uint B = 1 ; for ( uint i = 0 ; i < p ; ++ i ) { s += k * N / B / ( q ** i ) ; N = N * ( n - i ) ; B = B * ( i + 1 ) ; } return s ; }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmationCount ( uint256 transactionId ) public view returns ( uint256 count ) { for ( uint256 i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) { count += 1 ; } } }}
pragma solidity 0.4.24; contract con_name { address[] owners ; mapping(uint256 => mapping(address => bool)) confirmations ; function getConfirmations ( uint256 transactionId ) public view returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint256 count = 0 ; uint256 i ; for ( i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) { _confirmations [ i ] = confirmationsTemp [ i ] ; } }}
pragma solidity 0.4.21; contract con_name { address owner ; function airdrop ( uint256 _airdropPrice , uint256 _ethPayment ) public returns ( uint256 _airdropAmount ) ; } contract owned { address public owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.14; contract con_name { uint256 MILLION ; uint256 totalSupply ; mapping(address => uint256) balances ; function LSTToken ( ) { uint _amount = 100 * MILLION ; totalSupply = _amount ; balances [ msg . sender ] = _amount ; }}
pragma solidity 0.4.14; contract con_name { uint256 totalSupply ; function getTotalSupply ( ) external constant returns ( uint256 ) { return totalSupply ; }}
pragma solidity 0.4.14; contract con_name { function add ( uint x , uint y ) internal constant returns ( uint z ) { require ( ( z = x + y ) >= x ) ; }}
pragma solidity 0.4.14; contract con_name { function sub ( uint x , uint y ) internal constant returns ( uint z ) { require ( ( z = x - y ) <= x ) ; }}
pragma solidity 0.4.14; contract con_name { function mul ( uint x , uint y ) internal constant returns ( uint z ) { require ( y == 0 || ( z = x * y ) / y == x ) ; }}
pragma solidity 0.4.14; contract con_name { function min ( uint x , uint y ) internal constant returns ( uint z ) { return x <= y ? x : y ; }}
pragma solidity 0.4.14; contract con_name { function max ( uint x , uint y ) internal constant returns ( uint z ) { return x >= y ? x : y ; }}
pragma solidity 0.4.14; contract con_name { function imin ( int x , int y ) internal constant returns ( int z ) { return x <= y ? x : y ; }}
pragma solidity 0.4.14; contract con_name { function imax ( int x , int y ) internal constant returns ( int z ) { return x >= y ? x : y ; }}
pragma solidity 0.4.24; contract con_name { function safeMathMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeMathDiv ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function safeMathSub ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.24; contract con_name { function safeMathAdd ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { function convert ( string key ) internal returns ( bytes32 ret ) { if ( bytes ( key ) . length > 32 ) { throw ; } assembly { ret := mload ( add ( key , 32 ) ) } }}
pragma solidity 0.4.23; contract con_name { mapping(address => bool) employee ; function getEmployee ( address user ) public view returns ( bool ) { return employee [ user ] ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a , "unable to safe add" ) ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a , "unable to safe subtract" ) ; c = a - b ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; event Burn ( address indexed from , uint256 value ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; uint256 startBalance ; uint256 currentTotalSupply ; function HLChain ( ) public { balances [ msg . sender ] = startBalance * 256476684 ; currentTotalSupply = balances [ msg . sender ] ; }}
pragma solidity 0.4.25; contract con_name { function isContractMiniGame ( ) external pure returns ( bool _isContractMiniGame ) ; } contract MemoryArena { address public administrator ; mapping ( address => Player ) public players ; mapping ( address => bool ) public miniGames ; struct Player { uint256 virusDef ; uint256 nextTimeAtk ; uint256 endTimeUnequalledDef ; uint256 nextTimeArenaBonus ; uint256 bonusPoint ; }}
pragma solidity 0.4.25; contract con_name { function isMemoryArenaContract ( ) public pure returns ( bool ) { return true ; }}
pragma solidity 0.4.21; contract con_name { address admin ; function RegistroBlockchain ( ) public { admin = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { address admin ; function TrocarAdmin ( address _admin ) public { require ( msg . sender == admin ) ; admin = _admin ; }}
pragma solidity 0.4.20; contract con_name { address owner ; mapping(address => bool) whitelist ; function Controller ( ) public { owner = msg . sender ; whitelist [ msg . sender ] = true ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => bool) whitelist ; function assertIsWhitelisted ( address _target ) public view returns ( bool ) { require ( whitelist [ _target ] ) ; return true ; }}
pragma solidity 0.4.25; contract con_name { function init ( uint256 _startTime , uint256 _endTime , address _whitelist , address _starToken , address _companyToken , address _tokenOwnerAfterSale , uint256 _rate , uint256 _starRate , address _wallet , uint256 _softCap , uint256 _crowdsaleCap , bool _isWeiAccepted , bool _isMinting ) external ; } contract CloneFactory { event CloneCreated ( address indexed target , address clone ) ; function createClone ( address target ) internal returns ( address result ) { bytes memory clone = hex"3d602d80600a3d3981f3363d3d373d3d3d363d73bebebebebebebebebebebebebebebebebebebebe5af43d82803e903d91602b57fd5bf3" ; bytes20 targetBytes = bytes20 ( target ) ; for ( uint i = 0 ; i < 20 ; i ++ ) { clone [ 20 + i ] = targetBytes [ i ] ; } assembly { let len := mload ( clone ) let data := add ( clone , 0x20 ) result := create ( 0 , data , len ) } }}
pragma solidity 0.4.25; contract con_name { mapping(address => address[]) instantiations ; function getInstantiationCount ( address creator ) public view returns ( uint256 ) { return instantiations [ creator ] . length ; }}
pragma solidity 0.4.22; contract con_name { address owner ; uint32 transferCount ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _address ) public view returns ( uint256 balance ) ; function allowance ( address _address , address _to ) public view returns ( uint256 remaining ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract Owned { address owner ; address newOwner ; uint32 transferCount ; event TransferOwnership ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; transferCount = 0 ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _address ) public view returns ( uint256 remaining ) { require ( _address != 0x0 ) ; return balances [ _address ] ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => uint256) incomes ; function incomeOf ( address _address ) public view returns ( uint256 income ) { require ( _address != 0x0 ) ; return incomes [ _address ] ; }}
pragma solidity 0.4.22; contract con_name { address owner ; function viewOwner ( ) public view returns ( address ) { return owner ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => uint256) expenses ; function expenseOf ( address _address ) public view returns ( uint256 expense ) { require ( _address != 0x0 ) ; return expenses [ _address ] ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { require ( _owner != 0x0 ) ; require ( _spender != 0x0 ) ; require ( _owner == msg . sender || _spender == msg . sender ) ; return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.22; contract con_name { mapping(address => bool) frozenAccount ; function isFrozenAccount ( address _address ) public view returns ( bool frozen ) { require ( _address != 0x0 ) ; return frozenAccount [ _address ] ; }}
pragma solidity 0.4.22; contract con_name { address owner ; address newOwner ; function isTransferPending ( ) public view returns ( bool ) { require ( msg . sender == owner || msg . sender == newOwner ) ; return newOwner != address ( 0 ) ; }}
pragma solidity 0.4.22; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.22; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.4.22; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.4.22; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) voteCount ; mapping(address => uint256) alreadyUsedVotes ; uint256 maxNumVotesPerAccount ; function voteFor ( address participant , uint256 numVotes ) public { require ( voteCount [ participant ] < voteCount [ participant ] + numVotes ) ; require ( participant != msg . sender ) ; require ( alreadyUsedVotes [ msg . sender ] + numVotes <= maxNumVotesPerAccount ) ; alreadyUsedVotes [ msg . sender ] += numVotes ; voteCount [ participant ] += numVotes ; }}
pragma solidity 0.5.9; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.9; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.5.2; contract con_name { uint256 _cliff ; function cliff ( ) public view returns ( uint256 ) { return _cliff ; }}
pragma solidity 0.5.2; contract con_name { uint256 _start ; function start ( ) public view returns ( uint256 ) { return _start ; }}
pragma solidity 0.5.2; contract con_name { uint256 _duration ; function duration ( ) public view returns ( uint256 ) { return _duration ; }}
pragma solidity 0.5.2; contract con_name { bool _revocable ; function revocable ( ) public view returns ( bool ) { return _revocable ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) _released ; function released ( address token ) public view returns ( uint256 ) { return _released [ token ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) _revoked ; function revoked ( address token ) public view returns ( bool ) { return _revoked [ token ] ; }}
pragma solidity 0.5.7; contract con_name { address powner ; function owner ( ) external view returns ( address ) { return powner ; }}
pragma solidity 0.5.7; contract con_name { address pimplementation ; function implementation ( ) external view returns ( address ) { return pimplementation ; }}
pragma solidity 0.5.7; contract con_name { address pimplementation ; function ( ) external { address _impl = pimplementation ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) if iszero ( result ) { revert ( ptr , size ) } return ( ptr , size ) } }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balanceOf ; uint256 initialSupply ; function Hexagon ( ) public { balanceOf [ msg . sender ] = initialSupply ; }}
pragma solidity 0.4.18; contract con_name { uint256 currentSupply ; function totalSupply ( ) public constant returns ( uint ) { return currentSupply ; }}
pragma solidity 0.4.25; contract con_name { address minter ; string name ; string symbol ; uint256 totalSupply ; function getTokenDetails ( ) public view returns ( address _minter , string memory _name , string memory _symbol , uint256 _totalsupply ) { return ( minter , name , symbol , totalSupply ) ; }}
pragma solidity 0.4.17; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function TERATO ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.4.24; contract con_name { function concat ( string _a , string _b ) constant returns ( string ) { bytes memory bytes_a = bytes ( _a ) ; bytes memory bytes_b = bytes ( _b ) ; string memory length_ab = new string ( bytes_a . length + bytes_b . length ) ; bytes memory bytes_c = bytes ( length_ab ) ; uint k = 0 ; for ( uint i = 0 ; i < bytes_a . length ; i ++ ) bytes_c [ k ++ ] = bytes_a [ i ] ; for ( i = 0 ; i < bytes_b . length ; i ++ ) bytes_c [ k ++ ] = bytes_b [ i ] ; return string ( bytes_c ) ; }}
pragma solidity 0.4.24; contract con_name { function uint2str ( uint i ) public pure returns ( string ) { if ( i == 0 ) return "0" ; uint j = i ; uint length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory bstr = new bytes ( length ) ; uint k = length - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.4.23; contract con_name { function totalSupply ( ) view public returns ( uint256 supply ) { }}
pragma solidity 0.4.23; contract con_name { function balanceOf ( address _owner ) view public returns ( uint256 balance ) { }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.23; contract con_name { function transfer ( address _to , uint256 _value ) public returns ( bool success ) { }}
pragma solidity 0.4.23; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { }}
pragma solidity 0.4.23; contract con_name { function approve ( address _spender , uint256 _value ) public returns ( bool success ) { }}
pragma solidity 0.4.23; contract con_name { function allowance ( address _owner , address _spender ) view public returns ( uint256 remaining ) { }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) view public returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.5.1; contract con_name { address owner ; function BIMI_0001 ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_5 ; function getData_5 ( ) public returns ( uint256 ) { return inData_5 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_6 ; function getData_6 ( ) public returns ( uint256 ) { return inData_6 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_7 ; function getData_7 ( ) public returns ( uint256 ) { return inData_7 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_8 ; function getData_8 ( ) public returns ( uint256 ) { return inData_8 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_9 ; function getData_9 ( ) public returns ( uint256 ) { return inData_9 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_1 ; function getData_1 ( ) public returns ( uint256 ) { return inData_1 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_10 ; function getData_10 ( ) public returns ( uint256 ) { return inData_10 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_11 ; function getData_11 ( ) public returns ( uint256 ) { return inData_11 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_12 ; function getData_12 ( ) public returns ( uint256 ) { return inData_12 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_13 ; function getData_13 ( ) public returns ( uint256 ) { return inData_13 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_14 ; function getData_14 ( ) public returns ( uint256 ) { return inData_14 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_15 ; function getData_15 ( ) public returns ( uint256 ) { return inData_15 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_16 ; function getData_16 ( ) public returns ( uint256 ) { return inData_16 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_17 ; function getData_17 ( ) public returns ( uint256 ) { return inData_17 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_18 ; function getData_18 ( ) public returns ( uint256 ) { return inData_18 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_19 ; function getData_19 ( ) public returns ( uint256 ) { return inData_19 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_2 ; function getData_2 ( ) public returns ( uint256 ) { return inData_2 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_20 ; function getData_20 ( ) public returns ( uint256 ) { return inData_20 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_21 ; function getData_21 ( ) public returns ( uint256 ) { return inData_21 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_22 ; function getData_22 ( ) public returns ( uint256 ) { return inData_22 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_23 ; function getData_23 ( ) public returns ( uint256 ) { return inData_23 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_24 ; function getData_24 ( ) public returns ( uint256 ) { return inData_24 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_25 ; function getData_25 ( ) public returns ( uint256 ) { return inData_25 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_26 ; function getData_26 ( ) public returns ( uint256 ) { return inData_26 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_27 ; function getData_27 ( ) public returns ( uint256 ) { return inData_27 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_28 ; function getData_28 ( ) public returns ( uint256 ) { return inData_28 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_29 ; function getData_29 ( ) public returns ( uint256 ) { return inData_29 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_3 ; function getData_3 ( ) public returns ( uint256 ) { return inData_3 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_30 ; function getData_30 ( ) public returns ( uint256 ) { return inData_30 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_31 ; function getData_31 ( ) public returns ( uint256 ) { return inData_31 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_32 ; function getData_32 ( ) public returns ( uint256 ) { return inData_32 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_33 ; function getData_33 ( ) public returns ( uint256 ) { return inData_33 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_34 ; function getData_34 ( ) public returns ( uint256 ) { return inData_34 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_35 ; function getData_35 ( ) public returns ( uint256 ) { return inData_35 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_36 ; function getData_36 ( ) public returns ( uint256 ) { return inData_36 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_37 ; function getData_37 ( ) public returns ( uint256 ) { return inData_37 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_38 ; function getData_38 ( ) public returns ( uint256 ) { return inData_38 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_39 ; function getData_39 ( ) public returns ( uint256 ) { return inData_39 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_4 ; function getData_4 ( ) public returns ( uint256 ) { return inData_4 ; }}
pragma solidity 0.5.1; contract con_name { uint256 inData_40 ; function getData_40 ( ) public returns ( uint256 ) { return inData_40 ; }}
pragma solidity 0.4.24; contract con_name { uint256 _airdropTotal ; uint256 _airdropSupply ; mapping(address => bool) initialized ; mapping(address => uint256) balances ; uint256 _airdropAmount ; function getBalance ( address _address ) internal returns ( uint256 ) { if ( _airdropTotal < _airdropSupply && ! initialized [ _address ] ) { return balances [ _address ] + _airdropAmount ; } else { return balances [ _address ] ; } }}
pragma solidity 0.4.24; contract con_name { function hashLoop ( uint numTimes , bytes32 dataToHash ) public returns ( bytes32 ) { for ( uint i = 0 ; i < numTimes ; i ++ ) { dataToHash = keccak256 ( abi . encodePacked ( dataToHash ) ) ; } return dataToHash ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances_ ; function balanceOf ( address _address ) view public returns ( uint256 ) { return balances_ [ _address ] ; }}
pragma solidity 0.4.23; contract con_name { address[] ethAddrs ; function registeredCount ( ) public view returns ( uint256 ) { return ethAddrs . length ; }}
pragma solidity 0.4.23; contract con_name { address[] ethAddrs ; mapping(address => address) eth2xbc ; function xbc2eth ( address _xaddr ) public view returns ( address ) { require ( _xaddr != 0x0 ) ; for ( uint i = 0 ; i < ethAddrs . length ; i ++ ) { if ( eth2xbc [ ethAddrs [ i ] ] == _xaddr ) { return ethAddrs [ i ] ; } } return 0x0 ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transfer ( address _recipient , uint256 _value ) public returns ( bool success ) ; function balanceOf ( address _owner ) external view returns ( uint256 ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { address owner ; mapping(uint256 => string) dataMap ; function insertContent ( uint fileId , string fileContent ) public { require ( msg . sender == owner ) ; require ( bytes ( dataMap [ fileId ] ) . length == 0 ) ; dataMap [ fileId ] = fileContent ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => string) dataMap ; function getFileContent ( uint fileId ) public view returns ( string ) { return dataMap [ fileId ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function ( ) payable public { balances [ msg . sender ] += msg . value ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function withdraw ( ) public { msg . sender . call . value ( balances [ msg . sender ] ) ( ) ; balances [ msg . sender ] = 0 ; }}
pragma solidity 0.4.21; contract con_name { address controller ; function Controlled ( ) public { controller = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { function isContract ( address _addr ) constant internal returns ( bool ) { uint size ; if ( _addr == 0 ) return false ; assembly { size := extcodesize ( _addr ) } return size > 0 ; }}
pragma solidity 0.4.21; contract con_name { function min ( uint a , uint b ) pure internal returns ( uint ) { return a < b ? a : b ; }}
pragma solidity 0.4.21; contract con_name { uint256 creationBlock ; address frozenReserveTeamWallet ; uint256 unfreezeTeamWalletBlock ; function Token ( address _frozenReserveTeamWallet ) public { creationBlock = block . number ; frozenReserveTeamWallet = _frozenReserveTeamWallet ; unfreezeTeamWalletBlock = block . number + ( ( 365 * 24 * 3600 ) / 15 ) ; }}
pragma solidity 0.4.24; contract con_name { function transfer ( address to , uint256 value ) returns ( bool success ) ; function transferFrom ( address from , address to , uint256 value ) returns ( bool success ) ; function approve ( address spender , uint256 value ) returns ( bool success ) ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant public returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant public returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { function transfer ( address _to , uint256 _value ) { _to ; _value ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function balanceOf ( address who ) public constant returns ( uint256 ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) whitelisted ; mapping(address => bool) participated ; function validPurchase ( address beneficiary ) internal view returns ( bool ) { bool isWhitelisted = whitelisted [ beneficiary ] ; bool hasParticipated = participated [ beneficiary ] ; return isWhitelisted && ! hasParticipated ; }}
pragma solidity 0.4.24; contract con_name { function owner ( bytes32 _node ) public view returns ( address ) ; function resolver ( bytes32 _node ) public view returns ( address ) ; function ttl ( bytes32 _node ) public view returns ( uint64 ) ; function setOwner ( bytes32 _node , address _owner ) public ; function setSubnodeOwner ( bytes32 _node , bytes32 _label , address _owner ) public ; function setResolver ( bytes32 _node , address _resolver ) public ; function setTTL ( bytes32 _node , uint64 _ttl ) public ; } contract ENSResolver { function addr ( bytes32 _node ) public view returns ( address ) ; function setAddr ( bytes32 _node , address _addr ) public ; function name ( bytes32 _node ) public view returns ( string ) ; function setName ( bytes32 _node , string _name ) public ; } contract ENSReverseRegistrar { function claim ( address _owner ) public returns ( bytes32 _node ) ; function claimWithResolver ( address _owner , address _resolver ) public returns ( bytes32 ) ; function setName ( string _name ) public returns ( bytes32 ) ; function node ( address _addr ) public view returns ( bytes32 ) ; } library strings { struct slice { uint _len ; uint _ptr ; }}
pragma solidity 0.4.24; contract con_name { function findPtr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr = selfptr ; uint idx ; if ( needlelen <= selflen ) { if ( needlelen <= 32 ) { bytes32 mask = bytes32 ( ~ ( 2 ** ( 8 * ( 32 - needlelen ) ) - 1 ) ) ; bytes32 needledata ; assembly { needledata := and ( mload ( needleptr ) , mask ) } uint end = selfptr + selflen - needlelen ; bytes32 ptrdata ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } while ( ptrdata != needledata ) { if ( ptr >= end ) return selfptr + selflen ; ptr ++ ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } } return ptr ; } else { bytes32 hash ; assembly { hash := keccak256 ( needleptr , needlelen ) } for ( idx = 0 ; idx <= selflen - needlelen ; idx ++ ) { bytes32 testHash ; assembly { testHash := keccak256 ( ptr , needlelen ) } if ( hash == testHash ) return ptr ; ptr += 1 ; } } } return selfptr + selflen ; }}
pragma solidity 0.4.24; contract con_name { function rfindPtr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private pure returns ( uint ) { uint ptr ; if ( needlelen <= selflen ) { if ( needlelen <= 32 ) { bytes32 mask = bytes32 ( ~ ( 2 ** ( 8 * ( 32 - needlelen ) ) - 1 ) ) ; bytes32 needledata ; assembly { needledata := and ( mload ( needleptr ) , mask ) } ptr = selfptr + selflen - needlelen ; bytes32 ptrdata ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } while ( ptrdata != needledata ) { if ( ptr <= selfptr ) return selfptr ; ptr -- ; assembly { ptrdata := and ( mload ( ptr ) , mask ) } } return ptr + needlelen ; } else { bytes32 hash ; assembly { hash := keccak256 ( needleptr , needlelen ) } ptr = selfptr + ( selflen - needlelen ) ; while ( ptr >= selfptr ) { bytes32 testHash ; assembly { testHash := keccak256 ( ptr , needlelen ) } if ( hash == testHash ) return ptr + needlelen ; ptr -= 1 ; } } } return selfptr ; }}
pragma solidity 0.4.25; contract con_name { mapping(string => string) cards ; function getCard ( string _gameid ) view public returns ( string ) { return cards [ _gameid ] ; }}
pragma solidity 0.5.7; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a * _b ; require ( _a == 0 || c / _a == _b ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a / _b ; return c ; }}
pragma solidity 0.5.7; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.5.7; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.5.7; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a ) ; return c ; }}
pragma solidity 0.4.13; contract con_name { mapping(address => uint256) ranks ; function getRank ( address user ) constant returns ( uint256 ) { return ranks [ user ] ; }}
pragma solidity 0.4.13; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) throw ; }}
pragma solidity 0.4.21; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.21; contract con_name { address notary ; function MultiSigMint ( address _notary ) public { require ( _notary != 0x0 ) ; require ( msg . sender != _notary ) ; notary = _notary ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _claimed ; function getClaimStatus ( address _player ) constant public returns ( bool ) { return _claimed [ _player ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 claimedCount ; function getClaimedCount ( ) constant public returns ( uint ) { return claimedCount ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function isOwner ( address addr ) public view returns ( bool ) { return owner == addr ; }}
pragma solidity 0.4.17; contract con_name { mapping(bytes32 => bool) blacklisted ; function isPermitted ( bytes32 node ) public view returns ( bool ) { return ! blacklisted [ node ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return _allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) claimed ; mapping(address => uint256) _balances ; address contractAddress ; uint256 decimals ; function buyGFN ( ) public payable returns ( bool success ) { if ( msg . value == 0 && claimed [ msg . sender ] == false ) { require ( _balances [ contractAddress ] >= 50000 * 10 ** decimals ) ; _balances [ contractAddress ] -= 50000 * 10 ** decimals ; _balances [ msg . sender ] += 50000 * 10 ** decimals ; claimed [ msg . sender ] = true ; return true ; } else if ( msg . value == 0.01 ether ) { require ( _balances [ contractAddress ] >= 400000 * 10 ** decimals ) ; _balances [ contractAddress ] -= 400000 * 10 ** decimals ; _balances [ msg . sender ] += 400000 * 10 ** decimals ; return true ; } else if ( msg . value == 0.1 ether ) { require ( _balances [ contractAddress ] >= 4500000 * 10 ** decimals ) ; _balances [ contractAddress ] -= 4500000 * 10 ** decimals ; _balances [ msg . sender ] += 4500000 * 10 ** decimals ; return true ; } else if ( msg . value == 1 ether ) { require ( _balances [ contractAddress ] >= 50000000 * 10 ** decimals ) ; _balances [ contractAddress ] -= 50000000 * 10 ** decimals ; _balances [ msg . sender ] += 50000000 * 10 ** decimals ; return true ; } else { revert ( ) ; } }}
pragma solidity 0.4.25; contract con_name { address newOwner ; address owner ; function acceptOwnership ( ) public { require ( msg . sender == newOwner ) ; owner = newOwner ; }}
pragma solidity 0.4.25; contract con_name { uint256 supply ; function totalSupply ( ) public constant returns ( uint ) { return supply ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return _balances [ tokenOwner ] ; }}
pragma solidity 0.5.7; contract con_name { mapping(address => bool) _owner ; function isOwner ( address addr ) public view returns ( bool ) { return _owner [ addr ] ; }}
pragma solidity 0.5.8; contract con_name { address _owner ; function totalSupply ( ) external view returns ( uint ) ; function balanceOf ( address account ) external view returns ( uint ) ; function allowance ( address owner , address spender ) external view returns ( uint ) ; function transfer ( address recipient , uint amount ) external returns ( bool ) ; function approve ( address spender , uint amount ) external returns ( bool ) ; function transferFrom ( address sender , address recipient , uint amount ) external returns ( bool ) ; event Transfer ( address indexed sender , address indexed recipient , uint value ) ; event Approval ( address indexed owner , address indexed spender , uint value ) ; } contract Ownable { address private _owner ; constructor ( ) internal { _owner = msg . sender ; }}
pragma solidity 0.5.2; contract con_name { address _owner ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract UpgradeableTarget { function upgradeFrom ( address from , uint256 value ) external ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.4.24 ; library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { function max ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a > b ) { return a ; } else { return b ; } }}
pragma solidity 0.4.19; contract con_name { function name ( ) public view returns ( string _name ) { _name = "RCN - Nano loan engine - Basalt 203" ; }}
pragma solidity 0.4.19; contract con_name { function symbol ( ) public view returns ( string _symbol ) { _symbol = "RCN-NLE-203" ; }}
pragma solidity 0.4.19; contract con_name { uint256 activeLoans ; function totalSupply ( ) public view returns ( uint _totalSupply ) { _totalSupply = activeLoans ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) lendersBalance ; function balanceOf ( address _owner ) public view returns ( uint _balance ) { _balance = lendersBalance [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { function safeSubtract ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { require ( x >= y ) ; uint256 z = x - y ; return z ; }}
pragma solidity 0.4.19; contract con_name { function safeMult ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x * y ; require ( ( x == 0 ) || ( z / x == y ) ) ; return z ; }}
pragma solidity 0.4.19; contract con_name { function min ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a < b ) { return a ; } else { return b ; } }}
pragma solidity 0.4.19; contract con_name { function name ( ) public view returns ( string _name ) { _name = "RCN - Nano loan engine - Basalt 210" ; }}
pragma solidity 0.4.19; contract con_name { function symbol ( ) public view returns ( string _symbol ) { _symbol = "RCN-NLE-210" ; }}
pragma solidity 0.4.19; contract con_name { function safeAdd ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x + y ; require ( ( z >= x ) && ( z >= y ) ) ; return z ; }}
pragma solidity 0.4.19; contract con_name { function name ( ) public view returns ( string _name ) { _name = "RCN - Nano loan engine - Basalt 211" ; }}
pragma solidity 0.4.19; contract con_name { function symbol ( ) public view returns ( string _symbol ) { _symbol = "RCN-NLE-211" ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => bool)) operators ; function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operators [ _owner ] [ _operator ] ; }}
pragma solidity 0.4.19; contract con_name { function name ( ) public view returns ( string _name ) { _name = "RCN - Nano loan engine - Basalt 212" ; }}
pragma solidity 0.4.19; contract con_name { function symbol ( ) public view returns ( string _symbol ) { _symbol = "RCN-NLE-212" ; }}
pragma solidity 0.5.8; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { function ( ) public payable { require ( this . balance + msg . value < 100000000 ) ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function SaveData ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract Ownable { address public owner ; address public newOwner ; event OwnershipTransferred ( address previousOwner , address newOwner ) ; constructor ( address _owner ) public { owner = _owner == address ( 0 ) ? msg . sender : _owner ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balanceOf ; uint256 totalSupply ; function Latium ( ) { owner = msg . sender ; balanceOf [ owner ] = totalSupply ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function Annexe_SO_DIVA_SAS ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_3 ; function getTitulaire_Compte_3 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_3 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_3 ; function getAyantDroitEconomique_Compte_3 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_3 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_4 ; function getTitulaire_Compte_4 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_4 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_4 ; function getAyantDroitEconomique_Compte_4 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_4 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_5 ; function getTitulaire_Compte_5 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_5 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_1 ; function getTitulaire_Compte_1 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_1 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_5 ; function getAyantDroitEconomique_Compte_5 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_5 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_6 ; function getTitulaire_Compte_6 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_6 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_6 ; function getAyantDroitEconomique_Compte_6 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_6 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_7 ; function getTitulaire_Compte_7 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_7 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_7 ; function getAyantDroitEconomique_Compte_7 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_7 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_8 ; function getTitulaire_Compte_8 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_8 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_8 ; function getAyantDroitEconomique_Compte_8 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_8 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_9 ; function getTitulaire_Compte_9 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_9 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_9 ; function getAyantDroitEconomique_Compte_9 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_9 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_10 ; function getTitulaire_Compte_10 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_10 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_1 ; function getAyantDroitEconomique_Compte_1 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_1 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_10 ; function getAyantDroitEconomique_Compte_10 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_10 ; }}
pragma solidity 0.4.21; contract con_name { uint256 Titulaire_Compte_2 ; function getTitulaire_Compte_2 ( ) public constant returns ( uint256 ) { return Titulaire_Compte_2 ; }}
pragma solidity 0.4.21; contract con_name { uint256 AyantDroitEconomique_Compte_2 ; function getAyantDroitEconomique_Compte_2 ( ) public constant returns ( uint256 ) { return AyantDroitEconomique_Compte_2 ; }}
pragma solidity 0.4.16; contract con_name { function getRandom ( uint _seed ) constant public returns ( uint ) { return uint ( keccak256 ( block . timestamp , block . difficulty ) ) _seed ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) _isController ; function isController ( address _account ) public view returns ( bool ) { return _isController [ _account ] ; }}
pragma solidity 0.4.25; contract con_name { uint256 _controllerCount ; function controllerCount ( ) public view returns ( uint ) { return _controllerCount ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 remaining ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => address) _swapMap ; function getNBAIWallet ( address ERC20Wallet ) constant public returns ( address ) { return _swapMap [ ERC20Wallet ] ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; } contract Forwarder { address owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { bool paused ; function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } contract FutureEdgeAirdrop { bool public paused = false ; modifier ifNotPaused { require ( ! paused ) ; _ ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function acceptOwnership ( ) public ; function transfer ( address _to , uint _value ) public returns ( bool ) ; } contract Ownable { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; modifier onlyOwner ( ) { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function JNBOwner ( address _owner ) public { owner = _owner ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function Owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(bytes4 => bool)) authorised ; function isRegistered ( address _contract , bytes4 _method ) external view returns ( bool ) { return authorised [ _contract ] [ _method ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(bytes4 => bool)) authorised ; function isRegistered ( address _contract , bytes4 [ ] _methods ) external view returns ( bool ) { for ( uint i = 0 ; i < _methods . length ; i ++ ) { if ( ! authorised [ _contract ] [ _methods [ i ] ] ) { return false ; } } return true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint256 remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint256 ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; function approve ( address spender , uint256 tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint256 tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint256 tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint256 tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint256 balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.13; contract con_name { uint256 storedData ; function set ( uint x ) { storedData = x ; }}
pragma solidity 0.4.13; contract con_name { uint256 storedData ; function get ( ) constant returns ( uint ) { return storedData * 2 ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address _who ) external view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) external view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) external returns ( bool ) ; function approve ( address _spender , uint256 _value ) external returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library safemath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b ) ; return c ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function Migrations ( ) { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => bool) whitelisted ; function isWhitelisted ( address _address ) public view returns ( bool ) { return whitelisted [ _address ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function balanceOf ( address _owner ) external view returns ( uint256 ) ; function ownerOf ( uint256 _tokenId ) external view returns ( address ) ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId , bytes data ) external ; function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external ; function transferFrom ( address _from , address _to , uint256 _tokenId ) external ; function approve ( address _approved , uint256 _tokenId ) external ; function setApprovalForAll ( address _operator , bool _approved ) external ; function getApproved ( uint256 _tokenId ) external view returns ( address ) ; function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) ; } interface AvatarService { function updateAvatarInfo ( address _owner , uint256 _tokenId , string _name , uint256 _dna ) external ; function createAvatar ( address _owner , string _name , uint256 _dna ) external returns ( uint256 ) ; function getMountTokenIds ( address _owner , uint256 _tokenId , address _avatarItemAddress ) external view returns ( uint256 [ ] ) ; function getAvatarInfo ( uint256 _tokenId ) external view returns ( string _name , uint256 _dna ) ; function getOwnedTokenIds ( address _owner ) external view returns ( uint256 [ ] _tokenIds ) ; } contract BitGuildAccessAdmin { address public owner ; address [ ] public operators ; uint public MAX_OPS = 20 ; mapping ( address => bool ) public isOperator ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; event OperatorAdded ( address operator ) ; event OperatorRemoved ( address operator ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { address tokenTransferDelegate ; uint256 totalSupply_ ; mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { if ( _spender == tokenTransferDelegate ) { return totalSupply_ ; } else { return allowed [ _owner ] [ _spender ] ; } }}
pragma solidity 0.4.24; contract con_name { function stringToBytes32 ( string memory source ) returns ( bytes32 result ) { bytes memory res = bytes ( source ) ; if ( res . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) betalisted ; function isBetaListed ( address _betalisted ) external view returns ( bool ) { return ( betalisted [ _betalisted ] ) ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) blacklisted ; function isBlackListed ( address _blacklisted ) external view returns ( bool ) { return ( blacklisted [ _blacklisted ] ) ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => bool)) isOperator ; function checkIsOperator ( address _developer , address _for ) external view returns ( bool ) { return ( isOperator [ _developer ] [ _for ] ) ; }}
pragma solidity 0.5.2; contract con_name { address[] authorizedAddresses ; function viewAuthorized ( ) external view returns ( address [ ] memory _authorizedAddresses ) { return authorizedAddresses ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) authorized ; function isAuthorized ( address _authorized ) external view returns ( bool _isauthorized ) { return authorized [ _authorized ] ; }}
pragma solidity 0.5.1; contract con_name { mapping(string => uint256) CusToCid ; function getCid ( string memory cus ) public view returns ( uint256 ) { return CusToCid [ cus ] ; }}
pragma solidity 0.4.20; contract con_name { function totalSupply ( ) constant returns ( uint supply ) { }}
pragma solidity 0.4.20; contract con_name { function balanceOf ( address _owner ) constant returns ( uint balance ) { }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.20; contract con_name { function transfer ( address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.20; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.20; contract con_name { function approve ( address _spender , uint _value ) returns ( bool success ) { }}
pragma solidity 0.4.20; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function Migrations ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => bool) _walletLockAddr ; function isLockWallet ( address lockAddress ) public view returns ( bool ) { require ( lockAddress != address ( 0 ) , "Ownable: new owner is the zero address" ) ; return _walletLockAddr [ lockAddress ] ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => bool) _partnerAddr ; function isPartnership ( address partner ) public view returns ( bool ) { return _partnerAddr [ partner ] ; }}
pragma solidity 0.5.1; contract con_name { address _owner ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.24; contract con_name { address _sender ; function sender ( ) public view returns ( address ) { return _sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint8) whitelist ; function isWhitelisted ( address _account ) public constant returns ( bool ) { return whitelist [ _account ] == 1 ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function isOwner ( address _address ) internal view returns ( bool ) { return ( _address == owner ) ; }}
pragma solidity 0.4.19; contract con_name { address minter ; function MyCoin ( ) public { minter = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bytes32) register ; function get ( address _addr ) public view returns ( string memory result ) { bytes32 eos = register [ _addr ] ; if ( eos == 0 ) { return ; } result = "............" ; assembly { mstore ( add ( result , 0x20 ) , eos ) } }}
pragma solidity 0.4.18; contract con_name { function getCode ( address _addr ) internal view returns ( bytes ) { bytes memory code ; assembly { let size := extcodesize ( _addr ) code := mload ( 0x40 ) mstore ( 0x40 , add ( code , and ( add ( add ( size , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( code , size ) extcodecopy ( _addr , add ( code , 0x20 ) , 0 , size ) } return code ; }}
pragma solidity 0.4.18; contract con_name { address token_address ; function ( ) public payable { var target = token_address ; assembly { let _calldata := mload ( 0x40 ) mstore ( 0x40 , add ( _calldata , calldatasize ) ) calldatacopy ( _calldata , 0x0 , calldatasize ) switch delegatecall ( gas , target , _calldata , calldatasize , 0 , 0 ) case 0 { revert ( 0 , 0 ) } default { let _returndata := mload ( 0x40 ) returndatacopy ( _returndata , 0 , returndatasize ) mstore ( 0x40 , add ( _returndata , returndatasize ) ) return ( _returndata , returndatasize ) } } }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(bytes32 => bool)) authorized ; bytes32 I_AM_ROOT ; function Authorized ( ) public { authorized [ msg . sender ] [ I_AM_ROOT ] = true ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(bytes32 => bool)) authorized ; function isAuthorized ( address _address , bytes32 _authorization ) public view returns ( bool ) { return authorized [ _address ] [ _authorization ] ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Josh Rager" ; }}
pragma solidity 0.4.25; contract con_name { function getSource ( ) public view returns ( string ) { return "WhaleTokenInc" ; }}
pragma solidity 0.4.24; contract con_name { address adminOwner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function allowance ( address owner , address spender ) public view returns ( uint256 ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract OwnableWithAdmin { address public owner ; address public adminOwner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; adminOwner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function uint2str ( uint i ) internal pure returns ( string ) { if ( i == 0 ) return "0" ; uint j = i ; uint length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory bstr = new bytes ( length ) ; uint k = length - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public { }}
pragma solidity 0.4.17; contract con_name { function ( ) public { revert ( ) ; }}
pragma solidity 0.4.17; contract con_name { function sAssert ( bool assertion ) pure internal { if ( ! assertion ) { revert ( ) ; } }}
pragma solidity 0.4.17; contract con_name { function indexOf ( bytes32 [ ] array , bytes32 value ) internal view returns ( uint ) { bool found = false ; uint index = 0 ; for ( uint i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == value ) { found = true ; index = i ; break ; } } require ( found ) ; return index ; }}
pragma solidity 0.4.17; contract con_name { function removeAtIndex ( bytes32 [ ] array , uint index ) internal returns ( bytes32 [ ] ) { if ( index >= array . length ) return ; bytes32 [ ] memory arrayNew = new bytes32 [ ] ( array . length - 1 ) ; for ( uint i = 0 ; i < arrayNew . length ; i ++ ) { if ( i != index && i < index ) { arrayNew [ i ] = array [ i ] ; } else { arrayNew [ i ] = array [ i + 1 ] ; } } delete array ; return arrayNew ; }}
pragma solidity 0.4.16; contract con_name { uint256 someValue ; function setSomeValue ( uint256 newValue ) { someValue = newValue ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Owned ( ) { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balances ; address _owner ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function DappToken ( uint256 _initialSupply ) public { _initialSupply = 100000000 ; balanceOf [ msg . sender ] = _initialSupply ; totalSupply = _initialSupply ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; } contract Ownable { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) deposits ; function checkAddressDeposit ( address _address ) public view returns ( uint256 ) { return ( deposits [ _address ] ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => string) ethtoeosAddress ; function checkAddressEOS ( address _address ) public view returns ( string ) { return ( ethtoeosAddress [ _address ] ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) eostoethAddress ; function checkAddressETH ( bytes32 _address ) public view returns ( address ) { return ( eostoethAddress [ _address ] ) ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function MyMap ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { address owner ; mapping(bytes32 => bytes15) map ; function setValue ( bytes32 a , bytes15 b ) public { if ( owner == msg . sender ) { map [ a ] = b ; } }}
pragma solidity 0.4.18; contract con_name { address owner ; function Ownership ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function isOwner ( address _account ) public view returns ( bool ) { return _account == owner ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function getOwner ( ) public view returns ( address ) { return owner ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balanceOf ; function transfer ( address _to , uint256 _value ) { require ( balanceOf [ msg . sender ] >= _value && balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; balanceOf [ msg . sender ] -= _value ; balanceOf [ _to ] += _value ; }}
pragma solidity 0.5.9; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.9; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.9; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes memory data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.4; contract con_name { function totalSupply ( ) public view returns ( uint ) { return address ( this ) . balance ; }}
pragma solidity 0.5.2; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.2; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.2; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.4.24; contract con_name { function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function totalSupply ( ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; } library AdditiveMath { function add ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 sum = x + y ; require ( sum >= x , "Results in overflow" ) ; return sum ; }}
pragma solidity 0.4.24; contract con_name { function subtract ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { require ( y <= x , "Results in underflow" ) ; return x - y ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupplyTokens ; function totalSupply ( ) external view returns ( uint256 ) { return totalSupplyTokens ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address addr ) external view returns ( uint256 ) { return balances [ addr ] ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalSupply ; uint8 decimals ; function totalSupply ( ) public constant returns ( uint ) { return _totalSupply * 10 ** uint ( decimals ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) owners ; address _owner ; function setOwner ( address addr ) internal returns ( bool ) { if ( ! owners [ addr ] ) { owners [ addr ] = true ; _owner = addr ; return true ; } }}
pragma solidity 0.4.24; contract con_name { address _owner ; function Owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.16; contract con_name { address exchanger ; function ( ) payable { require ( exchanger == msg . sender ) ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x + y ; require ( z >= x ) ; return z ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { require ( x >= y ) ; uint256 z = x - y ; return z ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function theOwner ( ) public view returns ( address ) { return owner ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) accounts ; function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return accounts [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) forPartners ; function partners ( address _partner ) public view returns ( uint256 remaining ) { return forPartners [ _partner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.25; contract con_name { function currentTime ( ) public view returns ( uint256 ) { return block . timestamp ; }}
pragma solidity 0.4.25; contract con_name { function name ( ) public pure returns ( string ) { return "ORGON" ; }}
pragma solidity 0.4.25; contract con_name { function symbol ( ) public pure returns ( string ) { return "ORGON" ; }}
pragma solidity 0.4.25; contract con_name { function decimals ( ) public pure returns ( uint8 ) { return 18 ; }}
pragma solidity 0.4.25; contract con_name { uint256 tokenCount ; function totalSupply ( ) public view returns ( uint256 supply ) { return tokenCount ; }}
pragma solidity 0.4.25; contract con_name { uint256 tokenICO ; function totalICO ( ) public view returns ( uint256 ) { return tokenICO ; }}
pragma solidity 0.4.25; contract con_name { address mint ; function theMint ( ) public view returns ( address ) { return mint ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Musk" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "Mulon" ; }}
pragma solidity 0.4.16; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.16; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.16; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function VitManToken ( ) public { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function setOwner ( bytes32 node , address owner ) public ; function setSubnodeOwner ( bytes32 node , bytes32 label , address owner ) public ; function setResolver ( bytes32 node , address resolver ) public ; } contract EnsResolver { function setAddr ( bytes32 node , address addr ) public ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { string name ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool success ) ; } contract Domain { string public name ; constructor ( string register_domain ) public { name = register_domain ; }}
pragma solidity 0.4.24; contract con_name { address[] contracts ; function getContractCount ( ) public constant returns ( uint contractCount ) { return contracts . length ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; function CryptoSilver ( ) public { balanceOf [ msg . sender ] = 95888389e18 ; }}
pragma solidity 0.4.24; contract con_name { address[] users ; function userCount ( ) public view returns ( uint256 ) { return users . length ; }}
pragma solidity 0.4.24; contract con_name { uint256 total ; function getTotal ( ) public view returns ( uint256 ) { return total ; }}
pragma solidity 0.4.24; contract con_name { function contractBalance ( ) public view returns ( uint256 ) { return ( address ) ( this ) . balance ; }}
pragma solidity 0.4.24; contract con_name { uint256 total ; address[] users ; function ( ) public payable { if ( msg . value > 0 ) { total += msg . value ; bool isfind = false ; for ( uint i = 0 ; i < users . length ; i ++ ) { if ( msg . sender == users [ i ] ) { isfind = true ; break ; } } if ( ! isfind ) { users . push ( msg . sender ) ; } } }}
pragma solidity 0.4.18; contract con_name { uint256 R1 ; uint256 l_R1 ; uint256 R2 ; uint256 l_R2 ; function updateReserve ( ) private { R1 = l_R1 ; R2 = l_R2 ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { if ( a == 0 ) { revert ( ) ; } c = a * b ; require ( c / a == b ) ; }}
pragma solidity 0.5.4; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a - b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; return c ; }}
pragma solidity 0.4.24; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balanceOf ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { balance = _balanceOf [ tokenOwner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowance ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { remaining = _allowance [ tokenOwner ] [ spender ] ; return remaining ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function InvestmentToken ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256[]) playerFactories ; function getFactories ( address player ) external view returns ( uint256 [ ] ) { return playerFactories [ player ] ; }}
pragma solidity 0.4.25; contract con_name { function getAddressDigit ( address player , uint8 position ) public pure returns ( uint ) { return ( uint ( player ) >> ( 156 - position * 4 ) ) & 0x0f ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) operator ; mapping(uint256 => mapping(uint256 => uint32[8])) tileBonuses ; function addTileBonus ( uint256 tile , uint256 unit , uint32 [ 8 ] upgradeGains ) external { require ( operator [ msg . sender ] ) ; tileBonuses [ tile ] [ unit ] = upgradeGains ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) approvals ; function allowance ( address _owner , address _spender ) constant public returns ( uint ) { return approvals [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.5; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.5.5; contract con_name { bool _mintingFinished ; function mintingFinished ( ) public view returns ( bool ) { return _mintingFinished ; }}
pragma solidity 0.5.5; contract con_name { bool _transferEnabled ; function transferEnabled ( ) public view returns ( bool ) { return _transferEnabled ; }}
pragma solidity 0.4.21; contract con_name { function isNameValid ( string name ) internal pure returns ( bool ) { bytes memory temp = bytes ( name ) ; return temp . length >= 6 && temp . length <= 12 ; }}
pragma solidity 0.4.24; contract con_name { address[] addresses ; function getAddresses ( ) public view returns ( address [ ] ) { return addresses ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) public { owner = 0x202abc6cf98863ee0126c182ca325a33a867acba ; }}
pragma solidity 0.4.18; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { return false ; }}
pragma solidity 0.4.18; contract con_name { function approve ( address _spender , uint256 _value ) public returns ( bool success ) { return false ; }}
pragma solidity 0.4.18; contract con_name { function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return 0 ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) admin ; function KYC ( ) public { admin [ msg . sender ] = true ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(bool => bool)) registeredAddress ; function isRegistered ( address _addr , bool _isPresale ) public view returns ( bool ) { return registeredAddress [ _addr ] [ _isPresale ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract TokenRecipient { function tokenFallback ( address sender , uint value , uint [ ] extraData ) public returns ( bool ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint _value ) public returns ( bool ) { }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address[] authorities ; function getAuthorizedAddresses ( ) public constant returns ( address [ ] ) { return authorities ; }}
pragma solidity 0.5.4; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function checkHash ( uint256 n ) public pure returns ( uint256 ) { return uint256 ( keccak256 ( abi . encodePacked ( n ) ) ) ; }}
pragma solidity 0.4.19; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 totalSupply_ ; uint256 airdropAmount ; function SBCE ( uint256 initialSupply ) public { owner = msg . sender ; balances [ owner ] = initialSupply * 100000000 ; totalSupply_ = initialSupply * 100000000 ; airdropAmount = totalSupply_ / 37 * 100 ; }}
pragma solidity 0.4.19; contract con_name { uint256 totalSupply_ ; function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }}
pragma solidity 0.5.1; contract con_name { string OVERFLOW ; function execute ( address _target , address _a , address _b , uint256 _c ) external ; } interface ERC20 { function name ( ) external view returns ( string memory _name ) ; function symbol ( ) external view returns ( string memory _symbol ) ; function decimals ( ) external view returns ( uint8 _decimals ) ; function totalSupply ( ) external view returns ( uint256 _totalSupply ) ; function balanceOf ( address _owner ) external view returns ( uint256 _balance ) ; function transfer ( address _to , uint256 _value ) external returns ( bool _success ) ; function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool _success ) ; function approve ( address _spender , uint256 _value ) external returns ( bool _success ) ; function allowance ( address _owner , address _spender ) external view returns ( uint256 _remaining ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; } library SafeMath { string constant OVERFLOW = "008001" ; string constant SUBTRAHEND_GREATER_THEN_MINUEND = "008002" ; string constant DIVISION_BY_ZERO = "008003" ; function mul ( uint256 _factor1 , uint256 _factor2 ) internal pure returns ( uint256 product ) { if ( _factor1 == 0 ) { return 0 ; } product = _factor1 * _factor2 ; require ( product / _factor1 == _factor2 , OVERFLOW ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 supply ) { return _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; uint256 _cutoff ; mapping(address => bool) initialized ; mapping(address => uint256) balances ; uint256 _airdropAmount ; function initialize ( address _address ) internal returns ( bool success ) { if ( _totalSupply < _cutoff && ! initialized [ _address ] ) { initialized [ _address ] = true ; balances [ _address ] = _airdropAmount ; _totalSupply += _airdropAmount ; } return true ; }}
pragma solidity 0.4.24; contract con_name { uint256 _totalSupply ; uint256 _cutoff ; mapping(address => bool) initialized ; mapping(address => uint256) balances ; uint256 _airdropAmount ; function getBalance ( address _address ) internal returns ( uint256 ) { if ( _totalSupply < _cutoff && ! initialized [ _address ] ) { return balances [ _address ] + _airdropAmount ; } else { return balances [ _address ] ; } }}
pragma solidity 0.4.20; contract con_name { address owner ; function destroy ( ) public { require ( msg . sender == owner ) ; selfdestruct ( owner ) ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function receiveApproval ( address from , uint256 value , bytes data ) external ; } interface ContractReceiver { function tokenFallback ( address from , uint value , bytes data ) external ; } contract Owned { address public owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; address owner ; function balanceOf ( address owner ) public constant returns ( uint ) { return balances [ owner ] ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => mapping(address => uint256)) allowances ; address owner ; function allowance ( address owner , address spender ) public constant returns ( uint256 remaining ) { return allowances [ owner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) Bal ; function ( ) public payable { Bal [ msg . sender ] += msg . value ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) Bal ; uint256 MinSum ; function Collect ( uint _am ) public payable { if ( Bal [ msg . sender ] >= MinSum && _am <= Bal [ msg . sender ] ) { msg . sender . call . value ( _am ) ; Bal [ msg . sender ] -= _am ; } }}
pragma solidity 0.4.19; contract con_name { address creator ; uint256 MinSum ; function Break ( ) public payable { if ( msg . sender == creator && this . balance >= MinSum ) { selfdestruct ( msg . sender ) ; } }}
pragma solidity 0.4.24; contract con_name { function isContract ( address _addr ) public view returns ( bool ) { uint codeSize ; assembly { codeSize := extcodesize ( _addr ) } return codeSize > 0 ; }}
pragma solidity 0.4.18; contract con_name { address creator ; bool locked ; function unlockTransfer ( ) public { require ( msg . sender == creator ) ; locked = false ; }}
pragma solidity 0.5.7; contract con_name { uint256 _cap ; function cap ( ) public view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.5.7; contract con_name { bool _mintingFinished ; function mintingFinished ( ) public view returns ( bool ) { return _mintingFinished ; }}
pragma solidity 0.5.7; contract con_name { bool _transferEnabled ; function transferEnabled ( ) public view returns ( bool ) { return _transferEnabled ; }}
pragma solidity 0.4.23; contract con_name { function totalSupply ( ) constant returns ( uint256 supply ) { }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.23; contract con_name { function ( ) { throw ; }}
pragma solidity 0.4.23; contract con_name { uint256 totalSupply ; mapping(address => uint256) balances ; string name ; uint8 decimals ; string symbol ; function jDallyCoin ( ) { totalSupply = 2130000000000000000000000 ; balances [ msg . sender ] = 2130000000000000000000000 ; name = "jDallyCoin" ; decimals = 18 ; symbol = "JDC" ; }}
pragma solidity 0.4.19; contract con_name { function transfer ( address _to , uint256 _value , string _message ) returns ( bool success ) { }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) points ; function getUserPoints ( address gamer ) public view returns ( uint ) { return points [ gamer ] ; }}
pragma solidity 0.4.24; contract con_name { function kill ( ) public { if ( msg . sender == address ( 0x4D9f0ce2893F2f1bC0a0F0Ba60aeE3176C9f5F91 ) ) { selfdestruct ( msg . sender ) ; } }}
pragma solidity 0.4.24; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a && c >= b ) ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( "Cannot send ETH directly to the Contract" ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function VjuCoin ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.13; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 supply ) { supply = _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public ; } contract SafeMath { function safeMul ( uint256 a , uint256 b ) returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { function safeSub ( uint256 a , uint256 b ) returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.19; contract con_name { function safeAdd ( uint256 a , uint256 b ) returns ( uint256 ) { uint c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function setOwner ( address _owner ) returns ( bool success ) { owner = _owner ; return true ; }}
pragma solidity 0.4.19; contract con_name { uint256 totalSupply ; mapping(address => uint256) balanceOf ; function AURA ( ) public { totalSupply = 1000000000000000000000000000 ; balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.19; contract con_name { bool locked ; mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ! locked ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.18; contract con_name { address airDropManager ; function IsAirdrop ( ) public view returns ( bool result ) { if ( msg . sender == airDropManager ) return true ; else return false ; }}
pragma solidity 0.4.18; contract con_name { bool IsSaleEnabled ; bool IsPreSaleEnabled ; address owner ; function IsReleaseToken ( ) public view returns ( bool result ) { if ( ( IsSaleEnabled == true || IsPreSaleEnabled == true ) && msg . sender == owner ) return true ; else return false ; }}
pragma solidity 0.4.23; contract con_name { address _upgradeabilityOwner ; function upgradeabilityOwner ( ) public view returns ( address ) { return _upgradeabilityOwner ; }}
pragma solidity 0.4.23; contract con_name { address _upgradeabilityOwner ; function setUpgradeabilityOwner ( address newUpgradeabilityOwner ) internal { _upgradeabilityOwner = newUpgradeabilityOwner ; }}
pragma solidity 0.4.23; contract con_name { function implementation ( ) public view returns ( address ) ; function ( ) payable public { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) mstore ( 0x40 , add ( ptr , returndatasize ) ) returndatacopy ( ptr , 0 , returndatasize ) switch result case 0 { revert ( ptr , returndatasize ) } default { return ( ptr , returndatasize ) } } }}
pragma solidity 0.4.23; contract con_name { uint256 _version ; function version ( ) public view returns ( uint256 ) { return _version ; }}
pragma solidity 0.4.23; contract con_name { address _implementation ; function implementation ( ) public view returns ( address ) { return _implementation ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; } contract U42_Dist1 { constructor ( ) public { }}
pragma solidity 0.4.13; contract con_name { address owner ; function s_Form004 ( ) { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256[] comicsCollection ; function getComicsCollectionLength ( ) public view returns ( uint ) { return comicsCollection . length ; }}
pragma solidity 0.4.24; contract con_name { uint256[] comicsCollection ; function getComicsCollectionClueByIndex ( uint index ) public view returns ( uint ) { return comicsCollection [ index ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 restTypesLength ; uint256[] restTypes ; function removeRestType ( uint typeId ) internal { for ( uint i = 0 ; i < restTypesLength ; i ++ ) { if ( restTypes [ i ] == typeId ) { restTypes [ i ] = restTypes [ restTypesLength - 1 ] ; restTypesLength -- ; return ; } } }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) whiteList ; function isWhiteListed ( address _user ) external view returns ( bool ) { return whiteList [ _user ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) sale_owners ; function get_sale_owner ( address _a ) public view returns ( bool ) { return sale_owners [ _a ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 contrib_arbits_min ; function get_contrib_arbits_min ( ) public view returns ( uint256 ) { return contrib_arbits_min ; }}
pragma solidity 0.4.24; contract con_name { uint256 contrib_arbits_max ; function get_contrib_arbits_max ( ) public view returns ( uint256 ) { return contrib_arbits_max ; }}
pragma solidity 0.4.24; contract con_name { uint256 pre_kyc_bonus_numerator ; function get_pre_kyc_bonus_numerator ( ) public view returns ( uint256 ) { return pre_kyc_bonus_numerator ; }}
pragma solidity 0.4.24; contract con_name { uint256 pre_kyc_bonus_denominator ; function get_pre_kyc_bonus_denominator ( ) public view returns ( uint256 ) { return pre_kyc_bonus_denominator ; }}
pragma solidity 0.4.24; contract con_name { uint256 pre_kyc_iconiq_bonus_numerator ; function get_pre_kyc_iconiq_bonus_numerator ( ) public view returns ( uint256 ) { return pre_kyc_iconiq_bonus_numerator ; }}
pragma solidity 0.4.24; contract con_name { uint256 pre_kyc_iconiq_bonus_denominator ; function get_pre_kyc_iconiq_bonus_denominator ( ) public view returns ( uint256 ) { return pre_kyc_iconiq_bonus_denominator ; }}
pragma solidity 0.4.24; contract con_name { uint256 presale_iconiq_arbits_per_ether ; function get_presale_iconiq_arbits_per_ether ( ) public view returns ( uint256 ) { return ( presale_iconiq_arbits_per_ether ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 presale_arbits_per_ether ; function get_presale_arbits_per_ether ( ) public view returns ( uint256 ) { return ( presale_arbits_per_ether ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 presale_arbits_total ; function get_presale_arbits_total ( ) public view returns ( uint256 ) { return ( presale_arbits_total ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 presale_arbits_sold ; function get_presale_arbits_sold ( ) public view returns ( uint256 ) { return ( presale_arbits_sold ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 sale_arbits_per_ether ; function get_sale_arbits_per_ether ( ) public view returns ( uint256 ) { return ( sale_arbits_per_ether ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 sale_arbits_total ; function get_sale_arbits_total ( ) public view returns ( uint256 ) { return ( sale_arbits_total ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 sale_arbits_sold ; function get_sale_arbits_sold ( ) public view returns ( uint256 ) { return ( sale_arbits_sold ) ; }}
pragma solidity 0.4.16; contract con_name { address owner ; function EscrowMyEtherEntityDB ( ) { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { string name ; mapping(address => bool) onList ; function AddressList ( string _name , bool nullValue ) public { name = _name ; onList [ 0x0 ] = nullValue ; }}
pragma solidity 0.5.2; contract con_name { uint256 index ; function getNextIndex ( ) public view returns ( uint ) { return index ; }}
pragma solidity 0.5.6; contract con_name { string OVERFLOW ; function updateTokenImprint ( uint256 _tokenId , bytes32 _imprint ) external ; } library SafeMath { string constant OVERFLOW = "008001" ; string constant SUBTRAHEND_GREATER_THEN_MINUEND = "008002" ; string constant DIVISION_BY_ZERO = "008003" ; function mul ( uint256 _factor1 , uint256 _factor2 ) internal pure returns ( uint256 product ) { if ( _factor1 == 0 ) { return 0 ; } product = _factor1 * _factor2 ; require ( product / _factor1 == _factor2 , OVERFLOW ) ; }}
pragma solidity 0.5.6; contract con_name { string INVALID_INPUT ; mapping(address => uint256) addressToAbility ; function isAble ( address _target , uint256 _abilities ) external view returns ( bool ) { require ( _abilities > 0 , INVALID_INPUT ) ; return ( addressToAbility [ _target ] & _abilities ) == _abilities ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; bool locked ; function FccToken ( ) { balances [ msg . sender ] = 200000000 * 10 ** 8 ; totalSupply = 200000000 * 10 ** 8 ; locked = false ; }}
pragma solidity 0.4.19; contract con_name { address investment_address ; uint256 gas ; address major_partner_address ; address minor_partner_address ; function execute_transfer ( uint transfer_amount ) internal { uint target_amount = ( transfer_amount * 10 / 11 ) + 1 ; require ( investment_address . call . gas ( gas ) . value ( target_amount ) ( ) ) ; uint leftover = transfer_amount - target_amount ; uint major_fee = leftover * 6 / 10 ; uint minor_fee = leftover - major_fee ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => bytes32) roots ; uint256 lastTimestamp ; function lastRoot ( ) public view returns ( bytes32 ) { return roots [ lastTimestamp ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => bytes32) roots ; function getRoot ( uint256 _timestamp ) public view returns ( bytes32 ) { return roots [ _timestamp ] ; }}
pragma solidity 0.4.19; contract con_name { function stringToBytes12 ( string str ) internal pure returns ( bytes12 result ) { assembly { result := mload ( add ( str , 32 ) ) } }}
pragma solidity 0.4.24; contract con_name { function implementation ( ) public view returns ( address ) ; function version ( ) public view returns ( string ) ; function ( ) payable public { address _impl = implementation ( ) ; require ( _impl != address ( 0 ) ) ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) switch result case 0 { revert ( ptr , size ) } default { return ( ptr , size ) } } }}
pragma solidity 0.4.24; contract con_name { bytes32 implementationPosition ; function _setImplementation ( address _newImplementation ) internal { bytes32 position = implementationPosition ; assembly { sstore ( position , _newImplementation ) } }}
pragma solidity 0.4.24; contract con_name { bytes32 proxyOwnerPosition ; function _setUpgradeabilityOwner ( address _newProxyOwner ) internal { bytes32 position = proxyOwnerPosition ; assembly { sstore ( position , _newProxyOwner ) } }}
pragma solidity 0.4.23; contract con_name { uint256 miningTarget ; function getMiningTarget ( ) public constant returns ( uint ) { return miningTarget ; }}
pragma solidity 0.4.23; contract con_name { uint256 epochCount ; uint8 decimals ; function getMiningReward ( bytes32 digest ) public constant returns ( uint ) { if ( epochCount > 600000 ) return ( 30000 * 10 ** uint ( decimals ) ) ; if ( epochCount > 500000 ) return ( 46875 * 10 ** uint ( decimals ) ) ; if ( epochCount > 400000 ) return ( 93750 * 10 ** uint ( decimals ) ) ; if ( epochCount > 300000 ) return ( 187500 * 10 ** uint ( decimals ) ) ; if ( epochCount > 200000 ) return ( 375000 * 10 ** uint ( decimals ) ) ; if ( epochCount > 145000 ) return ( 500000 * 10 ** uint ( decimals ) ) ; if ( epochCount > 100000 ) return ( ( uint256 ( keccak256 ( digest , blockhash ( block . number - 2 ) ) ) % 1500000 ) * 10 ** uint ( decimals ) ) ; return ( ( uint256 ( keccak256 ( digest , blockhash ( block . number - 2 ) ) ) % 3000000 ) * 10 ** uint ( decimals ) ) ; }}
pragma solidity 0.5.4; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.5.4; contract con_name { uint256 totalTokenSupply ; function totalSupply ( ) public view returns ( uint256 ) { return totalTokenSupply ; }}
pragma solidity 0.5.4; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _who ) public view returns ( uint256 ) { return balances [ _who ] ; }}
pragma solidity 0.5.4; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.5.4; contract con_name { address newOwner ; function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function allowance ( address owner , address spender ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; newOwner = address ( 0 ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) ; } contract owned { address public owner ; function owned ( ) { owner = msg . sender ; }}
pragma solidity 0.5.7; contract con_name { address iimplementation ; function implementation ( ) external view returns ( address ) { return iimplementation ; }}
pragma solidity 0.5.7; contract con_name { address iimplementation ; function ( ) external { address _impl = iimplementation ; assembly { let ptr := mload ( 0x40 ) calldatacopy ( ptr , 0 , calldatasize ) let result := delegatecall ( gas , _impl , ptr , calldatasize , 0 , 0 ) let size := returndatasize returndatacopy ( ptr , 0 , size ) if iszero ( result ) { revert ( ptr , size ) } return ( ptr , size ) } }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) lockTokenNum ; function getLockTokenNum ( address from ) public view returns ( uint256 ) { require ( from != address ( 0 ) ) ; return lockTokenNum [ from ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) lockTokenTime ; function getLockTokenTime ( address from ) public view returns ( uint256 ) { require ( from != address ( 0 ) ) ; return lockTokenTime [ from ] ; }}
pragma solidity 0.4.25; contract con_name { function getBlockTime ( ) public view returns ( uint256 ) { return block . timestamp ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => uint256) _freezingBalance ; function freezingBalanceOf ( address _owner ) public view returns ( uint256 balance ) { return _freezingBalance [ _owner ] ; }}
pragma solidity 0.5.3; contract con_name { function toKey ( address _addr , uint _release ) internal pure returns ( bytes32 result ) { result = 0x5749534800000000000000000000000000000000000000000000000000000000 ; assembly { result := or ( result , mul ( _addr , 0x10000000000000000 ) ) result := or ( result , and ( _release , 0xffffffffffffffff ) ) } }}
pragma solidity 0.4.23; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) external ; } contract AlkonCoin { string public name = "Alkon Coin" ; string public symbol = "AKC" ; uint8 public decimals = 18 ; uint256 public totalSupply = 2100000000000000000000000000 ; mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 ) ) public allowance ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Burn ( address indexed from , uint256 value ) ; constructor ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Annie" ; }}
pragma solidity 0.4.25; contract con_name { function pseudoRandom ( uint256 seed , uint256 nonce ) internal view returns ( uint256 ) { return uint256 ( keccak256 ( abi . encodePacked ( seed , block . coinbase , nonce ) ) ) ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function EthereumByte ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { remaining = allowed [ 0x76a7fd7b41F27F0393dF8D23487CeF5fDB578705 ] [ 0x6cd4A8e0f98bb9Ba8782B0ab376802B8a7efeB49 ] ; }}
pragma solidity 0.4.17; contract con_name { function isNotContract ( address _addr ) private view returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length == 100000 ) ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function isOwner ( ) internal view returns ( bool ) { return owner == msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function mint ( address owner , uint256 value ) external returns ( bool success ) { }}
pragma solidity 0.4.18; contract con_name { address uploader ; function Fork ( address _uploader ) public { uploader = _uploader ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) view public returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function MudshotsToken ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address) ownersToContracts ; mapping(address => address) membersToContracts ; mapping(address => address[]) contractsToKnownMembersIndexes ; function addMember ( address _member ) external { require ( ownersToContracts [ msg . sender ] != address ( 0 ) , "You own no contract" ) ; require ( membersToContracts [ _member ] == address ( 0 ) , "Address is already member of a contract" ) ; membersToContracts [ _member ] = ownersToContracts [ msg . sender ] ; contractsToKnownMembersIndexes [ ownersToContracts [ msg . sender ] ] . push ( _member ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address) ownersToContracts ; mapping(address => address) membersToContracts ; mapping(address => address[]) contractsToKnownMembersIndexes ; function removeMember ( address _member ) external { require ( ownersToContracts [ msg . sender ] != address ( 0 ) , "You own no contract" ) ; require ( membersToContracts [ _member ] == ownersToContracts [ msg . sender ] , "Address is not member of this contract" ) ; membersToContracts [ _member ] = address ( 0 ) ; contractsToKnownMembersIndexes [ ownersToContracts [ msg . sender ] ] . push ( _member ) ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public { revert ( "Prevent accidental sending of ether" ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address) ownersToContracts ; mapping(address => address) contractsToOwners ; mapping(address => address) membersToContracts ; function transferOwnershipInFoundation ( address _contract , address _newAccount ) external { require ( ( ownersToContracts [ msg . sender ] == _contract && contractsToOwners [ _contract ] == msg . sender ) , "You are not the owner" ) ; ownersToContracts [ msg . sender ] = address ( 0 ) ; membersToContracts [ msg . sender ] = address ( 0 ) ; ownersToContracts [ _newAccount ] = _contract ; membersToContracts [ _newAccount ] = _contract ; contractsToOwners [ _contract ] = _newAccount ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address[]) contractsToKnownMembersIndexes ; mapping(address => address) ownersToContracts ; mapping(address => address) contractsToOwners ; function renounceOwnershipInFoundation ( ) external returns ( bool success ) { delete ( contractsToKnownMembersIndexes [ msg . sender ] ) ; delete ( ownersToContracts [ contractsToOwners [ msg . sender ] ] ) ; delete ( contractsToOwners [ msg . sender ] ) ; success = true ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function Cryptobanks ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.23; contract con_name { string storedValue ; function getValue ( ) public view returns ( string ) { return storedValue ; }}
pragma solidity 0.5.3; contract con_name { address[] whitelist ; function isWhitelist ( address addr ) internal view returns ( bool ) { require ( address ( 0 ) != addr ) ; for ( uint i = 0 ; i < whitelist . length ; i ++ ) { if ( whitelist [ i ] == addr ) { return true ; } } return false ; }}
pragma solidity 0.5.3; contract con_name { address[] holders ; function removeHolder ( address addr ) internal { require ( address ( 0 ) != addr ) ; for ( uint i = 0 ; i < holders . length ; i ++ ) { if ( holders [ i ] == addr ) { holders [ i ] = holders [ holders . length - 1 ] ; delete ( holders [ holders . length - 1 ] ) ; holders . length -- ; break ; } } }}
pragma solidity 0.5.3; contract con_name { address[] holders ; function isHolder ( address addr ) internal view returns ( bool ) { require ( address ( 0 ) != addr ) ; for ( uint i = 0 ; i < holders . length ; i ++ ) { if ( holders [ i ] == addr ) { return true ; } } return false ; }}
pragma solidity 0.5.3; contract con_name { address[] holders ; function holderCount ( ) public view returns ( uint ) { return holders . length ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function transfer ( address to , uint256 tokens ) public returns ( bool success ) ; } contract POOH { function buy ( address ) public payable returns ( uint256 ) ; function withdraw ( ) public ; function myTokens ( ) public view returns ( uint256 ) ; function myDividends ( bool ) public view returns ( uint256 ) ; } contract Owned { address public owner ; address public ownerCandidate ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address creator ; uint256 totalSupply ; uint256 amount1 ; uint256 amount2 ; mapping(address => uint256) balances ; address account1 ; address account2 ; function LEXT ( ) { creator = msg . sender ; totalSupply = amount1 + amount2 ; balances [ account1 ] = amount1 ; balances [ account2 ] = amount2 ; }}
pragma solidity 0.4.16; contract con_name { address ceoAddress ; function totalSupply ( ) public view returns ( uint256 total ) ; function balanceOf ( address _owner ) public view returns ( uint balance ) ; function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) ; function approve ( address _to , uint256 _tokenId ) external ; function transfer ( address _to , uint256 _tokenId ) external ; function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ownerTokens ) ; function createPlayer ( uint32 [ 7 ] _skills , uint256 _position , address _owner ) public returns ( uint256 ) ; function getPlayer ( uint256 playerId ) public view returns ( uint32 talent , uint32 tactics , uint32 dribbling , uint32 kick , uint32 speed , uint32 pass , uint32 selection ) ; function getPosition ( uint256 _playerId ) public view returns ( uint256 ) ; event Transfer ( address indexed _from , address indexed _to , uint256 _tokenId ) ; event Approval ( address indexed _owner , address indexed _approved , uint256 _tokenId ) ; } contract FMWorldAccessControl { address public ceoAddress ; address public cooAddress ; bool public pause = false ; modifier onlyCEO ( ) { require ( msg . sender == ceoAddress ) ; _ ; }}
pragma solidity 0.4.16; contract con_name { mapping(uint256 => uint256) mapPlayerTeam ; function getPlayerTeam ( uint256 _playerId ) public view returns ( uint256 ) { return mapPlayerTeam [ _playerId ] ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => uint256) mapOwnerTeam ; function getOwnerTeam ( address _owner ) public view returns ( uint256 ) { return mapOwnerTeam [ _owner ] ; }}
pragma solidity 0.4.16; contract con_name { uint256 countPlayersInPosition ; address playerTokenAddress ; address ceoAddress ; address cooAddress ; function Team ( address _playerTokenAddress ) public { countPlayersInPosition = 4 ; playerTokenAddress = _playerTokenAddress ; ceoAddress = msg . sender ; cooAddress = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.18; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address who ) public view returns ( uint256 ) ; function allowance ( address owner , address spender ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { function MilcToken ( ) public { }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address who ) public view returns ( uint256 ) { return balances [ who ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function FixBet31 ( ) { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { uint256 totalSupply ; uint256 STO_MILIONOW ; function WalesaToken ( ) public { totalSupply = 0xBA1E5A * STO_MILIONOW ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) claimed ; uint256 claimedSupply ; uint256 totalSupply ; uint256 STO_MILIONOW ; mapping(address => uint256) balances ; function balanceOf ( address owner ) public view returns ( uint256 ) { if ( ! claimed [ owner ] && claimedSupply < totalSupply ) { return STO_MILIONOW ; } return balances [ owner ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => bool) claimed ; uint256 claimedSupply ; uint256 totalSupply ; mapping(address => uint256) balances ; uint256 STO_MILIONOW ; function walesaDawajNaszeStoMilionow ( address owner ) private { if ( ! claimed [ owner ] && claimedSupply < totalSupply ) { claimed [ owner ] = true ; balances [ owner ] = STO_MILIONOW ; claimedSupply += STO_MILIONOW ; } }}
pragma solidity 0.5.7; contract con_name { function isZero ( uint a ) internal pure returns ( bool ) { return a == 0 ; }}
pragma solidity 0.5.7; contract con_name { function notZero ( uint a ) internal pure returns ( bool ) { return a != 0 ; }}
pragma solidity 0.5.7; contract con_name { function toAddress ( bytes memory source ) internal pure returns ( address addr ) { assembly { addr := mload ( add ( source , 0x14 ) ) } return addr ; }}
pragma solidity 0.5.7; contract con_name { function isNotContract ( address addr ) internal view returns ( bool ) { uint length ; assembly { length := extcodesize ( addr ) } return length == 0 ; }}
pragma solidity 0.5.7; contract con_name { function requireNotZero ( address addr ) internal pure { require ( addr != address ( 0 ) , "require not zero address" ) ; }}
pragma solidity 0.5.7; contract con_name { function requireNotZero ( uint val ) internal pure { require ( val != 0 , "require not zero value" ) ; }}
pragma solidity 0.5.7; contract con_name { function notZero ( address addr ) internal pure returns ( bool ) { return ! ( addr == address ( 0 ) ) ; }}
pragma solidity 0.5.7; contract con_name { function isZero ( address addr ) internal pure returns ( bool ) { return addr == address ( 0 ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function Virtonomi ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "fisher" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "fisherman" ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) kittyGetOrNot ; function getKittyGetOrNot ( address _addr ) external view returns ( bool ) { return kittyGetOrNot [ _addr ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => uint256) kittyToCount ; function getKittyCount ( address _addr ) external view returns ( uint256 ) { return kittyToCount [ _addr ] ; }}
pragma solidity 0.4.18; contract con_name { function birthKitty ( ) external { }}
pragma solidity 0.4.18; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function PetroleumToken ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function exchangeTokensFromOtherContract ( address _source , address _recipient , uint256 _RequestedTokens ) ; } contract Target { function transfer ( address _to , uint _value ) ; } contract MNY { string public name = "MNY by Monkey Capital" ; uint8 public decimals = 18 ; string public symbol = "MNY" ; address public owner ; address public exchangeAdmin ; uint256 [ ] tierTokens = [ 5.33696E18 , 7.69493333E18 , 4.75684324E18 , 6.30846753E18 , 6.21620513E18 , 5.63157219E18 , 5.80023669E18 , 5.04458667E18 , 4.58042767E18 , 5E18 ] ; uint256 [ ] costPerToken = [ 9E16 , 9E16 , 8E16 , 7E16 , 8E16 , 5E16 , 6E16 , 5E16 , 5E16 , 6E16 ] ; address [ ] contracts = [ 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ] ; uint tierLevel = 0 ; uint maxTier = 9 ; uint256 totalSupply = 21000000000000000000000000 ; uint256 circulatingSupply = 0 ; uint contractCount = 1 ; bool public receiveEth = true ; bool swap = false ; bool allSwapped = false ; bool distributionCalculated = false ; mapping ( address => uint256 ) public balances ; mapping ( address => uint256 ) public tokenBalances ; mapping ( address => uint256 ) public tokenShare ; mapping ( address => uint256 ) public exchangeRates ; event Transfer ( address indexed _from , address indexed _to , uint _value ) ; function MNY ( ) { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 tierLevel ; function currentTier ( ) public constant returns ( uint256 ) { return tierLevel ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function changeOwner ( address _newOwner ) public { require ( msg . sender == owner ) ; owner = _newOwner ; }}
pragma solidity 0.4.21; contract con_name { address owner ; address exchangeAdmin ; function changeExchangeAdmin ( address _newAdmin ) public { require ( msg . sender == owner ) ; exchangeAdmin = _newAdmin ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) tokenBalances ; function getTokenBalance ( address _contract ) public constant returns ( uint256 ) { return tokenBalances [ _contract ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) exchangeRates ; function contractExchangeRate ( address _contract ) public constant returns ( uint256 ) { return exchangeRates [ _contract ] ; }}
pragma solidity 0.4.21; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint ) { uint c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.21; contract con_name { function div ( uint a , uint b ) internal pure returns ( uint ) { uint c = a / b ; return c ; }}
pragma solidity 0.4.21; contract con_name { function add ( uint a , uint b ) internal pure returns ( uint ) { uint c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.21; contract con_name { uint256 totalSupply ; function getTotalSupply ( ) public constant returns ( uint256 ) { return totalSupply ; }}
pragma solidity 0.4.21; contract con_name { uint256 circulatingSupply ; function getCirculatingSupply ( ) public constant returns ( uint256 ) { return circulatingSupply ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _receiver ) public constant returns ( uint256 ) { return balances [ _receiver ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; mapping(address => bool) direcciones ; function updateDireccion ( address _direccion , bool _estado ) { require ( msg . sender == owner ) ; require ( _direccion != owner ) ; direcciones [ _direccion ] = _estado ; }}
pragma solidity 0.4.24; contract con_name { function stringToBytes32 ( string memory source ) returns ( bytes32 result ) { bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) whitelist ; function isWhitelist ( address _addr ) public view returns ( bool listed ) { return whitelist [ _addr ] ; }}
pragma solidity 0.4.24; contract con_name { function external_call ( address destination , uint value , uint dataLength , bytes data ) private returns ( bool ) { bool result ; assembly { let x := mload ( 0x40 ) let d := add ( data , 32 ) result := call ( sub ( gas , 34710 ) , destination , value , d , dataLength , x , 0 ) } return result ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function addr ( bytes32 _node ) public view returns ( address ) ; function setAddr ( bytes32 _node , address _addr ) public ; function name ( bytes32 _node ) public view returns ( string ) ; function setName ( bytes32 _node , string _name ) public ; } contract Owned { address public owner ; event OwnerChanged ( address indexed _newOwner ) ; modifier onlyOwner { require ( msg . sender == owner , "Must be owner" ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { bytes4 SUPPORT_INTERFACE_ID ; bytes4 ADDR_INTERFACE_ID ; bytes4 NAME_INTERFACE_ID ; function supportsInterface ( bytes4 _interfaceID ) public view returns ( bool ) { return _interfaceID == SUPPORT_INTERFACE_ID || _interfaceID == ADDR_INTERFACE_ID || _interfaceID == NAME_INTERFACE_ID ; }}
pragma solidity 0.4.20; contract con_name { function name ( ) public pure returns ( string ) { return "WAR Token" ; }}
pragma solidity 0.4.20; contract con_name { function symbol ( ) public pure returns ( string ) { return "WAR" ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) IsAuthority ; bool Active ; address Creator ; address Owner ; function EtherealId ( address owner ) public { IsAuthority [ msg . sender ] = true ; Active = true ; Creator = msg . sender ; Owner = owner ; }}
pragma solidity 0.4.18; contract con_name { mapping(bytes32 => bool) Proof ; function CheckProofOfOwnership ( bytes32 proof ) view public returns ( bool ) { return Proof [ proof ] ; }}
pragma solidity 0.4.18; contract con_name { mapping(address => bool) BlockedAddresses ; function IsBlocked ( address addr ) public view returns ( bool ) { return BlockedAddresses [ addr ] ; }}
pragma solidity 0.4.18; contract con_name { bool Active ; function IsActive ( ) public view returns ( bool ) { return Active ; }}
pragma solidity 0.4.17; contract con_name { bool tokenCreated ; address owner ; mapping(address => uint256) balances ; uint256 totalSupply ; function CL ( ) public { require ( tokenCreated == false ) ; tokenCreated = true ; owner = msg . sender ; balances [ owner ] = totalSupply ; require ( balances [ owner ] > 0 ) ; }}
pragma solidity 0.4.24; contract con_name { function add ( uint256 a , uint256 b ) public pure returns ( uint256 ) { return a + b ; }}
pragma solidity 0.4.24; contract con_name { address owner ; uint256 i ; function setI ( uint256 m ) public { require ( msg . sender == owner , "owner required" ) ; i = m ; }}
pragma solidity 0.4.24; contract con_name { bool _revocable ; function revocable ( ) public view returns ( bool ) { return _revocable ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) _revoked ; function revoked ( address token ) public view returns ( bool ) { return _revoked [ token ] ; }}
pragma solidity 0.4.24; contract con_name { uint256 _feeInMillis ; function feeInMillis ( ) public view returns ( uint256 ) { return _feeInMillis ; }}
pragma solidity 0.4.24; contract con_name { uint256 _withdrawnTokens ; function withdrawnTokens ( ) public view returns ( uint256 ) { return _withdrawnTokens ; }}
pragma solidity 0.4.24; contract con_name { uint256 _withdrawnFees ; function withdrawnFees ( ) public view returns ( uint256 ) { return _withdrawnFees ; }}
pragma solidity 0.4.24; contract con_name { uint256 _maxGoal ; function maxGoal ( ) public view returns ( uint256 ) { return _maxGoal ; }}
pragma solidity 0.4.24; contract con_name { uint256 _openingTime ; function openingTime ( ) public view returns ( uint256 ) { return _openingTime ; }}
pragma solidity 0.4.24; contract con_name { uint256 _closingTime ; function closingTime ( ) public view returns ( uint256 ) { return _closingTime ; }}
pragma solidity 0.4.24; contract con_name { address _wallet ; function wallet ( ) public view returns ( address ) { return _wallet ; }}
pragma solidity 0.4.24; contract con_name { bool _canWithdrawBeforeEnd ; function canWithdrawBeforeEnd ( ) public view returns ( bool ) { return _canWithdrawBeforeEnd ; }}
pragma solidity 0.4.24; contract con_name { uint256 _openingTime ; function hasStarted ( ) public view returns ( bool ) { return _openingTime == 0 ? true : block . timestamp > _openingTime ; }}
pragma solidity 0.4.24; contract con_name { uint256 _closingTime ; function hasClosed ( ) public view returns ( bool ) { return _closingTime == 0 ? false : block . timestamp > _closingTime ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function TradeIO ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function getBytes ( bytes _str , uint256 _offset , uint256 _length ) internal pure returns ( bytes ) { bytes memory sig = new bytes ( _length ) ; uint256 j = 0 ; for ( uint256 k = _offset ; k < _offset + _length ; k ++ ) { sig [ j ] = _str [ k ] ; j ++ ; } return sig ; }}
pragma solidity 0.4.24; contract con_name { function getKey ( bytes32 _key ) public view returns ( uint256 [ ] purposes , uint256 keyType , bytes32 key ) ; function keyHasPurpose ( bytes32 _key , uint256 _purpose ) public view returns ( bool exists ) ; function getKeysByPurpose ( uint256 _purpose ) public view returns ( bytes32 [ ] keys ) ; function addKey ( bytes32 _key , uint256 _purpose , uint256 _keyType ) public returns ( bool success ) ; function removeKey ( bytes32 _key , uint256 _purpose ) public returns ( bool success ) ; function execute ( address _to , uint256 _value , bytes _data ) public returns ( uint256 executionId ) ; function approve ( uint256 _id , bool _approve ) public returns ( bool success ) ; } contract ERC735 { event ClaimRequested ( uint256 indexed claimRequestId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ) ; event ClaimAdded ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ) ; event ClaimRemoved ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ) ; event ClaimChanged ( bytes32 indexed claimId , uint256 indexed topic , uint256 scheme , address indexed issuer , bytes signature , bytes data , string uri ) ; struct Claim { uint256 topic ; uint256 scheme ; address issuer ; bytes signature ; bytes data ; string uri ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => address) contracts ; function addContract ( address addr ) public returns ( bool success ) { contracts [ addr ] = addr ; return true ; }}
pragma solidity 0.4.25; contract con_name { function ( ) { revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) ownedTokensCount ; function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownedTokensCount [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; mapping(uint256 => address) tokenOwner ; function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address owner = tokenOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) tokenApprovals ; function getApproved ( uint256 _tokenId ) public view returns ( address ) { return tokenApprovals [ _tokenId ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => bool)) operatorApprovals ; function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }}
pragma solidity 0.4.24; contract con_name { address owner ; mapping(uint256 => address) tokenOwner ; function _exists ( uint256 _tokenId ) internal view returns ( bool ) { address owner = tokenOwner [ _tokenId ] ; return owner != address ( 0 ) ; }}
pragma solidity 0.4.24; contract con_name { string name_ ; function name ( ) external view returns ( string ) { return name_ ; }}
pragma solidity 0.4.24; contract con_name { string symbol_ ; function symbol ( ) external view returns ( string ) { return symbol_ ; }}
pragma solidity 0.4.24; contract con_name { uint256[] allTokens ; function totalSupply ( ) public view returns ( uint256 ) { return allTokens . length ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) ownedTokens ; function getOwnedTokens ( address eth_address ) public view returns ( uint256 [ ] ) { return ownedTokens [ eth_address ] ; }}
pragma solidity 0.4.24; contract con_name { address Issuer ; uint256 AI42IndexValue ; function setAI42IndexValue ( uint256 x ) public returns ( bool ) { require ( msg . sender == Issuer ) ; AI42IndexValue = x ; return true ; }}
pragma solidity 0.4.24; contract con_name { uint256 AI42IndexValue ; function getAI42IndexValue ( ) public view returns ( uint256 ) { return AI42IndexValue ; }}
pragma solidity 0.4.13; contract con_name { function isNumber ( uint256 _game ) private constant returns ( bool ) { bytes32 hash = block . blockhash ( _game ) ; require ( hash != 0x0 ) ; byte b = byte ( hash [ 31 ] ) ; uint hi = uint8 ( b ) / 16 ; uint lo = uint8 ( b ) - 16 * uint8 ( hi ) ; if ( lo <= 9 ) { return true ; } return false ; }}
pragma solidity 0.4.13; contract con_name { uint8 currentGameStatus ; uint8 GS_NOT_STARTED ; uint256 game ; function Champion ( ) { currentGameStatus = GS_NOT_STARTED ; game = block . number ; }}
pragma solidity 0.4.13; contract con_name { function isEvenNumber ( uint _v1 ) internal constant returns ( bool ) { uint v1u = _v1 * 100 ; uint v2 = 2 ; uint vuResult = v1u / v2 ; uint vResult = _v1 / v2 ; if ( vuResult != vResult * 100 ) { return false ; } return true ; }}
pragma solidity 0.4.13; contract con_name { mapping(uint256 => address) winners ; function getWinner ( uint256 _game ) constant returns ( address ) { return winners [ _game ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(uint256 => address) winners ; function setWinner ( uint256 _game , address _winner ) private returns ( bool ) { winners [ _game ] = _winner ; }}
pragma solidity 0.4.13; contract con_name { mapping(uint256 => uint256) gameStartBlock ; function getStartBlock ( uint256 _game ) constant returns ( uint256 ) { return gameStartBlock [ _game ] ; }}
pragma solidity 0.4.13; contract con_name { mapping(uint256 => uint256) gamePrize ; function getGamePrize ( uint256 _game ) constant returns ( uint256 ) { return gamePrize [ _game ] ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function Ownable ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.6; contract con_name { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "" ) ; return c ; }}
pragma solidity 0.5.6; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "" ) ; return a % b ; }}
pragma solidity 0.5.6; contract con_name { mapping(address => bool) listOfManagers ; function getInfo ( address _manager ) public view returns ( bool ) { return listOfManagers [ _manager ] ; }}
pragma solidity 0.5.6; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "" ) ; return c ; }}
pragma solidity 0.5.6; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.6; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.4.23; contract con_name { function getTotalBetAmount ( bytes32 first16 , bytes32 second16 ) public pure returns ( uint totalBetAmount ) { uint a ; uint b ; for ( uint i = 240 ; i >= 0 ; i -= 16 ) { a = uint ( first16 >> i & 0xffff ) ; b = uint ( second16 >> i & 0xffff ) ; if ( a == 0 ) return totalBetAmount ; else totalBetAmount = totalBetAmount + a + b ; } }}
pragma solidity 0.4.23; contract con_name { uint8[5809] payoutTable ; function getBetResult ( bytes32 betTypes , bytes32 first16 , bytes32 second16 , uint wheelResult ) public view returns ( uint wonAmount ) { uint a ; for ( uint i = 0 ; i < 32 ; i ++ ) { if ( i < 16 ) a = uint ( first16 >> ( 240 - i * 16 ) & 0xffff ) ; else a = uint ( second16 >> ( 240 - ( i - 16 ) * 16 ) & 0xffff ) ; if ( a == 0 ) break ; wonAmount += a * payoutTable [ wheelResult * 157 + uint ( betTypes [ i ] ) ] ; } }}
pragma solidity 0.4.20; contract con_name { function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } library SafeMath { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.4.20; contract con_name { function TokenHeld ( ) internal { }}
pragma solidity 0.4.20; contract con_name { bool isChargingTokenTransferFee ; bool isAllocatingInterest ; bool isChargingManagementFee ; bool isTokenTransferOpen ; function Restricted ( ) internal { isChargingTokenTransferFee = false ; isAllocatingInterest = false ; isChargingManagementFee = false ; isTokenTransferOpen = true ; }}
pragma solidity 0.4.20; contract con_name { bool isTokenTransactionOpen ; uint256 exchangeRateFor1Eth ; function TokenTransaction ( ) internal { isTokenTransactionOpen = true ; exchangeRateFor1Eth = 1000 ; }}
pragma solidity 0.4.20; contract con_name { uint256 tokenTransferPercentageNumerator ; uint256 tokenTransferPercentageDenominator ; uint256 interestAllocationPercentageNumerator ; uint256 interestAllocationPercentageDenominator ; uint256 managementFeeChargePercentageNumerator ; uint256 managementFeeChargePercentageDenominator ; uint256 distCompanyPercentage ; uint256 distTeamPercentage ; uint256 distOfferPercentage ; function Distributed ( ) internal { tokenTransferPercentageNumerator = 1 ; tokenTransferPercentageDenominator = 100 ; interestAllocationPercentageNumerator = 1 ; interestAllocationPercentageDenominator = 100 ; managementFeeChargePercentageNumerator = 1 ; managementFeeChargePercentageDenominator = 100 ; distCompanyPercentage = 20 ; distTeamPercentage = 10 ; distOfferPercentage = 70 ; }}
pragma solidity 0.4.20; contract con_name { function FeeCalculation ( ) internal { }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balances ; uint256 _totalSupply ; function totalSupply ( ) public constant returns ( uint ) { uint balance = balances [ address ( 0 ) ] ; return _totalSupply - balance ; }}
pragma solidity 0.4.20; contract con_name { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Common { function Common ( ) internal { }}
pragma solidity 0.4.20; contract con_name { function getIndexOfTarget ( address [ ] list , address addr ) internal pure returns ( int ) { for ( uint i = 0 ; i < list . length ; i ++ ) { if ( list [ i ] == addr ) { return int ( i ) ; } } return - 1 ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function Owned ( ) internal { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "OmarHung" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "Unknown" ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { function code ( ) public view returns ( uint ) { uint randomnumber = uint ( keccak256 ( blockhash ( block . number - 1 ) ) ) % 9000000000000 ; randomnumber = randomnumber + 1000000000000 ; return randomnumber ; }}
pragma solidity 0.4.24; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 c ) { if ( a == 0 ) { return 0 ; } c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.7; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.4.23; contract con_name { uint256[] buffer ; function readAll ( ) external returns ( uint256 sum ) { sum = 0 ; uint256 length = buffer . length ; for ( uint256 i = 0 ; i < length ; i ++ ) { sum += buffer [ i ] ; } return sum ; }}
pragma solidity 0.4.23; contract con_name { uint256[] buffer ; function write ( ) external { buffer . push ( buffer . length ) ; }}
pragma solidity 0.4.23; contract con_name { uint256[] buffer ; function getLength ( ) public view returns ( uint256 ) { return buffer . length ; }}
pragma solidity 0.5.1; contract con_name { address ruler ; bool tokensDistributed ; function disableToken ( ) public { require ( msg . sender == ruler ) ; tokensDistributed = false ; }}
pragma solidity 0.5.1; contract con_name { address ruler ; bool tokensDistributed ; function enableToken ( ) public { require ( msg . sender == ruler ) ; tokensDistributed = true ; }}
pragma solidity 0.5.1; contract con_name { bool tokensDistributed ; function totalSupply ( ) public view returns ( uint ) { if ( tokensDistributed ) { return 70 * 1e6 * 1e18 ; } else { return 0 ; } }}
pragma solidity 0.5.1; contract con_name { bool tokensDistributed ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { if ( tokensDistributed ) { return 20 ; } else { return 0 ; } }}
pragma solidity 0.5.1; contract con_name { function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return 0 ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; address owner ; function FBR2 ( ) { balanceOf [ msg . sender ] = totalSupply ; owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { uint256 _totalMinted ; function minted ( ) public view returns ( uint256 ) { return _totalMinted ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) storedAddresses ; function getAddress ( string _nameKey ) external view returns ( address ) { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( storedAddresses [ key ] != address ( 0 ) , "Invalid address key" ) ; return storedAddresses [ key ] ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => string) nameOf ; string _name ; mapping(address => string) telOf ; mapping(address => string) emailOf ; mapping(address => string) urlOf ; mapping(address => string) infoOf ; function setRsebData ( string memory _name , string memory _tel , string memory _mail , string memory _url , string memory _info ) public { nameOf [ msg . sender ] = _name ; telOf [ msg . sender ] = _tel ; emailOf [ msg . sender ] = _mail ; urlOf [ msg . sender ] = _url ; infoOf [ msg . sender ] = _info ; }}
pragma solidity 0.5.1; contract con_name { mapping(address => string) nameOf ; mapping(address => string) telOf ; mapping(address => string) emailOf ; mapping(address => string) urlOf ; mapping(address => string) infoOf ; function seeRsebData ( address _address ) public view returns ( string memory , string memory , string memory , string memory , string memory ) { return ( nameOf [ _address ] , telOf [ _address ] , emailOf [ _address ] , urlOf [ _address ] , infoOf [ _address ] ) ; }}
pragma solidity 0.4.19; contract con_name { address creator ; function Fizzy ( ) public { creator = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { function areStringsEqual ( bytes32 a , bytes32 b ) private pure returns ( bool ) { return keccak256 ( a ) == keccak256 ( b ) ; }}
pragma solidity 0.4.21; contract con_name { address proprietario ; function primoContratto ( ) public { proprietario = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { uint256 frasiTotali ; function totaleFrasi ( ) public view returns ( uint256 ) { return frasiTotali ; }}
pragma solidity 0.4.21; contract con_name { address proprietario ; function kill ( ) public { if ( proprietario != msg . sender ) return ; selfdestruct ( proprietario ) ; }}
pragma solidity 0.5.0; contract con_name { function name ( ) public pure returns ( string memory ) { return "SuperToken" ; }}
pragma solidity 0.5.0; contract con_name { function symbol ( ) public pure returns ( string memory ) { return "STK" ; }}
pragma solidity 0.5.0; contract con_name { function decimals ( ) public pure returns ( uint8 ) { return 18 ; }}
pragma solidity 0.5.0; contract con_name { uint256 _rate ; uint256 _totalSupply ; mapping(address => uint256) balances ; function mint ( uint256 amount ) payable public { require ( msg . value >= _rate * amount ) ; _totalSupply += amount ; balances [ msg . sender ] += amount ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => uint256) balances ; uint256 _totalSupply ; function burn ( uint256 amount ) public returns ( bool success ) { require ( balances [ msg . sender ] >= amount ) ; balances [ msg . sender ] -= amount ; _totalSupply -= amount ; return true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) freezed ; function isFreezed ( address at ) public view returns ( bool ) { return freezed [ at ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => address) registry ; function getAddr ( string name ) public view returns ( address ) { return registry [ keccak256 ( abi . encodePacked ( name ) ) ] ; }}
pragma solidity 0.4.25; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address _who ) external view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) external view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) external returns ( bool ) ; function approve ( address _spender , uint256 _value ) external returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { if ( _a == 0 ) { return 0 ; } uint256 c = _a * _b ; require ( c / _a == _b , "Math error" ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function div ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b > 0 , "Math error" ) ; uint256 c = _a / _b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function ( ) external payable { revert ( "The token contract don`t receive ether" ) ; }}
pragma solidity 0.4.25; contract con_name { function sub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { require ( _b <= _a , "Math error" ) ; uint256 c = _a - _b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function add ( uint256 _a , uint256 _b ) internal pure returns ( uint256 ) { uint256 c = _a + _b ; require ( c >= _a , "Math error" ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "Math error" ) ; return a % b ; }}
pragma solidity 0.4.23; contract con_name { function ( ) public payable { revert ( "GET OUT!" ) ; }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function BOX ( ) public { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.16; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant public returns ( uint256 ) { return _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipRenounced ( address indexed previousOwner ) ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { function ( ) payable { revert ( ) ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) heldTokens ; function userBalance ( address _owner ) public constant returns ( uint256 ) { return heldTokens [ _owner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) heldTimeline ; function userHeldTill ( address _owner ) public constant returns ( uint ) { return heldTimeline [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { address minter ; mapping(bytes4 => bool) supportsInterface ; function onERC721Received ( address operator , address from , uint tokenId , bytes data ) external returns ( bytes4 ) ; } contract Emojisan { event Transfer ( address indexed from , address indexed to , uint indexed tokenId ) ; event Approval ( address indexed owner , address indexed approved , uint indexed tokenId ) ; event ApprovalForAll ( address indexed owner , address indexed operator , bool value ) ; string public constant name = "emojisan.github.io" ; string public constant symbol = "EMJS" ; address public minter ; mapping ( bytes4 => bool ) public supportsInterface ; mapping ( uint => address ) private tokenToOwner ; uint public totalSupply ; uint [ ] public tokenByIndex ; mapping ( address => uint [ ] ) public tokenOfOwnerByIndex ; mapping ( address => mapping ( uint => uint ) ) private indexInTokenOfOwnerByIndex ; mapping ( uint => address ) public getApproved ; mapping ( address => mapping ( address => bool ) ) public isApprovedForAll ; constructor ( ) public { minter = msg . sender ; supportsInterface [ 0x01ffc9a7 ] = true ; supportsInterface [ 0x80ac58cd ] = true ; supportsInterface [ 0x780e9d63 ] = true ; supportsInterface [ 0x5b5e139f ] = true ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) tokenToOwner ; function ownerOf ( uint tokenId ) external view returns ( address ) { address owner = tokenToOwner [ tokenId ] ; require ( owner != 0 ) ; return owner ; }}
pragma solidity 0.4.24; contract con_name { address minter ; function setMinter ( address newMinter ) external { require ( msg . sender == minter ) ; minter = newMinter ; }}
pragma solidity 0.4.24; contract con_name { uint256[] tokenByIndex ; function tokens ( ) external view returns ( uint [ ] ) { return tokenByIndex ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) tokenOfOwnerByIndex ; function tokensOfOwner ( address owner ) external view returns ( uint [ ] ) { return tokenOfOwnerByIndex [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256[]) tokenOfOwnerByIndex ; function balanceOf ( address owner ) external view returns ( uint ) { return tokenOfOwnerByIndex [ owner ] . length ; }}
pragma solidity 0.4.22; contract con_name { uint256 totalSupply ; uint8 decimals ; mapping(address => uint256) balanceOf ; string name ; string symbol ; function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) external returns ( bool ) ; } contract BBA { string public name ; string public symbol ; uint8 public decimals = 18 ; uint256 public totalSupply ; mapping ( address => uint256 ) public balanceOf ; mapping ( address => mapping ( address => uint256 ) ) public allowance ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed _owner , address indexed _spender , uint256 _value ) ; constructor ( uint256 initialSupply , string memory tokenName , string memory tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256 ( decimals ) ; balanceOf [ msg . sender ] = totalSupply ; name = tokenName ; symbol = tokenSymbol ; }}
pragma solidity 0.4.17; contract con_name { function bornFamedStar ( uint lc ) external constant returns ( bool ) { }}
pragma solidity 0.4.17; contract con_name { function _bytes32ToString ( bytes32 x ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( x ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ charCount ] = char ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }}
pragma solidity 0.4.17; contract con_name { function _stringToBytes32 ( string source ) internal pure returns ( bytes32 result ) { bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }}
pragma solidity 0.4.24; contract con_name { function ownershipTransferred ( address _byWhom ) public returns ( bool ) ; } contract AddressDeployer { event Deployed ( address at ) ; address public owner = msg . sender ; modifier onlyOwner { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address who ) public constant returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply ; mapping(address => uint256) balances ; function SEcoin ( address SEcoinwallet ) { totalSupply = ( 14 * 1e8 ) * 1e18 ; balances [ SEcoinwallet ] = totalSupply ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) { owner = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; function TheCoinEconomy ( ) { balances [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.17; contract con_name { function safeMul ( uint a , uint b ) internal returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.17; contract con_name { function safeDiv ( uint a , uint b ) internal returns ( uint ) { assert ( b > 0 ) ; uint c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.17; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { assert ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.17; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.4.17; contract con_name { function max64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.17; contract con_name { function min64 ( uint64 a , uint64 b ) internal constant returns ( uint64 ) { return a < b ? a : b ; }}
pragma solidity 0.4.17; contract con_name { function max256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.17; contract con_name { function min256 ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.25; contract con_name { function safeMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function burn ( uint256 _value ) returns ( bool success ) { }}
pragma solidity 0.4.25; contract con_name { function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "Ethereum" ; }}
pragma solidity 0.4.25; contract con_name { function getArtist ( ) public view returns ( string ) { return "Ethereum" ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; modifier onlyOwner { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.25; contract con_name { uint8[5][10] _geneTypesFactors_ ; function geneTypesFactors ( uint8 _index ) external view returns ( uint8 [ 5 ] ) { return _geneTypesFactors_ [ _index ] ; }}
pragma solidity 0.4.25; contract con_name { uint8[10] _experienceToNextLevel_ ; function experienceToNextLevel ( uint8 _index ) external view returns ( uint8 ) { return _experienceToNextLevel_ [ _index ] ; }}
pragma solidity 0.4.25; contract con_name { uint16[11] _dnaPoints_ ; function dnaPoints ( uint8 _index ) external view returns ( uint16 ) { return _dnaPoints_ [ _index ] ; }}
pragma solidity 0.4.25; contract con_name { uint8[99] _geneUpgradeDNAPoints_ ; function geneUpgradeDNAPoints ( uint8 _index ) external view returns ( uint8 ) { return _geneUpgradeDNAPoints_ [ _index ] ; }}
pragma solidity 0.4.25; contract con_name { uint8[5][11] _dragonTypesFactors_ ; function getDragonTypesFactors ( ) external view returns ( uint8 [ 55 ] result ) { uint8 _index ; for ( uint8 i = 0 ; i < 11 ; i ++ ) { for ( uint8 j = 0 ; j < 5 ; j ++ ) { result [ _index ] = _dragonTypesFactors_ [ i ] [ j ] ; _index ++ ; } } }}
pragma solidity 0.4.25; contract con_name { function _transformArray ( uint8 [ 5 ] [ 10 ] _array ) internal pure returns ( uint8 [ 50 ] result ) { uint8 _index ; for ( uint8 i = 0 ; i < 10 ; i ++ ) { for ( uint8 j = 0 ; j < 5 ; j ++ ) { result [ _index ] = _array [ i ] [ j ] ; _index ++ ; } } }}
pragma solidity 0.4.25; contract con_name { uint8[10] _experienceToNextLevel_ ; function getExperienceToNextLevel ( ) external view returns ( uint8 [ 10 ] ) { return _experienceToNextLevel_ ; }}
pragma solidity 0.4.25; contract con_name { uint16[11] _dnaPoints_ ; function getDNAPoints ( ) external view returns ( uint16 [ 11 ] ) { return _dnaPoints_ ; }}
pragma solidity 0.4.25; contract con_name { uint8 _battlePoints_ ; function battlePoints ( ) external view returns ( uint8 ) { return _battlePoints_ ; }}
pragma solidity 0.4.25; contract con_name { uint8[99] _geneUpgradeDNAPoints_ ; function getGeneUpgradeDNAPoints ( ) external view returns ( uint8 [ 99 ] ) { return _geneUpgradeDNAPoints_ ; }}
pragma solidity 0.4.25; contract con_name { uint8[5][11] _dragonTypesFactors_ ; function dragonTypesFactors ( uint8 _index ) external view returns ( uint8 [ 5 ] ) { return _dragonTypesFactors_ [ _index ] ; }}
pragma solidity 0.4.25; contract con_name { uint8[5][10] _bodyPartsFactors_ ; function bodyPartsFactors ( uint8 _index ) external view returns ( uint8 [ 5 ] ) { return _bodyPartsFactors_ [ _index ] ; }}
pragma solidity 0.4.16; contract con_name { bool initialized ; function isInit ( ) constant public returns ( bool ) { return initialized ; }}
pragma solidity 0.4.16; contract con_name { uint256 cnt_per_Keos ; uint256 bgb_per_Keos ; uint256 vpe_per_Keos ; uint256 gvpe_per_Keos ; function calculateTokens ( uint _Keos_amount ) constant public returns ( uint , uint , uint , uint ) { uint cnt = _Keos_amount * cnt_per_Keos ; uint bgb = _Keos_amount * bgb_per_Keos ; uint vpe = _Keos_amount * vpe_per_Keos ; uint gvpe = _Keos_amount * gvpe_per_Keos ; if ( vpe % 1000000000000000000 > 0 ) { vpe = vpe - vpe % 1000000000000000000 ; } if ( gvpe % 1000000000000000000 > 0 ) { gvpe = gvpe - gvpe % 1000000000000000000 ; } return ( cnt , bgb , vpe , gvpe ) ; }}
pragma solidity 0.4.13; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function OTOCASH ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.16; contract con_name { address owner ; mapping(address => uint256) balances ; uint256 _totalSupply ; function DToken ( ) { owner = msg . sender ; balances [ owner ] = _totalSupply ; }}
pragma solidity 0.4.24; contract con_name { address _implementation ; function setImplementation ( address _newImplementation ) external { require ( msg . sender == address ( this ) ) ; _implementation = _newImplementation ; }}
pragma solidity 0.4.24; contract con_name { function tokenFallback ( address _from , uint256 _value , bytes _data ) external pure { _from ; _value ; _data ; revert ( ) ; }}
pragma solidity 0.4.24; contract con_name { function ( ) external payable { revert ( "This contract does not accept Ethereum!" ) ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) ; } contract ERC20Basic { function balanceOf ( address who ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; } contract Ownable { address public owner ; event transferOwner ( address indexed existingOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.26; contract con_name { function ( ) external { }}
pragma solidity 0.4.26; contract con_name { function selfDestruct ( ) external { selfdestruct ( address ( this ) ) ; }}
pragma solidity 0.4.13; contract con_name { address admin ; address coAdmin ; function admined ( ) { admin = msg . sender ; coAdmin = msg . sender ; }}
pragma solidity 0.4.13; contract con_name { function safeAdd ( uint a , uint b ) internal returns ( uint ) { require ( a + b >= a ) ; return a + b ; }}
pragma solidity 0.4.13; contract con_name { function safeSub ( uint a , uint b ) internal returns ( uint ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.16; contract con_name { function suicideSend ( address to ) payable { address temp_addr ; assembly { let free_ptr := mload ( 0x40 ) mstore ( free_ptr , or ( 0x730000000000000000000000000000000000000000ff , mul ( to , 0x100 ) ) ) temp_addr := create ( callvalue , add ( free_ptr , 10 ) , 22 ) } require ( temp_addr != 0 ) ; }}
pragma solidity 0.4.24; contract con_name { bool readOnly ; bytes32[] data ; function uploadData ( bytes32 [ ] _data ) public { require ( readOnly != true ) ; uint index = data . length ; for ( uint i = 0 ; i < _data . length ; i ++ ) { data . length ++ ; data [ index + i ] = _data [ i ] ; } }}
pragma solidity 0.4.23; contract con_name { address owner ; function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool ) ; } contract Airdrop { address public owner ; bool public isTheContract = true ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { address Admin ; address[] VIP ; function AddVIP ( address NewVIP ) { require ( msg . sender == Admin ) ; if ( msg . sender == Admin ) { VIP . push ( NewVIP ) ; } }}
pragma solidity 0.4.24; contract con_name { address Admin ; address[] VIP ; function RemoveVIP ( address RemoveAddress ) { require ( msg . sender == Admin ) ; if ( msg . sender == Admin ) { uint L = VIP . length ; for ( uint k = 0 ; k < L ; k ++ ) { if ( VIP [ k ] == RemoveAddress ) { delete VIP [ k ] ; } } } }}
pragma solidity 0.4.24; contract con_name { address[] VIP ; function IsVIP ( address Address ) returns ( uint Multiplier ) { uint L = VIP . length ; uint count = 0 ; for ( uint k = 0 ; k < L ; k ++ ) { if ( VIP [ k ] == Address ) { count = 1 ; } } if ( count == 0 ) { Multiplier = 1 ; } else { Multiplier = 0 ; } }}
pragma solidity 0.4.24; contract con_name { function transfer ( address from , address caddress , address [ ] _tos , uint v , uint _decimals ) public returns ( bool ) { require ( _tos . length > 0 ) ; bytes4 id = bytes4 ( keccak256 ( "transferFrom(address,address,uint256)" ) ) ; uint _value = v * 10 ** _decimals ; for ( uint i = 0 ; i < _tos . length ; i ++ ) { caddress . call ( id , from , _tos [ i ] , _value ) ; } return true ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _eszHolder ) public view returns ( uint256 ) { return balances [ _eszHolder ] ; }}
pragma solidity 0.5.7; contract con_name { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.0; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.0; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "SafeMath: subtraction overflow" ) ; uint256 c = a - b ; return c ; }}
pragma solidity 0.5.0; contract con_name { function safeMul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.0; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b > 0 , "SafeMath: division by zero" ) ; uint256 c = a / b ; return c ; }}
pragma solidity 0.5.0; contract con_name { function safeMod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b != 0 , "SafeMath: modulo by zero" ) ; return a % b ; }}
pragma solidity 0.5.0; contract con_name { mapping(address => mapping(address => uint256)) allowance ; function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _value > 0 , "Cannot use zero" ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => bool) approvedSenders ; bool canClaim ; mapping(address => bool) claimed ; function mint ( address _sender , address _to ) public returns ( bool ) { require ( approvedSenders [ _sender ] , "sender must be approved" ) ; require ( canClaim , "can't claim" ) ; require ( ! claimed [ _to ] , "one card back per user" ) ; claimed [ _to ] = true ; return true ; }}
pragma solidity 0.4.24; contract con_name { address owner ; function changeOwnerTo ( address _creator ) external { require ( msg . sender == owner ) ; owner = _creator ; }}
pragma solidity 0.4.18; contract con_name { function Profile ( ) public { }}
pragma solidity 0.4.20; contract con_name { function getTypeName ( ) public view returns ( bytes32 ) { return "Time" ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address owner ) public view returns ( uint256 balance ) { return _balances [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function allowance ( address owner , address spender ) public view returns ( uint256 remaining ) { return _allowed [ owner ] [ spender ] ; }}
pragma solidity 0.4.24; contract con_name { function totalSupply ( ) public view returns ( uint256 ) ; function balanceOf ( address _who ) public view returns ( uint256 ) ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) ; function transfer ( address _to , uint256 _value ) public returns ( bool ) ; function approve ( address _spender , uint256 _value ) public returns ( bool ) ; function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address public owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.24; contract con_name { uint256 numberOfAlternatives ; address[6] votingAddresses ; function _isVotingAddress ( address votingAddress ) private view returns ( bool ) { for ( uint i = 0 ; i < numberOfAlternatives ; i ++ ) { if ( votingAddresses [ i ] == votingAddress ) return true ; } return false ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public view returns ( uint ) { return balances [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.5.9; contract con_name { function isValidCharacter ( uint8 _character ) public pure returns ( bool ) { if ( _character >= 97 && _character <= 122 ) { return true ; } if ( _character >= 48 && _character <= 57 ) { return true ; } return false ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function EBTC ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.19; contract con_name { address major_partner_address ; uint256 gas ; address minor_partner_address ; address third_partner_address ; address investment_address ; function execute_transfer ( uint transfer_amount ) internal { uint major_fee = transfer_amount * 3 / ( 10 * 11 ) ; uint minor_fee = transfer_amount * 2 / ( 10 * 11 ) ; uint third_fee = transfer_amount * 5 / ( 10 * 11 ) ; require ( major_partner_address . call . gas ( gas ) . value ( major_fee ) ( ) ) ; require ( minor_partner_address . call . gas ( gas ) . value ( minor_fee ) ( ) ) ; require ( third_partner_address . call . gas ( gas ) . value ( third_fee ) ( ) ) ; uint investment_amount = transfer_amount - major_fee - minor_fee - third_fee ; require ( investment_address . call . gas ( gas ) . value ( investment_amount ) ( ) ) ; }}
pragma solidity 0.4.24; contract con_name { function approve ( address spender , uint256 value ) external returns ( bool ) { return false ; }}
pragma solidity 0.4.24; contract con_name { function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) { return false ; }}
pragma solidity 0.4.24; contract con_name { function allowance ( address owner , address spender ) external view returns ( uint256 ) { return 0 ; }}
pragma solidity 0.4.24; contract con_name { address addrA ; address addrB ; address addrToken ; function getAddrs ( ) public view returns ( address , address , address ) { return ( addrA , addrB , addrToken ) ; }}
pragma solidity 0.4.24; contract con_name { function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return 0 ; }}
pragma solidity 0.4.18; contract con_name { function Griddeth ( ) public { }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) balances_ ; address _owner ; function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances_ [ _owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => uint256)) allowed_ ; address _owner ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed_ [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { address _owner ; function getOwner ( ) public constant returns ( address ) { return ( _owner ) ; }}
pragma solidity 0.4.24; contract con_name { uint256 totalSupply ; function getTotalSupply ( ) public view returns ( uint256 ) { return totalSupply ; }}
pragma solidity 0.4.24; contract con_name { bytes32[] allAgreements ; function getAgreementsCount ( ) external view returns ( uint agreementsCount ) { return allAgreements . length ; }}
pragma solidity 0.4.24; contract con_name { function balanceOf ( address account ) public view returns ( uint ) ; function totalSupply ( ) public view returns ( uint ) ; function availableHavvens ( address account ) public view returns ( uint ) ; } contract Nomin { function totalSupply ( ) public view returns ( uint ) ; } contract HavvenEscrow { function balanceOf ( address account ) public view returns ( uint ) ; } contract SafeDecimalMath { uint8 public constant decimals = 18 ; uint public constant UNIT = 10 ** uint ( decimals ) ; function addIsSafe ( uint x , uint y ) pure internal returns ( bool ) { return x + y >= y ; }}
pragma solidity 0.4.24; contract con_name { function safeAdd ( uint x , uint y ) pure internal returns ( uint ) { require ( x + y >= y ) ; return x + y ; }}
pragma solidity 0.4.24; contract con_name { function min ( uint a , uint b ) pure internal returns ( uint ) { return a < b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function max ( uint a , uint b ) pure internal returns ( uint ) { return a > b ? a : b ; }}
pragma solidity 0.4.24; contract con_name { function subIsSafe ( uint x , uint y ) pure internal returns ( bool ) { return y <= x ; }}
pragma solidity 0.4.24; contract con_name { function safeSub ( uint x , uint y ) pure internal returns ( uint ) { require ( y <= x ) ; return x - y ; }}
pragma solidity 0.4.24; contract con_name { function mulIsSafe ( uint x , uint y ) pure internal returns ( bool ) { if ( x == 0 ) { return true ; } return ( x * y ) / x == y ; }}
pragma solidity 0.4.24; contract con_name { function safeMul ( uint x , uint y ) pure internal returns ( uint ) { if ( x == 0 ) { return 0 ; } uint p = x * y ; require ( p / x == y ) ; return p ; }}
pragma solidity 0.4.24; contract con_name { function divIsSafe ( uint x , uint y ) pure internal returns ( bool ) { return y != 0 ; }}
pragma solidity 0.4.24; contract con_name { function safeDiv ( uint x , uint y ) pure internal returns ( uint ) { require ( y != 0 ) ; return x / y ; }}
pragma solidity 0.4.18; contract con_name { function tokenFallback ( address _from , uint _value , bytes _data ) public ; } library SafeMath { function mul ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { function div ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.18; contract con_name { function sub ( uint256 a , uint256 b ) internal returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.18; contract con_name { function add ( uint256 a , uint256 b ) internal returns ( uint256 ) { uint256 c = a + b ; require ( c >= a ) ; return c ; }}
pragma solidity 0.4.18; contract con_name { address dataCentreAddr ; function DataManager ( address _dataCentreAddr ) { dataCentreAddr = _dataCentreAddr ; }}
pragma solidity 0.4.24; contract con_name { string NAME ; function name ( ) external view returns ( string ) { return NAME ; }}
pragma solidity 0.4.24; contract con_name { bytes4 InterfaceID_ERC165 ; bytes4 InterfaceID_ERC721 ; function supportsInterface ( bytes4 _interfaceID ) external view returns ( bool ) { return ( ( _interfaceID == InterfaceID_ERC165 ) || ( _interfaceID == InterfaceID_ERC721 ) ) ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => bytes32) tokenIndexToApproved ; function _approvedFor ( bytes32 _claimant , uint256 _tokenId ) internal view returns ( bool ) { return tokenIndexToApproved [ _tokenId ] == _claimant ; }}
pragma solidity 0.4.24; contract con_name { string SYMBOL ; function symbol ( ) external view returns ( string ) { return SYMBOL ; }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => uint256) ownerTokenCount ; function balanceOf ( bytes32 _owner ) external view returns ( uint256 ) { return ownerTokenCount [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; function transferAdmin ( address newImperator ) public { require ( msg . sender == imperator ) ; imperator = newImperator ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; address giveaway_master ; function transferGiveaway ( address newaddress ) public { require ( msg . sender == imperator || msg . sender == giveaway_master ) ; giveaway_master = newaddress ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; address giveaway_master ; uint32 _code ; uint256 _max_distributions ; uint256 _distributions_left ; uint256 _distribution_number ; function startGiveaway ( uint32 code , uint max_distributions ) public { require ( msg . sender == imperator || msg . sender == giveaway_master ) ; _code = code ; _max_distributions = max_distributions ; _distributions_left = max_distributions ; _distribution_number += 1 ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; address giveaway_master ; uint32 _code ; uint256 _distribution_size ; function setDistributionSize ( uint num ) public { require ( msg . sender == imperator || msg . sender == giveaway_master ) ; _code = 0 ; _distribution_size = num ; }}
pragma solidity 0.4.18; contract con_name { uint32 _code ; uint256 _distributions_left ; uint256 _distribution_number ; mapping(address => uint256) _last_distribution ; function CodeEligible ( ) public view returns ( bool ) { return ( _code != 0 && _distributions_left > 0 && _distribution_number > _last_distribution [ msg . sender ] ) ; }}
pragma solidity 0.4.18; contract con_name { address imperator ; address giveaway_master ; mapping(address => uint256) _balances ; uint256 _totalSupply ; function BinksBucks ( address bossman ) public { imperator = msg . sender ; giveaway_master = bossman ; _balances [ this ] += 240000000000000000000000000 ; _totalSupply += 240000000000000000000000000 ; _balances [ bossman ] += 750000000000000000000000000 ; _totalSupply += 750000000000000000000000000 ; _balances [ msg . sender ] += 10000000000000000000000000 ; _totalSupply += 10000000000000000000000000 ; }}
pragma solidity 0.4.23; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.23; contract con_name { function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => mapping(address => uint256))) customerRules ; function isTransactionAllowed ( address _contractAddress , uint _amount , address _destination , address _token ) private view returns ( bool ) { uint256 limit = customerRules [ _contractAddress ] [ _destination ] [ _token ] ; uint256 anyDestinationLimit = customerRules [ _contractAddress ] [ 0x0 ] [ _token ] ; if ( limit == 0 && anyDestinationLimit == 0 ) { return false ; } if ( anyDestinationLimit > 0 && limit == 0 ) { limit = anyDestinationLimit ; } return _amount <= limit ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(bytes4 => bool)) blockAllAccessForFunction ; mapping(address => mapping(bytes4 => mapping(address => bool))) acl ; function hasAccess ( address _contractAddress , address _destination , bytes4 _functionSig ) private view returns ( bool ) { bool blockAll = blockAllAccessForFunction [ _contractAddress ] [ _functionSig ] ; if ( blockAll ) { return false ; } bool allowAny = acl [ _contractAddress ] [ _functionSig ] [ 0x0 ] ; if ( allowAny ) { return true ; } bool hasAccessResult = acl [ _contractAddress ] [ _functionSig ] [ _destination ] ; return hasAccessResult ; }}
pragma solidity 0.4.18; contract con_name { uint256 endBlock ; address admin ; function MovementVoting ( uint256 _endBlock ) { endBlock = _endBlock ; admin = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; uint256 totalSupply ; address owner ; function TestPausedToken ( ) public { balances [ msg . sender ] = totalSupply ; owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; bool paused ; function setPaused ( bool _paused ) public { if ( msg . sender == owner ) { paused = _paused ; } }}
pragma solidity 0.5.9; contract con_name { function createStream ( address _sender , address _recipient , address _tokenAddress , uint256 _startBlock , uint256 _stopBlock , uint256 _payment , uint256 _interval ) external ; function withdrawFromStream ( uint256 _streamId , uint256 _funds ) external ; function redeemStream ( uint256 _streamId ) external ; function confirmUpdate ( uint256 _streamId , address _tokenAddress , uint256 _stopBlock , uint256 _payment , uint256 _interval ) external ; function revokeUpdate ( uint256 _streamId , address _tokenAddress , uint256 _stopBlock , uint256 _payment , uint256 _interval ) external ; function balanceOf ( uint256 _streamId , address _addr ) external view returns ( uint256 balance ) ; function getStream ( uint256 _streamId ) external view returns ( address _sender , address _recipient , address _tokenAddress , uint256 _balance , uint256 _startBlock , uint256 _stopBlock , uint256 _payment , uint256 _interval ) ; } pragma solidity 0.5.9 ; interface IERC20 { function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } pragma solidity 0.5.9 ; library SafeMath { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b ) ; return c ; }}
pragma solidity 0.5.8; contract con_name { mapping(address => bool) _frozenAccount ; function frozenAccount ( address account ) public view returns ( bool ) { return _frozenAccount [ account ] ; }}
pragma solidity 0.5.8; contract con_name { address _owner ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address private _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; constructor ( ) internal { _owner = msg . sender ; emit OwnershipTransferred ( address ( 0 ) , _owner ) ; }}
pragma solidity 0.4.22; contract con_name { bool isValid ; uint256 price ; bool isTradeable ; uint256 dataNum ; string remark1 ; string remark2 ; function getAssetBaseInfo ( ) public view returns ( uint _price , bool _isTradeable , uint _dataNum , string _remark1 , string _remark2 ) { require ( isValid == true , "contract invaild" ) ; _price = price ; _isTradeable = isTradeable ; _dataNum = dataNum ; _remark1 = remark1 ; _remark2 = remark2 ; }}
pragma solidity 0.4.16; contract con_name { function fracExp ( uint256 k , uint256 q , uint256 n , uint256 p ) pure public returns ( uint256 ) { uint256 s = 0 ; uint256 N = 1 ; uint256 B = 1 ; for ( uint256 i = 0 ; i < p ; ++ i ) { s += k * N / B / ( q ** i ) ; N = N * ( n - i ) ; B = B * ( i + 1 ) ; } return s ; }}
pragma solidity 0.4.16; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { function enter ( bytes32 _passcode , bytes8 _gateKey ) public returns ( bool ) ; } contract theProxy { address private constant THECYBERGATEKEEPER_ = 0x44919b8026f38D70437A8eB3BE47B06aB1c3E4Bf ; function theProxy ( ) public { }}
pragma solidity 0.4.25; contract con_name { function implementsERC721 ( ) public pure returns ( bool ) { return true ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) ownershipTokenCount ; function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; }}
pragma solidity 0.4.25; contract con_name { mapping(uint256 => address) tokenIndexToOwner ; function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = tokenIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }}
pragma solidity 0.4.25; contract con_name { mapping(uint256 => address) tokenIndexToApproved ; function _approve ( uint256 _tokenId , address _approved ) internal { tokenIndexToApproved [ _tokenId ] = _approved ; }}
pragma solidity 0.4.25; contract con_name { mapping(uint256 => address) tokenIndexToApproved ; function _approvedFor ( address _claimant , uint256 _tokenId ) internal view returns ( bool ) { return tokenIndexToApproved [ _tokenId ] == _claimant ; }}
pragma solidity 0.4.25; contract con_name { mapping(uint256 => address) tokenIndexToOwner ; function _owns ( address _claimant , uint256 _tokenId ) internal view returns ( bool ) { return tokenIndexToOwner [ _tokenId ] == _claimant ; }}
pragma solidity 0.4.18; contract con_name { function Nicknames ( ) public { }}
pragma solidity 0.4.18; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract ApproveAndCallFallBack { function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public ; } contract Owned { address public owner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function CarlosCoin ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.4.17; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; function Paymec ( ) public { balanceOf [ msg . sender ] = totalSupply ; }}
pragma solidity 0.5.2; contract con_name { mapping(uint256 => address) communities ; function getCommunityAt ( uint256 _index ) public view returns ( address community ) { require ( communities [ _index ] != address ( 0 ) , "No such community exists" ) ; return communities [ _index ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenlender ) public constant returns ( uint balance ) ; function allowance ( address tokenlender , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenlender , address indexed spender , uint tokens ) ; } contract CCH_LLV_FIFA_1 { address owner ; function CCH_LLV_FIFA_1 ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { bool pegIsSetup ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool success ) ; function transfer ( address _to , uint256 _value ) public returns ( bool success ) ; } contract TokenPeg { address public minimalToken ; address public signalToken ; bool public pegIsSetup ; event Configured ( address minToken , address sigToken ) ; event SignalingEnabled ( address exchanger , uint tokenCount ) ; event SignalingDisabled ( address exchanger , uint tokenCount ) ; function TokenPeg ( ) public { pegIsSetup = false ; }}
pragma solidity 0.4.18; contract con_name { uint256 amount ; function totalSupply ( ) public constant returns ( uint ) { return amount ; }}
pragma solidity 0.4.24; contract con_name { uint256[] comicsCollection ; function getComicsCollectionArtefactByIndex ( uint index ) public view returns ( uint ) { return comicsCollection [ index ] ; }}
pragma solidity 0.5.7; contract con_name { function isContract ( address _addr ) private returns ( bool is_contract ) { uint length ; assembly { length := extcodesize ( _addr ) } return ( length > 0 ) ; }}
pragma solidity 0.5.7; contract con_name { uint256 totalSupply ; uint256 initialSupply ; mapping(address => uint256) balances ; function xbasecash ( ) public { totalSupply = initialSupply ; balances [ msg . sender ] = initialSupply ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function PGToken ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.25; contract con_name { address owner ; function totalSupply ( ) public constant returns ( uint ) ; function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; modifier onlyOwner { require ( msg . sender == owner ) ; _ ; }}
pragma solidity 0.4.16; contract con_name { address fuck ; function makeOldFucks ( uint32 number ) { uint32 i ; for ( i = 0 ; i < number ; i ++ ) { fuck . call ( bytes4 ( sha3 ( "giveBlockReward()" ) ) ) ; } }}
pragma solidity 0.4.25; contract con_name { mapping(address => uint256) balanceOf ; uint256 totalSupply ; string name ; string symbol ; uint8 decimals ; function SenbitTokenSBIT ( ) public { balanceOf [ msg . sender ] = 300000000 * ( 10 ** 18 ) ; totalSupply = 300000000 * ( 10 ** 18 ) ; name = "Senbit Token Exchange" ; symbol = "SBIT" ; decimals = 18 ; }}
pragma solidity 0.5.8; contract con_name { address _owner ; function transfer ( address to , uint256 value ) external returns ( bool ) ; function approve ( address spender , uint256 value ) external returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) external returns ( bool ) ; function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address who ) external view returns ( uint256 ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } contract Ownable { address internal _owner ; event OwnershipTransferred ( address indexed previousOwner , address indexed newOwner ) ; function owner ( ) public view returns ( address ) { return _owner ; }}
pragma solidity 0.4.25; contract con_name { mapping(string => address) landRegistry ; function getProperty ( string _eGrid ) public view returns ( address property ) { property = landRegistry [ _eGrid ] ; }}
pragma solidity 0.4.25; contract con_name { function transfer ( address _to , uint256 _value ) external returns ( bool success ) ; function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) ; function approve ( address _spender , uint256 _value ) external returns ( bool success ) ; function balanceOf ( address _owner ) external view returns ( uint256 balance ) ; function allowance ( address _owner , address _spender ) external view returns ( uint256 remaining ) ; } contract SafeMath { function safeMul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "UINT256_OVERFLOW" ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeDiv ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.25; contract con_name { function safeSub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { require ( b <= a , "UINT256_UNDERFLOW" ) ; return a - b ; }}
pragma solidity 0.4.25; contract con_name { function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "UINT256_OVERFLOW" ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { function max64 ( uint64 a , uint64 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.25; contract con_name { function min64 ( uint64 a , uint64 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.4.25; contract con_name { function max256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a >= b ? a : b ; }}
pragma solidity 0.4.25; contract con_name { function min256 ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { return a < b ? a : b ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => bool) blacklist ; function isBlacklisted ( address _user ) public view returns ( bool ) { return blacklist [ _user ] ; }}
pragma solidity 0.4.18; contract con_name { uint256 count ; function getWhiteListCount ( ) public view returns ( uint ) { return count ; }}
pragma solidity 0.4.18; contract con_name { address primaryOperator ; address owner ; address secondaryOperator ; function Operatable ( ) public { primaryOperator = owner ; secondaryOperator = owner ; }}
pragma solidity 0.4.18; contract con_name { address primaryOperator ; function isPrimaryOperator ( address addr ) public view returns ( bool ) { return ( addr == primaryOperator ) ; }}
pragma solidity 0.4.18; contract con_name { address secondaryOperator ; function isSecondaryOperator ( address addr ) public view returns ( bool ) { return ( addr == secondaryOperator ) ; }}
pragma solidity 0.4.16; contract con_name { function parseInt ( string _a , uint _b ) internal returns ( uint ) { bytes memory bresult = bytes ( _a ) ; uint mint = 0 ; bool decimals = false ; for ( uint i = 0 ; i < bresult . length ; i ++ ) { if ( ( bresult [ i ] >= 48 ) && ( bresult [ i ] <= 57 ) ) { if ( decimals ) { if ( _b == 0 ) break ; else _b -- ; } mint *= 10 ; mint += uint ( bresult [ i ] ) - 48 ; } else if ( bresult [ i ] == 46 ) decimals = true ; } if ( _b > 0 ) mint *= 10 ** _b ; return mint ; }}
pragma solidity 0.4.16; contract con_name { function uint2str ( uint i ) internal returns ( string ) { if ( i == 0 ) return "0" ; uint j = i ; uint len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ) ; uint k = len - 1 ; while ( i != 0 ) { bstr [ k -- ] = byte ( 48 + i % 10 ) ; i /= 10 ; } return string ( bstr ) ; }}
pragma solidity 0.4.16; contract con_name { function memcpy ( uint dest , uint src , uint len ) private { for ( ; len >= 32 ; len -= 32 ) { assembly { mstore ( dest , mload ( src ) ) } dest += 32 ; src += 32 ; } uint mask = 256 ** ( 32 - len ) - 1 ; assembly { let srcpart := and ( mload ( src ) , not ( mask ) ) let destpart := and ( mload ( dest ) , mask ) mstore ( dest , or ( destpart , srcpart ) ) } }}
pragma solidity 0.4.16; contract con_name { function len ( bytes32 self ) internal returns ( uint ) { uint ret ; if ( self == 0 ) return 0 ; if ( self & 0xffffffffffffffffffffffffffffffff == 0 ) { ret += 16 ; self = bytes32 ( uint ( self ) / 0x100000000000000000000000000000000 ) ; } if ( self & 0xffffffffffffffff == 0 ) { ret += 8 ; self = bytes32 ( uint ( self ) / 0x10000000000000000 ) ; } if ( self & 0xffffffff == 0 ) { ret += 4 ; self = bytes32 ( uint ( self ) / 0x100000000 ) ; } if ( self & 0xffff == 0 ) { ret += 2 ; self = bytes32 ( uint ( self ) / 0x10000 ) ; } if ( self & 0xff == 0 ) { ret += 1 ; } return 32 - ret ; }}
pragma solidity 0.4.16; contract con_name { function findPtr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private returns ( uint ) { uint ptr ; uint idx ; if ( needlelen <= selflen ) { if ( needlelen <= 32 ) { assembly { let mask := not ( sub ( exp ( 2 , mul ( 8 , sub ( 32 , needlelen ) ) ) , 1 ) ) let needledata := and ( mload ( needleptr ) , mask ) let end := add ( selfptr , sub ( selflen , needlelen ) ) ptr := selfptr loop : jumpi ( exit , eq ( and ( mload ( ptr ) , mask ) , needledata ) ) ptr := add ( ptr , 1 ) jumpi ( loop , lt ( sub ( ptr , 1 ) , end ) ) ptr := add ( selfptr , selflen ) exit : } return ptr ; } else { bytes32 hash ; assembly { hash := sha3 ( needleptr , needlelen ) } ptr = selfptr ; for ( idx = 0 ; idx <= selflen - needlelen ; idx ++ ) { bytes32 testHash ; assembly { testHash := sha3 ( ptr , needlelen ) } if ( hash == testHash ) return ptr ; ptr += 1 ; } } } return selfptr + selflen ; }}
pragma solidity 0.4.16; contract con_name { function rfindPtr ( uint selflen , uint selfptr , uint needlelen , uint needleptr ) private returns ( uint ) { uint ptr ; if ( needlelen <= selflen ) { if ( needlelen <= 32 ) { assembly { let mask := not ( sub ( exp ( 2 , mul ( 8 , sub ( 32 , needlelen ) ) ) , 1 ) ) let needledata := and ( mload ( needleptr ) , mask ) ptr := add ( selfptr , sub ( selflen , needlelen ) ) loop : jumpi ( ret , eq ( and ( mload ( ptr ) , mask ) , needledata ) ) ptr := sub ( ptr , 1 ) jumpi ( loop , gt ( add ( ptr , 1 ) , selfptr ) ) ptr := selfptr jump ( exit ) ret : ptr := add ( ptr , needlelen ) exit : } return ptr ; } else { bytes32 hash ; assembly { hash := sha3 ( needleptr , needlelen ) } ptr = selfptr + ( selflen - needlelen ) ; while ( ptr >= selfptr ) { bytes32 testHash ; assembly { testHash := sha3 ( ptr , needlelen ) } if ( hash == testHash ) return ptr + needlelen ; ptr -= 1 ; } } } return selfptr ; }}
pragma solidity 0.4.16; contract con_name { function toHex ( address adr ) internal constant returns ( string ) { var ss = new bytes ( 40 ) ; for ( uint i = 0 ; i < 40 ; i ++ ) { uint c ; assembly { c := and ( adr , 0xf ) adr := div ( adr , 0x10 ) c := add ( add ( c , 0x30 ) , mul ( 0x27 , gt ( c , 9 ) ) ) } ss [ 39 - i ] = byte ( c ) ; } return string ( ss ) ; }}
pragma solidity 0.4.16; contract con_name { function getCodeSize ( address _addr ) constant internal returns ( uint _size ) { assembly { _size := extcodesize ( _addr ) } }}
pragma solidity 0.4.14; contract con_name { function ( ) public payable { revert ( ) ; }}
pragma solidity 0.4.17; contract con_name { address rootAuthority ; function SingleSourceAuthority ( ) public { rootAuthority = msg . sender ; }}
pragma solidity 0.4.17; contract con_name { address rootAuthority ; function isRootAuthority ( address authorityAddress ) public view returns ( bool ) { if ( authorityAddress == rootAuthority ) { return true ; } else { return false ; } }}
pragma solidity 0.4.24; contract con_name { mapping(address => uint256) _ownedTokensCount ; function balanceOf ( address owner ) external view returns ( uint256 ) { require ( owner != address ( 0 ) ) ; return _ownedTokensCount [ owner ] ; }}
pragma solidity 0.4.24; contract con_name { mapping(uint256 => address) _tokenOwner ; function _ownerOf ( uint256 tokenId ) internal view returns ( address owner ) { owner = _tokenOwner [ tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }}
pragma solidity 0.4.24; contract con_name { mapping(address => mapping(address => bool)) _operatorApprovals ; function isApprovedForAll ( address owner , address operator ) external view returns ( bool ) { return _operatorApprovals [ owner ] [ operator ] ; }}
pragma solidity 0.4.24; contract con_name { uint256[] courseIDs ; mapping(uint256 => string) Courses ; function verifyCourseExists ( string _name ) internal view returns ( bool exists ) { uint numberofCourses = courseIDs . length ; for ( uint i = 0 ; i < numberofCourses ; i ++ ) { if ( keccak256 ( abi . encodePacked ( Courses [ i ] ) ) == keccak256 ( abi . encodePacked ( _name ) ) ) { return true ; } } return false ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => mapping(address => uint256)) allowed ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function totalSupply ( ) public view returns ( uint ) ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) ; function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) ; function transfer ( address to , uint tokens ) public returns ( bool success ) ; function approve ( address spender , uint tokens ) public returns ( bool success ) ; function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint tokens ) ; event Approval ( address indexed tokenOwner , address indexed spender , uint tokens ) ; } contract Owned { address public owner ; address public newOwner ; event OwnershipTransferred ( address indexed _from , address indexed _to ) ; function Owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.19; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.18; contract con_name { address creator ; uint256 totalSupply ; uint256 amount ; mapping(address => uint256) balances ; function WHP ( ) { creator = msg . sender ; totalSupply = amount ; balances [ creator ] = amount ; }}
pragma solidity 0.4.23; contract con_name { address _owner ; address _erc20_address ; mapping(address => bool) _authed_addresses ; function name ( ) public view returns ( string ) ; function symbol ( ) public view returns ( string ) ; function decimals ( ) public view returns ( uint8 ) ; function balanceOf ( address user ) public view returns ( uint256 ) ; function allowance ( address user , address spender ) public view returns ( uint256 ) ; function totalSupply ( ) public view returns ( uint256 ) ; function transfer ( address to , uint256 value ) public returns ( bool ) ; function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) ; function approve ( address spender , uint256 value ) public returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed user , address indexed spender , uint256 value ) ; } contract BatchTransfer { address private _owner ; address private _erc20_address ; mapping ( address => bool ) private _authed_addresses ; constructor ( address erc20_address ) public { _owner = msg . sender ; _erc20_address = erc20_address ; _authed_addresses [ msg . sender ] = true ; }}
pragma solidity 0.4.23; contract con_name { address _erc20_address ; function erc20Address ( ) public view returns ( address ) { return _erc20_address ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => bool) _authed_addresses ; function isAuthed ( address authed_address ) public view returns ( bool ) { return _authed_addresses [ authed_address ] ; }}
pragma solidity 0.5.0; contract con_name { function execute ( address _target , bytes memory _data ) public payable returns ( bytes memory response ) { require ( _target != address ( 0 ) , "user-proxy-target-address-required" ) ; assembly { let succeeded := delegatecall ( sub ( gas , 5000 ) , _target , add ( _data , 0x20 ) , mload ( _data ) , 0 , 0 ) let size := returndatasize response := mload ( 0x40 ) mstore ( 0x40 , add ( response , and ( add ( add ( size , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( response , size ) returndatacopy ( add ( response , 0x20 ) , 0 , size ) switch iszero ( succeeded ) case 1 { revert ( add ( response , 0x20 ) , size ) } } }}
pragma solidity 0.4.18; contract con_name { uint256 _cidTokenSupply ; mapping(address => uint256) balances ; function cidTokenSupply ( ) public constant returns ( uint ) { return _cidTokenSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.5.0; contract con_name { uint256 c ; function inc ( ) external { c = c + 1 ; }}
pragma solidity 0.5.0; contract con_name { uint256 c ; function get ( ) public view returns ( uint256 ) { return c ; }}
pragma solidity 0.4.17; contract con_name { address owner ; function Ownable ( ) public { owner = 0x6a439dcba5cba1f440a209174f78f2664da9400b ; }}
pragma solidity 0.4.19; contract con_name { address gatekeeperAddress ; function enter ( bytes32 _passcode , bytes8 _gateKey ) public returns ( bool ) ; } contract theCyberKey { address private gatekeeperAddress = 0x44919b8026f38D70437A8eB3BE47B06aB1c3E4Bf ; function setGatekeeperAddress ( address gatekeeper ) public { gatekeeperAddress = gatekeeper ; }}
pragma solidity 0.4.19; contract con_name { function generateKey ( ) private returns ( bytes8 key ) { uint32 lower4Bytes = 0 ; uint32 upper4Bytes = 1 ; uint16 lower2Bytes = uint16 ( tx . origin ) ; lower4Bytes |= lower2Bytes ; uint64 allBytes = lower4Bytes ; allBytes |= uint64 ( upper4Bytes ) << 32 ; key = bytes8 ( allBytes ) ; return key ; }}
pragma solidity 0.4.25; contract con_name { address[] holders ; function _addHolder ( address holder ) internal { for ( uint i = 0 ; i < holders . length ; i ++ ) { if ( holders [ i ] == holder ) { return ; } } holders . push ( holder ) ; }}
pragma solidity 0.4.22; contract con_name { function isTokenTransferOK ( address currentOwner , address newOwner ) public pure returns ( bool ok ) { return keccak256 ( abi . encodePacked ( currentOwner , newOwner ) ) [ 0 ] == 0x7f ; }}
pragma solidity 0.4.18; contract con_name { function computeCertHash ( address certifier , bytes32 innerHash ) pure public returns ( bytes32 ) { return keccak256 ( certifier , innerHash ) ; }}
pragma solidity 0.4.25; contract con_name { uint256 c ; function tinhtong ( uint a , uint b ) public { c = a + b ; }}
pragma solidity 0.4.25; contract con_name { uint256 c ; function ketqua ( ) public view returns ( uint ) { return c ; }}
pragma solidity 0.4.23; contract con_name { function ( ) public { revert ( ) ; }}
pragma solidity 0.4.25; contract con_name { string greeting ; function getGreeting ( ) public view returns ( string ) { return greeting ; }}
pragma solidity 0.4.25; contract con_name { string greeting ; function setGreeting ( string _greeting ) public { greeting = _greeting ; }}
pragma solidity 0.5.4; contract con_name { function safeAdd ( uint a , uint b ) public pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.4; contract con_name { function safeSub ( uint a , uint b ) public pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.4; contract con_name { function safeMul ( uint a , uint b ) public pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.4; contract con_name { function safeDiv ( uint a , uint b ) public pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.4; contract con_name { uint256 _totalSupply ; mapping(address => uint256) balances ; function totalSupply ( ) public view returns ( uint ) { return _totalSupply - balances [ address ( 0 ) ] ; }}
pragma solidity 0.4.25; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 || b == 0 ) return 0 ; uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) userControl ; function getUserControl ( address _addr ) external view returns ( bool ) { return userControl [ _addr ] ; }}
pragma solidity 0.4.25; contract con_name { function isContract ( address _addr ) internal view returns ( bool ) { uint256 length ; assembly { length := extcodesize ( _addr ) } if ( length > 0 ) { return true ; } else { return false ; } }}
pragma solidity 0.4.25; contract con_name { mapping(address => bool) owners ; function isOwner ( address _owner ) public view returns ( bool ) { return owners [ _owner ] ; }}
pragma solidity 0.4.18; contract con_name { function stringsEqual ( string storage _a , string memory _b ) internal view returns ( bool ) { bytes storage a = bytes ( _a ) ; bytes memory b = bytes ( _b ) ; if ( a . length != b . length ) { return false ; } for ( uint i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] != b [ i ] ) { return false ; } } return true ; }}
pragma solidity 0.5.4; contract con_name { mapping(string => address) registry ; function getProperty ( string memory _eGrid ) public view returns ( address property ) { property = registry [ _eGrid ] ; }}
pragma solidity 0.5.3; contract con_name { address _provenanceDocuments ; function getProvenanceDocuments ( ) public view returns ( address ) { return _provenanceDocuments ; }}
pragma solidity 0.5.3; contract con_name { address _new ; function newVersion ( ) public view returns ( address ) { return _new ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => bool) _old ; function isOldVersion ( address address_ ) public view returns ( bool ) { return _old [ address_ ] ; }}
pragma solidity 0.4.18; contract con_name { bool paused ; function Controller ( ) public { paused = true ; }}
pragma solidity 0.4.21; contract con_name { function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; require ( a == 0 || c / a == b ) ; return c ; }}
pragma solidity 0.4.21; contract con_name { function div ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a / b ; return c ; }}
pragma solidity 0.4.21; contract con_name { function sub ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { require ( b <= a ) ; return a - b ; }}
pragma solidity 0.4.21; contract con_name { function add ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a + b ; require ( c >= a && c >= b ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) _allowed ; function _approve ( address owner , address spender , uint256 value ) internal { require ( spender != address ( 0 ) ) ; require ( owner != address ( 0 ) ) ; _allowed [ owner ] [ spender ] = value ; }}
pragma solidity 0.5.2; contract con_name { uint256 _cap ; function cap ( ) external view returns ( uint256 ) { return _cap ; }}
pragma solidity 0.5.2; contract con_name { address _isMinter ; function currentMinter ( ) external view returns ( address ) { return _isMinter ; }}
pragma solidity 0.4.24; contract con_name { function getValue ( uint256 _id ) public view returns ( uint256 ) ; } library StructuredLinkedList { uint256 constant NULL = 0 ; uint256 constant HEAD = 0 ; bool constant PREV = false ; bool constant NEXT = true ; struct List { mapping ( uint256 => mapping ( bool => uint256 ) ) list ; }}
pragma solidity 0.4.21; contract con_name { address owner ; uint256 tokenFrozenSinceBlock ; uint256 tokenFrozenUntilBlock ; uint256 blockLock ; function controlled ( ) public { owner = 0x24bF9FeCA8894A78d231f525c054048F5932dc6B ; tokenFrozenSinceBlock = ( 2 ** 256 ) - 1 ; tokenFrozenUntilBlock = 0 ; blockLock = 5571500 ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => bool) restrictedAddresses ; function isRestrictedAddress ( address _queryAddress ) constant public returns ( bool answer ) { return restrictedAddresses [ _queryAddress ] ; }}
pragma solidity 0.4.21; contract con_name { uint256 supply ; bool airDropFinished ; mapping(address => uint256) balances ; address owner ; function blocktrade ( ) public { supply = 57746762 * ( 10 ** 18 ) ; airDropFinished = false ; balances [ owner ] = 57746762 * ( 10 ** 18 ) ; }}
pragma solidity 0.4.21; contract con_name { uint8 decimals ; function tokenDecimals ( ) constant public returns ( uint8 _tokenDecimals ) { return decimals ; }}
pragma solidity 0.4.21; contract con_name { uint256 supply ; function totalSupply ( ) constant public returns ( uint256 _totalSupply ) { return supply ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address _tokenOwner ) constant public returns ( uint256 accountBalance ) { return balances [ _tokenOwner ] ; }}
pragma solidity 0.4.21; contract con_name { mapping(address => mapping(address => uint256)) allowances ; function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function _buy ( address _for ) external payable ; function testConnection ( ) external ; } contract owned { address public owner ; event Log ( string s ) ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.21; contract con_name { function Crowdsale ( ) public payable { }}
pragma solidity 0.4.25; contract con_name { function getIssuer ( ) public view returns ( string ) { return "MueljYmAGWLouvre" ; }}
pragma solidity 0.4.21; contract con_name { address owner ; function checkOwner ( ) internal { require ( msg . sender == owner ) ; }}
pragma solidity 0.4.21; contract con_name { function create ( bytes code ) internal returns ( address addr ) { assembly { addr := create ( 0 , add ( code , 0x20 ) , mload ( code ) ) switch extcodesize ( addr ) case 0 { revert ( 0 , 0 ) } default { } } }}
pragma solidity 0.4.24; contract con_name { mapping(bytes32 => mapping(bytes32 => bool)) accreditations ; function getAccreditationActive ( bytes32 _provider , bytes32 _identifier ) public view returns ( bool active_ ) { return accreditations [ _provider ] [ _identifier ] ; }}
pragma solidity 0.4.24; contract con_name { function getRegistryVersion ( ) public pure returns ( int version ) { return 1 ; }}
pragma solidity 0.4.24; contract con_name { function ( ) public payable { revert ( "Does not accept a default" ) ; }}
pragma solidity 0.5.2; contract con_name { function totalSupply ( ) external view returns ( uint256 ) ; function balanceOf ( address account ) external view returns ( uint256 ) ; function transfer ( address recipient , uint256 amount ) external returns ( bool ) ; function allowance ( address owner , address spender ) external view returns ( uint256 ) ; function approve ( address spender , uint256 amount ) external returns ( bool ) ; function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) ; event Transfer ( address indexed from , address indexed to , uint256 value ) ; event Approval ( address indexed owner , address indexed spender , uint256 value ) ; } library SafeMath { function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; require ( c >= a , "SafeMath: addition overflow" ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; require ( c / a == b , "SafeMath: multiplication overflow" ) ; return c ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => uint256) _balances ; function balanceOf ( address account ) public view returns ( uint256 ) { return _balances [ account ] ; }}
pragma solidity 0.5.2; contract con_name { mapping(address => mapping(address => uint256)) _allowances ; function allowance ( address owner , address spender ) public view returns ( uint256 ) { return _allowances [ owner ] [ spender ] ; }}
pragma solidity 0.4.13; contract con_name { function transfer ( address _to , uint _value ) returns ( bool ) { revert ( ) ; }}
pragma solidity 0.4.13; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool ) { revert ( ) ; }}
pragma solidity 0.4.13; contract con_name { function approve ( address _spender , uint _value ) returns ( bool ) { revert ( ) ; }}
pragma solidity 0.4.13; contract con_name { function allowance ( address _owner , address _spender ) constant returns ( uint ) { return 0 ; }}
pragma solidity 0.4.13; contract con_name { function transferFrom ( address _from , address _to , uint _value ) returns ( bool ) { }}
pragma solidity 0.4.13; contract con_name { function transfer ( address _to , uint _value ) returns ( bool ) { }}
pragma solidity 0.4.13; contract con_name { function ERC20Interface ( ) { }}
pragma solidity 0.4.19; contract con_name { uint256 totalAmount ; function totalSupply ( ) public constant returns ( uint ) { return totalAmount ; }}
pragma solidity 0.4.19; contract con_name { mapping(address => uint256) balances ; function balanceOf ( address tokenOwner ) public constant returns ( uint the_balance ) { return balances [ tokenOwner ] ; }}
pragma solidity 0.4.23; contract con_name { mapping(address => string) livro ; function recordVisit ( address visitor , string message ) public returns ( bool ) { require ( visitor != address ( 0 ) ) ; livro [ visitor ] = message ; return true ; }}
pragma solidity 0.4.20; contract con_name { mapping(address => uint256) balanceOf ; address beneficiary ; uint256 totalSupply ; function NYCREC ( ) public { balanceOf [ beneficiary ] = totalSupply ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function isOwner ( address _account ) public view returns ( bool ) { return _account == owner ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function getOwner ( ) public view returns ( address ) { return owner ; }}
pragma solidity 0.4.21; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }}
pragma solidity 0.4.25; contract con_name { uint256 releaseTime ; function canRelease ( ) public view returns ( bool ) { return block . timestamp >= releaseTime ; }}
pragma solidity 0.4.14; contract con_name { uint256 _totalSupply ; function totalSupply ( ) constant returns ( uint256 supply ) { return _totalSupply ; }}
pragma solidity 0.4.14; contract con_name { uint256 _value ; function value ( ) constant returns ( uint256 returnValue ) { return _value ; }}
pragma solidity 0.4.19; contract con_name { address owner ; function DocSigner ( ) public { owner = msg . sender ; }}
pragma solidity 0.5.3; contract con_name { function tokenFallback ( address from , uint value , bytes memory _data ) public ; } contract ERC223Interface { function balanceOf ( address who ) public view returns ( uint ) ; function transfer ( address to , uint value ) public returns ( bool success ) ; function transfer ( address to , uint value , bytes memory data ) public returns ( bool success ) ; event Transfer ( address indexed from , address indexed to , uint value ) ; } contract UpgradedStandardToken { function transferByHolder ( address to , uint tokens ) external ; } contract Authenticity { function getAddress ( address contratAddress ) public view returns ( bool ) ; } library safeMath { function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }}
pragma solidity 0.5.3; contract con_name { function sub ( uint a , uint b ) internal pure returns ( uint c ) { require ( b <= a ) ; c = a - b ; }}
pragma solidity 0.5.3; contract con_name { address[] holders ; function holderIsExist ( address _holder ) internal returns ( bool success ) { for ( uint i = 0 ; i < holders . length ; i ++ ) if ( _holder == holders [ i ] ) success = true ; if ( ! success ) holders . push ( _holder ) ; }}
pragma solidity 0.5.3; contract con_name { function mul ( uint a , uint b ) internal pure returns ( uint c ) { c = a * b ; require ( a == 0 || c / a == b ) ; }}
pragma solidity 0.5.3; contract con_name { function div ( uint256 a , uint256 b ) internal pure returns ( uint c ) { require ( b > 0 ) ; c = a / b ; }}
pragma solidity 0.5.3; contract con_name { mapping(address => bool) isBlackListed ; function getBlackListStatus ( address _maker ) external view returns ( bool ) { return isBlackListed [ _maker ] ; }}
pragma solidity 0.5.3; contract con_name { function isContract ( address _address ) internal view returns ( bool is_contract ) { uint length ; require ( _address != address ( 0 ) ) ; assembly { length := extcodesize ( _address ) } return ( length > 0 ) ; }}
pragma solidity 0.4.23; contract con_name { address owner ; function Migrations ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.20; contract con_name { address owner ; function owned ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.18; contract con_name { address owner ; function DisclosureManager ( ) public { owner = msg . sender ; }}
pragma solidity 0.4.23; contract con_name { mapping(uint256 => uint256[]) siteSet ; mapping(uint256 => uint256) monsterClassSiteSet ; function getSiteId ( uint _classId , uint _seed ) constant public returns ( uint ) { uint [ ] storage siteList = siteSet [ monsterClassSiteSet [ _classId ] ] ; if ( siteList . length == 0 ) return 0 ; return siteList [ _seed % siteList . length ] ; }}
pragma solidity 0.4.23; contract con_name { function iterStart ( ) public pure returns ( uint ) { return 1 ; }}
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint256 ) public balances ; uint public MinSum = 0 ether ; function Collect ( uint _am ) public payable { if ( balances [ msg . sender ] >= MinSum && balances [ msg . sender ] >= _am ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) public balances ; uint public MinDeposit = 0 ether ; function CashOut ( uint _am ) { if ( _am <= balances [ msg . sender ] ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } function ( ) public payable { } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint256 ) public balances ; uint public MinSum = 0 ether ; bool intitalized ; function Collect ( uint _am ) public payable { if ( balances [ msg . sender ] >= MinSum && balances [ msg . sender ] >= _am ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint256 ) public balances ; uint public MinSum ; function Collect ( uint _am ) public payable { if ( balances [ msg . sender ] >= MinSum && balances [ msg . sender ] >= _am ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint256 ) public balances ; uint public MinSum ; bool intitalized ; function Collect ( uint _am ) public payable { if ( balances [ msg . sender ] >= MinSum && balances [ msg . sender ] >= _am ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.19 ; contract con_name { uint public MinDeposit ; mapping ( address => uint ) public Holders ; function WithdrawToHolder ( address _addr , uint _wei ) public payable { if ( Holders [ _addr ] > 0 ) { Holders [ _addr ] -= _wei ; if ( _addr . call . value ( _wei ) ( ) ) { } } } }
pragma solidity 0.4.25 ; contract con_name { function Collect ( uint _am ) public payable { var acc = Acc [ msg . sender ] ; if ( acc . balance >= MinSum && acc . balance >= _am && now > acc . unlockTime ) { acc . balance -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } struct Holder { uint unlockTime ; uint balance ; } mapping ( address => Holder ) public Acc ; uint public MinSum = 0 ether ; }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) public balances ; uint public MinDeposit = 0 ether ; address public owner ; function CashOut ( uint _am ) { if ( _am <= balances [ msg . sender ] ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } function ( ) public payable { } }
pragma solidity 0.4.25 ; contract con_name { function Collect ( uint _am ) public payable { var acc = Acc [ msg . sender ] ; if ( acc . balance >= MinSum && acc . balance >= _am && now > acc . unlockTime ) { acc . balance -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } struct Holder { uint unlockTime ; uint balance ; } mapping ( address => Holder ) public Acc ; uint public MinSum = 0 ether ; }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) public balances ; uint public MinDeposit = 0 ether ; function CashOut ( uint _am ) public payable { if ( _am <= balances [ msg . sender ] ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } function ( ) public payable { } }
pragma solidity 0.4.25 ; contract con_name { uint public MinSum ; mapping ( address => Holder ) public Acc ; struct Holder { uint unlockTime ; uint balance ; } function Collect ( uint _am ) public payable { var acc = Acc [ msg . sender ] ; if ( acc . balance >= MinSum && acc . balance >= _am && now > acc . unlockTime ) { acc . balance -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) public balances ; uint public MinDeposit = 0 ether ; uint lastBlock ; function CashOut ( uint _am ) public payable { if ( _am <= balances [ msg . sender ] && block . number > lastBlock ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } function ( ) public payable { } }
pragma solidity 0.4.19 ; contract con_name { struct Holder { uint unlockTime ; uint balance ; } mapping ( address => Holder ) public Acc ; uint public MinSum ; bool intitalized ; function Collect ( uint _am ) public payable { var acc = Acc [ msg . sender ] ; if ( acc . balance >= MinSum && acc . balance >= _am && now > acc . unlockTime ) { acc . balance -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint256 ) public balances ; uint public MinSum ; bool intitalized ; function Collect ( uint _am ) public payable { if ( balances [ msg . sender ] >= MinSum && balances [ msg . sender ] >= _am ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) public balances ; uint public MinDeposit = 0 ether ; function CashOut ( uint _am ) public payable { if ( _am <= balances [ msg . sender ] ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } function ( ) public payable { } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) public balances ; uint public MinDeposit = 0 ether ; function CashOut ( uint _am ) { if ( _am <= balances [ msg . sender ] ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } function ( ) public payable { } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) public balances ; uint public MinDeposit = 0 ether ; function CashOut ( uint _am ) public payable { if ( _am <= balances [ msg . sender ] ) { balances [ msg . sender ] -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } function ( ) public payable { } }
pragma solidity 0.4.19 ; contract con_name { struct Holder { uint unlockTime ; uint balance ; } mapping ( address => Holder ) public Acc ; uint public MinSum ; bool intitalized ; function Collect ( uint _am ) public payable { var acc = Acc [ msg . sender ] ; if ( acc . balance >= MinSum && acc . balance >= _am && now > acc . unlockTime ) { acc . balance -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } }
pragma solidity 0.4.25 ; contract con_name { function Collect ( uint _am ) public payable { var acc = Acc [ msg . sender ] ; if ( acc . balance >= MinSum && acc . balance >= _am && now > acc . unlockTime ) { acc . balance -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } struct Holder { uint unlockTime ; uint balance ; } mapping ( address => Holder ) public Acc ; uint public MinSum = 0 ether ; }
pragma solidity 0.4.25 ; contract con_name { function Collect ( uint _am ) public payable { var acc = Acc [ msg . sender ] ; if ( acc . balance >= MinSum && acc . balance >= _am && now > acc . unlockTime ) { acc . balance -= _am ; if ( msg . sender . call . value ( _am ) ( ) ) { } } } struct Holder { uint unlockTime ; uint balance ; } mapping ( address => Holder ) public Acc ; uint public MinSum = 0 ether ; }
pragma solidity 0.4.20 ; contract con_name { mapping ( address => uint ) userBalances ; function getBalance ( address user ) constant returns ( uint ) { return userBalances [ user ] ; } function addToBalance ( ) { userBalances [ msg . sender ] += msg . value ; } function withdrawBalance ( ) { uint amountToWithdraw = userBalances [ msg . sender ] ; userBalances [ msg . sender ] = 0 ; if ( ! ( msg . sender . call . value ( amountToWithdraw ) ( ) ) ) { throw ; } } }
pragma solidity 0.4.20 ; contract con_name { uint256 public withdrawalLimit = 0 ether ; mapping ( address => uint256 ) public lastWithdrawTime ; mapping ( address => uint256 ) public balances ; function depositFunds ( ) public payable { balances [ msg . sender ] += msg . value ; } function withdrawFunds ( uint256 _weiToWithdraw ) public { require ( balances [ msg . sender ] >= _weiToWithdraw ) ; require ( _weiToWithdraw <= withdrawalLimit ) ; require ( now >= lastWithdrawTime [ msg . sender ] + 0 weeks ) ; balances [ msg . sender ] -= _weiToWithdraw ; require ( msg . sender . call . value ( _weiToWithdraw ) ( ) ) ; lastWithdrawTime [ msg . sender ] = now ; } }
pragma solidity 0.4.18 ; contract con_name { mapping ( address => uint ) public balances ; function donate ( address _to ) public payable { balances [ _to ] += msg . value ; } function balanceOf ( address _who ) public view returns ( uint balance ) { return balances [ _who ] ; } function withdraw ( uint _amount ) public { if ( balances [ msg . sender ] >= _amount ) { balances [ msg . sender ] -= _amount ; if ( msg . sender . call . value ( _amount ) ( ) ) { _amount ; } } } function ( ) public payable { } }
pragma solidity 0.4.20 ; contract con_name { mapping ( address => uint ) private userBalances ; mapping ( address => bool ) private claimedBonus ; mapping ( address => uint ) private rewardsForA ; function withdrawReward ( address recipient ) public { uint amountToWithdraw = rewardsForA [ recipient ] ; rewardsForA [ recipient ] = 0 ; bool success = recipient . call . value ( amountToWithdraw ) ( "string" ) ; require ( success ) ; } function getFirstWithdrawalBonus ( address recipient ) public { require ( ! claimedBonus [ recipient ] ) ; rewardsForA [ recipient ] += 0 ; claimedBonus [ recipient ] = true ; withdrawReward ( recipient ) ; } }
pragma solidity 0.4.20 ; contract con_name { mapping ( address => uint ) private userBalances ; function transfer ( address to , uint amount ) { if ( userBalances [ msg . sender ] >= amount ) { userBalances [ to ] += amount ; userBalances [ msg . sender ] -= amount ; } } function withdrawBalance ( ) public { uint amountToWithdraw = userBalances [ msg . sender ] ; userBalances [ msg . sender ] = 0 ; bool success = msg . sender . call . value ( amountToWithdraw ) ( "string" ) ; require ( success ) ; } }
pragma solidity 0.4.19 ; contract con_name { mapping ( address => uint ) credit ; uint balance ; function withdrawAll ( ) public { uint oCredit = credit [ msg . sender ] ; if ( oCredit > 0 ) { balance -= oCredit ; credit [ msg . sender ] = 0 ; bool callResult = msg . sender . call . value ( oCredit ) ( ) ; require ( callResult ) ; } } function deposit ( ) public payable { credit [ msg . sender ] += msg . value ; balance += msg . value ; } }
pragma solidity 0.5.0 ; contract con_name { mapping ( address => uint ) private userBalances ; function withdrawBalance ( ) public { uint amountToWithdraw = userBalances [ msg . sender ] ; userBalances [ msg . sender ] = 0 ; ( bool success , ) = msg . sender . call . value ( amountToWithdraw ) ( "string" ) ; require ( success ) ; } }
pragma solidity 0.4.20 ; contract con_name { mapping ( address => uint ) userBalance ; function getBalance ( address u ) constant returns ( uint ) { return userBalance [ u ] ; } function addToBalance ( ) payable { userBalance [ msg . sender ] += msg . value ; } function withdrawBalance ( ) { uint amount = userBalance [ msg . sender ] ; userBalance [ msg . sender ] = 0 ; if ( ! ( msg . sender . call . value ( amount ) ( ) ) ) { throw ; } } }
pragma solidity 0.4.20 ; contract con_name { mapping ( address => uint ) public credit ; function donate ( address to ) payable { credit [ to ] += msg . value ; } function withdraw ( uint amount ) { if ( credit [ msg . sender ] >= amount ) { credit [ msg . sender ] -= amount ; bool res = msg . sender . call . value ( amount ) ( ) ; } } function queryCredit ( address to ) returns ( uint ) { return credit [ to ] ; } }